fb645e22525bcedbd671fbc2c8d669b5










'use strict';var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _get = function get(object, property, receiver) {if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {var parent = Object.getPrototypeOf(object);if (parent === null) {return undefined;} else {return get(parent, property, receiver);}} else if ("value" in desc) {return desc.value;} else {var getter = desc.get;if (getter === undefined) {return undefined;}return getter.call(receiver);}};var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self, call) {if (!self) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call && (typeof call === "object" || typeof call === "function") ? call : self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;}

var AnimatedNode = require('./AnimatedNode');
var AnimatedWithChildren = require('./AnimatedWithChildren');
var NativeAnimatedHelper = require('../NativeAnimatedHelper');

var invariant = require('fbjs/lib/invariant');
var normalizeColor = require('normalizeColor');
















var linear = function linear(t) {return t;};





function createInterpolation(
config)
{
  if (config.outputRange && typeof config.outputRange[0] === 'string') {
    return createInterpolationFromStringOutputRange(config);
  }

  var outputRange = config.outputRange;
  checkInfiniteRange('outputRange', outputRange);

  var inputRange = config.inputRange;
  checkInfiniteRange('inputRange', inputRange);
  checkValidInputRange(inputRange);

  invariant(
  inputRange.length === outputRange.length,
  'inputRange (' +
  inputRange.length +
  ') and outputRange (' +
  outputRange.length +
  ') must have the same length');


  var easing = config.easing || linear;

  var extrapolateLeft = 'extend';
  if (config.extrapolateLeft !== undefined) {
    extrapolateLeft = config.extrapolateLeft;
  } else if (config.extrapolate !== undefined) {
    extrapolateLeft = config.extrapolate;
  }

  var extrapolateRight = 'extend';
  if (config.extrapolateRight !== undefined) {
    extrapolateRight = config.extrapolateRight;
  } else if (config.extrapolate !== undefined) {
    extrapolateRight = config.extrapolate;
  }

  return function (input) {
    invariant(
    typeof input === 'number',
    'Cannot interpolation an input which is not a number');


    var range = findRange(input, inputRange);
    return interpolate(
    input,
    inputRange[range],
    inputRange[range + 1],
    outputRange[range],
    outputRange[range + 1],
    easing,
    extrapolateLeft,
    extrapolateRight);

  };
}

function interpolate(
input,
inputMin,
inputMax,
outputMin,
outputMax,
easing,
extrapolateLeft,
extrapolateRight)
{
  var result = input;


  if (result < inputMin) {
    if (extrapolateLeft === 'identity') {
      return result;
    } else if (extrapolateLeft === 'clamp') {
      result = inputMin;
    } else if (extrapolateLeft === 'extend') {

    }
  }

  if (result > inputMax) {
    if (extrapolateRight === 'identity') {
      return result;
    } else if (extrapolateRight === 'clamp') {
      result = inputMax;
    } else if (extrapolateRight === 'extend') {

    }
  }

  if (outputMin === outputMax) {
    return outputMin;
  }

  if (inputMin === inputMax) {
    if (input <= inputMin) {
      return outputMin;
    }
    return outputMax;
  }


  if (inputMin === -Infinity) {
    result = -result;
  } else if (inputMax === Infinity) {
    result = result - inputMin;
  } else {
    result = (result - inputMin) / (inputMax - inputMin);
  }


  result = easing(result);


  if (outputMin === -Infinity) {
    result = -result;
  } else if (outputMax === Infinity) {
    result = result + outputMin;
  } else {
    result = result * (outputMax - outputMin) + outputMin;
  }

  return result;
}

function colorToRgba(input) {
  var int32Color = normalizeColor(input);
  if (int32Color === null) {
    return input;
  }

  int32Color = int32Color || 0;

  var r = (int32Color & 0xff000000) >>> 24;
  var g = (int32Color & 0x00ff0000) >>> 16;
  var b = (int32Color & 0x0000ff00) >>> 8;
  var a = (int32Color & 0x000000ff) / 255;

  return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
}

var stringShapeRegex = /[0-9\.-]+/g;









function createInterpolationFromStringOutputRange(
config)
{
  var outputRange = config.outputRange;
  invariant(outputRange.length >= 2, 'Bad output range');
  outputRange = outputRange.map(colorToRgba);
  checkPattern(outputRange);












  var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {return [];});
  outputRange.forEach(function (value) {



    value.match(stringShapeRegex).forEach(function (number, i) {
      outputRanges[i].push(+number);
    });
  });




  var interpolations = outputRange[0].
  match(stringShapeRegex).
  map(function (value, i) {
    return createInterpolation(_extends({},
    config, {
      outputRange: outputRanges[i] }));

  });



  var shouldRound = isRgbOrRgba(outputRange[0]);

  return function (input) {
    var i = 0;



    return outputRange[0].replace(stringShapeRegex, function () {
      var val = +interpolations[i++](input);
      var rounded =
      shouldRound && i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
      return String(rounded);
    });
  };
}

function isRgbOrRgba(range) {
  return typeof range === 'string' && range.startsWith('rgb');
}

function checkPattern(arr) {
  var pattern = arr[0].replace(stringShapeRegex, '');
  for (var i = 1; i < arr.length; ++i) {
    invariant(
    pattern === arr[i].replace(stringShapeRegex, ''),
    'invalid pattern ' + arr[0] + ' and ' + arr[i]);

  }
}

function findRange(input, inputRange) {
  var i = void 0;
  for (i = 1; i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) {
      break;
    }
  }
  return i - 1;
}

function checkValidInputRange(arr) {
  invariant(arr.length >= 2, 'inputRange must have at least 2 elements');
  for (var i = 1; i < arr.length; ++i) {
    invariant(
    arr[i] >= arr[i - 1],






    'inputRange must be monotonically non-decreasing ' + arr);

  }
}

function checkInfiniteRange(name, arr) {
  invariant(arr.length >= 2, name + ' must have at least 2 elements');
  invariant(
  arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,






  name + 'cannot be ]-infinity;+infinity[ ' + arr);

}var

AnimatedInterpolation = function (_AnimatedWithChildren) {_inherits(AnimatedInterpolation, _AnimatedWithChildren);







  function AnimatedInterpolation(parent, config) {_classCallCheck(this, AnimatedInterpolation);var _this = _possibleConstructorReturn(this, (AnimatedInterpolation.__proto__ || Object.getPrototypeOf(AnimatedInterpolation)).call(this));

    _this._parent = parent;
    _this._config = config;
    _this._interpolation = createInterpolation(config);return _this;
  }_createClass(AnimatedInterpolation, [{ key: '__makeNative', value: function __makeNative()

    {
      this._parent.__makeNative();
      _get(AnimatedInterpolation.prototype.__proto__ || Object.getPrototypeOf(AnimatedInterpolation.prototype), '__makeNative', this).call(this);
    } }, { key: '__getValue', value: function __getValue()

    {
      var parentValue = this._parent.__getValue();
      invariant(
      typeof parentValue === 'number',
      'Cannot interpolate an input which is not a number.');

      return this._interpolation(parentValue);
    } }, { key: 'interpolate', value: function interpolate(

    config) {
      return new AnimatedInterpolation(this, config);
    } }, { key: '__attach', value: function __attach()

    {
      this._parent.__addChild(this);
    } }, { key: '__detach', value: function __detach()

    {
      this._parent.__removeChild(this);
      _get(AnimatedInterpolation.prototype.__proto__ || Object.getPrototypeOf(AnimatedInterpolation.prototype), '__detach', this).call(this);
    } }, { key: '__transformDataType', value: function __transformDataType(

    range) {





      return range.map(function (value) {
        if (typeof value !== 'string') {
          return value;
        }
        if (/deg$/.test(value)) {
          var degrees = parseFloat(value) || 0;
          var radians = degrees * Math.PI / 180.0;
          return radians;
        } else {

          return parseFloat(value) || 0;
        }
      });
    } }, { key: '__getNativeConfig', value: function __getNativeConfig()

    {
      if (__DEV__) {
        NativeAnimatedHelper.validateInterpolation(this._config);
      }

      return {
        inputRange: this._config.inputRange,

        outputRange: this.__transformDataType(this._config.outputRange),
        extrapolateLeft:
        this._config.extrapolateLeft || this._config.extrapolate || 'extend',
        extrapolateRight:
        this._config.extrapolateRight || this._config.extrapolate || 'extend',
        type: 'interpolation' };

    } }]);return AnimatedInterpolation;}(AnimatedWithChildren);AnimatedInterpolation.__createInterpolation = createInterpolation;


module.exports = AnimatedInterpolation;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFuaW1hdGVkSW50ZXJwb2xhdGlvbi5qcyJdLCJuYW1lcyI6WyJBbmltYXRlZE5vZGUiLCJyZXF1aXJlIiwiQW5pbWF0ZWRXaXRoQ2hpbGRyZW4iLCJOYXRpdmVBbmltYXRlZEhlbHBlciIsImludmFyaWFudCIsIm5vcm1hbGl6ZUNvbG9yIiwibGluZWFyIiwidCIsImNyZWF0ZUludGVycG9sYXRpb24iLCJjb25maWciLCJvdXRwdXRSYW5nZSIsImNyZWF0ZUludGVycG9sYXRpb25Gcm9tU3RyaW5nT3V0cHV0UmFuZ2UiLCJjaGVja0luZmluaXRlUmFuZ2UiLCJpbnB1dFJhbmdlIiwiY2hlY2tWYWxpZElucHV0UmFuZ2UiLCJsZW5ndGgiLCJlYXNpbmciLCJleHRyYXBvbGF0ZUxlZnQiLCJ1bmRlZmluZWQiLCJleHRyYXBvbGF0ZSIsImV4dHJhcG9sYXRlUmlnaHQiLCJpbnB1dCIsInJhbmdlIiwiZmluZFJhbmdlIiwiaW50ZXJwb2xhdGUiLCJpbnB1dE1pbiIsImlucHV0TWF4Iiwib3V0cHV0TWluIiwib3V0cHV0TWF4IiwicmVzdWx0IiwiSW5maW5pdHkiLCJjb2xvclRvUmdiYSIsImludDMyQ29sb3IiLCJyIiwiZyIsImIiLCJhIiwic3RyaW5nU2hhcGVSZWdleCIsIm1hcCIsImNoZWNrUGF0dGVybiIsIm91dHB1dFJhbmdlcyIsIm1hdGNoIiwiZm9yRWFjaCIsInZhbHVlIiwibnVtYmVyIiwiaSIsInB1c2giLCJpbnRlcnBvbGF0aW9ucyIsInNob3VsZFJvdW5kIiwiaXNSZ2JPclJnYmEiLCJyZXBsYWNlIiwidmFsIiwicm91bmRlZCIsIk1hdGgiLCJyb3VuZCIsIlN0cmluZyIsInN0YXJ0c1dpdGgiLCJhcnIiLCJwYXR0ZXJuIiwibmFtZSIsIkFuaW1hdGVkSW50ZXJwb2xhdGlvbiIsInBhcmVudCIsIl9wYXJlbnQiLCJfY29uZmlnIiwiX2ludGVycG9sYXRpb24iLCJfX21ha2VOYXRpdmUiLCJwYXJlbnRWYWx1ZSIsIl9fZ2V0VmFsdWUiLCJfX2FkZENoaWxkIiwiX19yZW1vdmVDaGlsZCIsInRlc3QiLCJkZWdyZWVzIiwicGFyc2VGbG9hdCIsInJhZGlhbnMiLCJQSSIsIl9fREVWX18iLCJ2YWxpZGF0ZUludGVycG9sYXRpb24iLCJfX3RyYW5zZm9ybURhdGFUeXBlIiwidHlwZSIsIl9fY3JlYXRlSW50ZXJwb2xhdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFVQSxhOztBQUVBLElBQU1BLGVBQWVDLFFBQVEsZ0JBQVIsQ0FBckI7QUFDQSxJQUFNQyx1QkFBdUJELFFBQVEsd0JBQVIsQ0FBN0I7QUFDQSxJQUFNRSx1QkFBdUJGLFFBQVEseUJBQVIsQ0FBN0I7O0FBRUEsSUFBTUcsWUFBWUgsUUFBUSxvQkFBUixDQUFsQjtBQUNBLElBQU1JLGlCQUFpQkosUUFBUSxnQkFBUixDQUF2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFBTUssU0FBUyxTQUFUQSxNQUFTLFlBQUtDLENBQUwsRUFBZjs7Ozs7O0FBTUEsU0FBU0MsbUJBQVQ7QUFDRUMsTUFERjtBQUVzQztBQUNwQyxNQUFJQSxPQUFPQyxXQUFQLElBQXNCLE9BQU9ELE9BQU9DLFdBQVAsQ0FBbUIsQ0FBbkIsQ0FBUCxLQUFpQyxRQUEzRCxFQUFxRTtBQUNuRSxXQUFPQyx5Q0FBeUNGLE1BQXpDLENBQVA7QUFDRDs7QUFFRCxNQUFNQyxjQUE4QkQsT0FBT0MsV0FBM0M7QUFDQUUscUJBQW1CLGFBQW5CLEVBQWtDRixXQUFsQzs7QUFFQSxNQUFNRyxhQUFhSixPQUFPSSxVQUExQjtBQUNBRCxxQkFBbUIsWUFBbkIsRUFBaUNDLFVBQWpDO0FBQ0FDLHVCQUFxQkQsVUFBckI7O0FBRUFUO0FBQ0VTLGFBQVdFLE1BQVgsS0FBc0JMLFlBQVlLLE1BRHBDO0FBRUU7QUFDRUYsYUFBV0UsTUFEYjtBQUVFLHVCQUZGO0FBR0VMLGNBQVlLLE1BSGQ7QUFJRSwrQkFOSjs7O0FBU0EsTUFBTUMsU0FBU1AsT0FBT08sTUFBUCxJQUFpQlYsTUFBaEM7O0FBRUEsTUFB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a0QsT0FBTCxDQUFhbEQsVUFEcEI7O0FBR0xILHFCQUFhLEtBQUttRSxtQkFBTCxDQUF5QixLQUFLZCxPQUFMLENBQWFyRCxXQUF0QyxDQUhSO0FBSUxPO0FBQ0UsYUFBSzhDLE9BQUwsQ0FBYTlDLGVBQWIsSUFBZ0MsS0FBSzhDLE9BQUwsQ0FBYTVDLFdBQTdDLElBQTRELFFBTHpEO0FBTUxDO0FBQ0UsYUFBSzJDLE9BQUwsQ0FBYTNDLGdCQUFiLElBQWlDLEtBQUsyQyxPQUFMLENBQWE1QyxXQUE5QyxJQUE2RCxRQVAxRDtBQVFMMkQsY0FBTSxlQVJELEVBQVA7O0FBVUQsSyxvQ0E5RWlDNUUsb0IsRUFBOUIwRCxxQixDQUVHbUIscUIsR0FBd0J2RSxtQjs7O0FBK0VqQ3dFLE9BQU9DLE9BQVAsR0FBaUJyQixxQkFBakIiLCJmaWxlIjoiQW5pbWF0ZWRJbnRlcnBvbGF0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICogQGZvcm1hdFxuICovXG4vKiBlc2xpbnQgbm8tYml0d2lzZTogMCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBbmltYXRlZE5vZGUgPSByZXF1aXJlKCcuL0FuaW1hdGVkTm9kZScpO1xuY29uc3QgQW5pbWF0ZWRXaXRoQ2hpbGRyZW4gPSByZXF1aXJlKCcuL0FuaW1hdGVkV2l0aENoaWxkcmVuJyk7XG5jb25zdCBOYXRpdmVBbmltYXRlZEhlbHBlciA9IHJlcXVpcmUoJy4uL05hdGl2ZUFuaW1hdGVkSGVscGVyJyk7XG5cbmNvbnN0IGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuY29uc3Qgbm9ybWFsaXplQ29sb3IgPSByZXF1aXJlKCdub3JtYWxpemVDb2xvcicpO1xuXG50eXBlIEV4dHJhcG9sYXRlVHlwZSA9ICdleHRlbmQnIHwgJ2lkZW50aXR5JyB8ICdjbGFtcCc7XG5cbmV4cG9ydCB0eXBlIEludGVycG9sYXRpb25Db25maWdUeXBlID0ge1xuICBpbnB1dFJhbmdlOiBBcnJheTxudW1iZXI+LFxuICAvKiAkRmxvd0ZpeE1lKD49MC4zOC4wIHNpdGU9cmVhY3RfbmF0aXZlX2ZiLHJlYWN0X25hdGl2ZV9vc3MpIC0gRmxvdyBlcnJvclxuICAgKiBkZXRlY3RlZCBkdXJpbmcgdGhlIGRlcGxveW1lbnQgb2YgdjAuMzguMC4gVG8gc2VlIHRoZSBlcnJvciwgcmVtb3ZlIHRoaXNcbiAgICogY29tbWVudCBhbmQgcnVuIGZsb3dcbiAgICovXG4gIG91dHB1dFJhbmdlOiBBcnJheTxudW1iZXI+IHwgQXJyYXk8c3RyaW5nPixcbiAgZWFzaW5nPzogKGlucHV0OiBudW1iZXIpID0+IG51bWJlcixcbiAgZXh0cmFwb2xhdGU/OiBFeHRyYXBvbGF0ZVR5cGUsXG4gIGV4dHJhcG9sYXRlTGVmdD86IEV4dHJhcG9sYXRlVHlwZSxcbiAgZXh0cmFwb2xhdGVSaWdodD86IEV4dHJhcG9sYXRlVHlwZSxcbn07XG5cbmNvbnN0IGxpbmVhciA9IHQgPT4gdDtcblxuLyoqXG4gKiBWZXJ5IGhhbmR5IGhlbHBlciB0byBtYXAgaW5wdXQgcmFuZ2VzIHRvIG91dHB1dCByYW5nZXMgd2l0aCBhbiBlYXNpbmdcbiAqIGZ1bmN0aW9uIGFuZCBjdXN0b20gYmVoYXZpb3Igb3V0c2lkZSBvZiB0aGUgcmFuZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcnBvbGF0aW9uKFxuICBjb25maWc6IEludGVycG9sYXRpb25Db25maWdUeXBlLFxuKTogKGlucHV0OiBudW1iZXIpID0+IG51bWJlciB8IHN0cmluZyB7XG4gIGlmIChjb25maWcub3V0cHV0UmFuZ2UgJiYgdHlwZW9mIGNvbmZpZy5vdXRwdXRSYW5nZVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY3JlYXRlSW50ZXJwb2xhdGlvbkZyb21TdHJpbmdPdXRwdXRSYW5nZShjb25maWcpO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0UmFuZ2U6IEFycmF5PG51bWJlcj4gPSAoY29uZmlnLm91dHB1dFJhbmdlOiBhbnkpO1xuICBjaGVja0luZmluaXRlUmFuZ2UoJ291dHB1dFJhbmdlJywgb3V0cHV0UmFuZ2UpO1xuXG4gIGNvbnN0IGlucHV0UmFuZ2UgPSBjb25maWcuaW5wdXRSYW5nZTtcbiAgY2hlY2tJbmZpbml0ZVJhbmdlKCdpbnB1dFJhbmdlJywgaW5wdXRSYW5nZSk7XG4gIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGlucHV0UmFuZ2UpO1xuXG4gIGludmFyaWFudChcbiAgICBpbnB1dFJhbmdlLmxlbmd0aCA9PT0gb3V0cHV0UmFuZ2UubGVuZ3RoLFxuICAgICdpbnB1dFJhbmdlICgnICtcbiAgICAgIGlucHV0UmFuZ2UubGVuZ3RoICtcbiAgICAgICcpIGFuZCBvdXRwdXRSYW5nZSAoJyArXG4gICAgICBvdXRwdXRSYW5nZS5sZW5ndGggK1xuICAgICAgJykgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcsXG4gICk7XG5cbiAgY29uc3QgZWFzaW5nID0gY29uZmlnLmVhc2luZyB8fCBsaW5lYXI7XG5cbiAgbGV0IGV4dHJhcG9sYXRlTGVmdDogRXh0cmFwb2xhdGVUeXBlID0gJ2V4dGVuZCc7XG4gIGlmIChjb25maWcuZXh0cmFwb2xhdGVMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBjb25maWcuZXh0cmFwb2xhdGVMZWZ0O1xuICB9IGVsc2UgaWYgKGNvbmZpZy5leHRyYXBvbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmFwb2xhdGVMZWZ0ID0gY29uZmlnLmV4dHJhcG9sYXRlO1xuICB9XG5cbiAgbGV0IGV4dHJhcG9sYXRlUmlnaHQ6IEV4dHJhcG9sYXRlVHlwZSA9ICdleHRlbmQnO1xuICBpZiAoY29uZmlnLmV4dHJhcG9sYXRlUmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlUmlnaHQgPSBjb25maWcuZXh0cmFwb2xhdGVSaWdodDtcbiAgfSBlbHNlIGlmIChjb25maWcuZXh0cmFwb2xhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlUmlnaHQgPSBjb25maWcuZXh0cmFwb2xhdGU7XG4gIH1cblxuICByZXR1cm4gaW5wdXQgPT4ge1xuICAgIGludmFyaWFudChcbiAgICAgIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicsXG4gICAgICAnQ2Fubm90IGludGVycG9sYXRpb24gYW4gaW5wdXQgd2hpY2ggaXMgbm90IGEgbnVtYmVyJyxcbiAgICApO1xuXG4gICAgY29uc3QgcmFuZ2UgPSBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZShcbiAgICAgIGlucHV0LFxuICAgICAgaW5wdXRSYW5nZVtyYW5nZV0sXG4gICAgICBpbnB1dFJhbmdlW3JhbmdlICsgMV0sXG4gICAgICBvdXRwdXRSYW5nZVtyYW5nZV0sXG4gICAgICBvdXRwdXRSYW5nZVtyYW5nZSArIDFdLFxuICAgICAgZWFzaW5nLFxuICAgICAgZXh0cmFwb2xhdGVMZWZ0LFxuICAgICAgZXh0cmFwb2xhdGVSaWdodCxcbiAgICApO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShcbiAgaW5wdXQ6IG51bWJlcixcbiAgaW5wdXRNaW46IG51bWJlcixcbiAgaW5wdXRNYXg6IG51bWJlcixcbiAgb3V0cHV0TWluOiBudW1iZXIsXG4gIG91dHB1dE1heDogbnVtYmVyLFxuICBlYXNpbmc6IChpbnB1dDogbnVtYmVyKSA9PiBudW1iZXIsXG4gIGV4dHJhcG9sYXRlTGVmdDogRXh0cmFwb2xhdGVUeXBlLFxuICBleHRyYXBvbGF0ZVJpZ2h0OiBFeHRyYXBvbGF0ZVR5cGUsXG4pIHtcbiAgbGV0IHJlc3VsdCA9IGlucHV0O1xuXG4gIC8vIEV4dHJhcG9sYXRlXG4gIGlmIChyZXN1bHQgPCBpbnB1dE1pbikge1xuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09ICdpZGVudGl0eScpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09ICdjbGFtcCcpIHtcbiAgICAgIHJlc3VsdCA9IGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSAnZXh0ZW5kJykge1xuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGlmIChyZXN1bHQgPiBpbnB1dE1heCkge1xuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gJ2NsYW1wJykge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNYXg7XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSAnZXh0ZW5kJykge1xuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGlmIChvdXRwdXRNaW4gPT09IG91dHB1dE1heCkge1xuICAgIHJldHVybiBvdXRwdXRNaW47XG4gIH1cblxuICBpZiAoaW5wdXRNaW4gPT09IGlucHV0TWF4KSB7XG4gICAgaWYgKGlucHV0IDw9IGlucHV0TWluKSB7XG4gICAgICByZXR1cm4gb3V0cHV0TWluO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0TWF4O1xuICB9XG5cbiAgLy8gSW5wdXQgUmFuZ2VcbiAgaWYgKGlucHV0TWluID09PSAtSW5maW5pdHkpIHtcbiAgICByZXN1bHQgPSAtcmVzdWx0O1xuICB9IGVsc2UgaWYgKGlucHV0TWF4ID09PSBJbmZpbml0eSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCAtIGlucHV0TWluO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIH1cblxuICAvLyBFYXNpbmdcbiAgcmVzdWx0ID0gZWFzaW5nKHJlc3VsdCk7XG5cbiAgLy8gT3V0cHV0IFJhbmdlXG4gIGlmIChvdXRwdXRNaW4gPT09IC1JbmZpbml0eSkge1xuICAgIHJlc3VsdCA9IC1yZXN1bHQ7XG4gIH0gZWxzZSBpZiAob3V0cHV0TWF4ID09PSBJbmZpbml0eSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIG91dHB1dE1pbjtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvbG9yVG9SZ2JhKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgaW50MzJDb2xvciA9IG5vcm1hbGl6ZUNvbG9yKGlucHV0KTtcbiAgaWYgKGludDMyQ29sb3IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBpbnQzMkNvbG9yID0gaW50MzJDb2xvciB8fCAwO1xuXG4gIGNvbnN0IHIgPSAoaW50MzJDb2xvciAmIDB4ZmYwMDAwMDApID4+PiAyNDtcbiAgY29uc3QgZyA9IChpbnQzMkNvbG9yICYgMHgwMGZmMDAwMCkgPj4+IDE2O1xuICBjb25zdCBiID0gKGludDMyQ29sb3IgJiAweDAwMDBmZjAwKSA+Pj4gODtcbiAgY29uc3QgYSA9IChpbnQzMkNvbG9yICYgMHgwMDAwMDBmZikgLyAyNTU7XG5cbiAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7YX0pYDtcbn1cblxuY29uc3Qgc3RyaW5nU2hhcGVSZWdleCA9IC9bMC05XFwuLV0rL2c7XG5cbi8qKlxuICogU3VwcG9ydHMgc3RyaW5nIHNoYXBlcyBieSBleHRyYWN0aW5nIG51bWJlcnMgc28gbmV3IHZhbHVlcyBjYW4gYmUgY29tcHV0ZWQsXG4gKiBhbmQgcmVjb21iaW5lcyB0aG9zZSB2YWx1ZXMgaW50byBuZXcgc3RyaW5ncyBvZiB0aGUgc2FtZSBzaGFwZS4gIFN1cHBvcnRzXG4gKiB0aGluZ3MgbGlrZTpcbiAqXG4gKiAgIHJnYmEoMTIzLCA0MiwgOTksIDAuMzYpIC8vIGNvbG9yc1xuICogICAtNDVkZWcgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgd2l0aCB1bml0c1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcnBvbGF0aW9uRnJvbVN0cmluZ091dHB1dFJhbmdlKFxuICBjb25maWc6IEludGVycG9sYXRpb25Db25maWdUeXBlLFxuKTogKGlucHV0OiBudW1iZXIpID0+IHN0cmluZyB7XG4gIGxldCBvdXRwdXRSYW5nZTogQXJyYXk8c3RyaW5nPiA9IChjb25maWcub3V0cHV0UmFuZ2U6IGFueSk7XG4gIGludmFyaWFudChvdXRwdXRSYW5nZS5sZW5ndGggPj0gMiwgJ0JhZCBvdXRwdXQgcmFuZ2UnKTtcbiAgb3V0cHV0UmFuZ2UgPSBvdXRwdXRSYW5nZS5tYXAoY29sb3JUb1JnYmEpO1xuICBjaGVja1BhdHRlcm4ob3V0cHV0UmFuZ2UpO1xuXG4gIC8vIFsncmdiYSgwLCAxMDAsIDIwMCwgMCknLCAncmdiYSg1MCwgMTUwLCAyNTAsIDAuNSknXVxuICAvLyAtPlxuICAvLyBbXG4gIC8vICAgWzAsIDUwXSxcbiAgLy8gICBbMTAwLCAxNTBdLFxuICAvLyAgIFsyMDAsIDI1MF0sXG4gIC8vICAgWzAsIDAuNV0sXG4gIC8vIF1cbiAgLyogJEZsb3dGaXhNZSg+PTAuMTguMCk6IGBvdXRwdXRSYW5nZVswXS5tYXRjaCgpYCBjYW4gcmV0dXJuIGBudWxsYC4gTmVlZCB0b1xuICAgKiBndWFyZCBhZ2FpbnN0IHRoaXMgcG9zc2liaWxpdHkuXG4gICAqL1xuICBjb25zdCBvdXRwdXRSYW5nZXMgPSBvdXRwdXRSYW5nZVswXS5tYXRjaChzdHJpbmdTaGFwZVJlZ2V4KS5tYXAoKCkgPT4gW10pO1xuICBvdXRwdXRSYW5nZS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAvKiAkRmxvd0ZpeE1lKD49MC4xOC4wKTogYHZhbHVlLm1hdGNoKClgIGNhbiByZXR1cm4gYG51bGxgLiBOZWVkIHRvIGd1YXJkXG4gICAgICogYWdhaW5zdCB0aGlzIHBvc3NpYmlsaXR5LlxuICAgICAqL1xuICAgIHZhbHVlLm1hdGNoKHN0cmluZ1NoYXBlUmVnZXgpLmZvckVhY2goKG51bWJlciwgaSkgPT4ge1xuICAgICAgb3V0cHV0UmFuZ2VzW2ldLnB1c2goK251bWJlcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qICRGbG93Rml4TWUoPj0wLjE4LjApOiBgb3V0cHV0UmFuZ2VbMF0ubWF0Y2goKWAgY2FuIHJldHVybiBgbnVsbGAuIE5lZWQgdG9cbiAgICogZ3VhcmQgYWdhaW5zdCB0aGlzIHBvc3NpYmlsaXR5LlxuICAgKi9cbiAgY29uc3QgaW50ZXJwb2xhdGlvbnMgPSBvdXRwdXRSYW5nZVswXVxuICAgIC5tYXRjaChzdHJpbmdTaGFwZVJlZ2V4KVxuICAgIC5tYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlSW50ZXJwb2xhdGlvbih7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgb3V0cHV0UmFuZ2U6IG91dHB1dFJhbmdlc1tpXSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIC8vIHJnYmEgcmVxdWlyZXMgdGhhdCB0aGUgcixnLGIgYXJlIGludGVnZXJzLi4uLiBzbyB3ZSB3YW50IHRvIHJvdW5kIHRoZW0sIGJ1dCB3ZSAqZG9udCogd2FudCB0b1xuICAvLyByb3VuZCB0aGUgb3BhY2l0eSAoNHRoIGNvbHVtbikuXG4gIGNvbnN0IHNob3VsZFJvdW5kID0gaXNSZ2JPclJnYmEob3V0cHV0UmFuZ2VbMF0pO1xuXG4gIHJldHVybiBpbnB1dCA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vICdyZ2JhKDAsIDEwMCwgMjAwLCAwKSdcbiAgICAvLyAtPlxuICAgIC8vICdyZ2JhKCR7aW50ZXJwb2xhdGlvbnNbMF0oaW5wdXQpfSwgJHtpbnRlcnBvbGF0aW9uc1sxXShpbnB1dCl9LCAuLi4nXG4gICAgcmV0dXJuIG91dHB1dFJhbmdlWzBdLnJlcGxhY2Uoc3RyaW5nU2hhcGVSZWdleCwgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gK2ludGVycG9sYXRpb25zW2krK10oaW5wdXQpO1xuICAgICAgY29uc3Qgcm91bmRlZCA9XG4gICAgICAgIHNob3VsZFJvdW5kICYmIGkgPCA0ID8gTWF0aC5yb3VuZCh2YWwpIDogTWF0aC5yb3VuZCh2YWwgKiAxMDAwKSAvIDEwMDA7XG4gICAgICByZXR1cm4gU3RyaW5nKHJvdW5kZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1JnYk9yUmdiYShyYW5nZSkge1xuICByZXR1cm4gdHlwZW9mIHJhbmdlID09PSAnc3RyaW5nJyAmJiByYW5nZS5zdGFydHNXaXRoKCdyZ2InKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXR0ZXJuKGFycjogQXJyYXk8c3RyaW5nPikge1xuICBjb25zdCBwYXR0ZXJuID0gYXJyWzBdLnJlcGxhY2Uoc3RyaW5nU2hhcGVSZWdleCwgJycpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGludmFyaWFudChcbiAgICAgIHBhdHRlcm4gPT09IGFycltpXS5yZXBsYWNlKHN0cmluZ1NoYXBlUmVnZXgsICcnKSxcbiAgICAgICdpbnZhbGlkIHBhdHRlcm4gJyArIGFyclswXSArICcgYW5kICcgKyBhcnJbaV0sXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUmFuZ2UoaW5wdXQ6IG51bWJlciwgaW5wdXRSYW5nZTogQXJyYXk8bnVtYmVyPikge1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTsgaSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgaWYgKGlucHV0UmFuZ2VbaV0gPj0gaW5wdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSAtIDE7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGFycjogQXJyYXk8bnVtYmVyPikge1xuICBpbnZhcmlhbnQoYXJyLmxlbmd0aCA+PSAyLCAnaW5wdXRSYW5nZSBtdXN0IGhhdmUgYXQgbGVhc3QgMiBlbGVtZW50cycpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGludmFyaWFudChcbiAgICAgIGFycltpXSA+PSBhcnJbaSAtIDFdLFxuICAgICAgLyogJEZsb3dGaXhNZSg+PTAuMTMuMCkgLSBJbiB0aGUgYWRkaXRpb24gZXhwcmVzc2lvbiBiZWxvdyB0aGlzIGNvbW1lbnQsXG4gICAgICAgKiBvbmUgb3IgYm90aCBvZiB0aGUgb3BlcmFuZHMgbWF5IGJlIHNvbWV0aGluZyB0aGF0IGRvZXNuJ3QgY2xlYW5seVxuICAgICAgICogY29udmVydCB0byBhIHN0cmluZywgbGlrZSB1bmRlZmluZWQsIG51bGwsIGFuZCBvYmplY3QsIGV0Yy4gSWYgeW91IHJlYWxseVxuICAgICAgICogbWVhbiB0aGlzIGltcGxpY2l0IHN0cmluZyBjb252ZXJzaW9uLCB5b3UgY2FuIGRvIHNvbWV0aGluZyBsaWtlXG4gICAgICAgKiBTdHJpbmcobXlUaGluZylcbiAgICAgICAqL1xuICAgICAgJ2lucHV0UmFuZ2UgbXVzdCBiZSBtb25vdG9uaWNhbGx5IG5vbi1kZWNyZWFzaW5nICcgKyBhcnIsXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luZmluaXRlUmFuZ2UobmFtZTogc3RyaW5nLCBhcnI6IEFycmF5PG51bWJlcj4pIHtcbiAgaW52YXJpYW50KGFyci5sZW5ndGggPj0gMiwgbmFtZSArICcgbXVzdCBoYXZlIGF0IGxlYXN0IDIgZWxlbWVudHMnKTtcbiAgaW52YXJpYW50KFxuICAgIGFyci5sZW5ndGggIT09IDIgfHwgYXJyWzBdICE9PSAtSW5maW5pdHkgfHwgYXJyWzFdICE9PSBJbmZpbml0eSxcbiAgICAvKiAkRmxvd0ZpeE1lKD49MC4xMy4wKSAtIEluIHRoZSBhZGRpdGlvbiBleHByZXNzaW9uIGJlbG93IHRoaXMgY29tbWVudCxcbiAgICAgKiBvbmUgb3IgYm90aCBvZiB0aGUgb3BlcmFuZHMgbWF5IGJlIHNvbWV0aGluZyB0aGF0IGRvZXNuJ3QgY2xlYW5seSBjb252ZXJ0XG4gICAgICogdG8gYSBzdHJpbmcsIGxpa2UgdW5kZWZpbmVkLCBudWxsLCBhbmQgb2JqZWN0LCBldGMuIElmIHlvdSByZWFsbHkgbWVhblxuICAgICAqIHRoaXMgaW1wbGljaXQgc3RyaW5nIGNvbnZlcnNpb24sIHlvdSBjYW4gZG8gc29tZXRoaW5nIGxpa2VcbiAgICAgKiBTdHJpbmcobXlUaGluZylcbiAgICAgKi9cbiAgICBuYW1lICsgJ2Nhbm5vdCBiZSBdLWluZmluaXR5OytpbmZpbml0eVsgJyArIGFycixcbiAgKTtcbn1cblxuY2xhc3MgQW5pbWF0ZWRJbnRlcnBvbGF0aW9uIGV4dGVuZHMgQW5pbWF0ZWRXaXRoQ2hpbGRyZW4ge1xuICAvLyBFeHBvcnQgZm9yIHRlc3RpbmcuXG4gIHN0YXRpYyBfX2NyZWF0ZUludGVycG9sYXRpb24gPSBjcmVhdGVJbnRlcnBvbGF0aW9uO1xuXG4gIF9wYXJlbnQ6IEFuaW1hdGVkTm9kZTtcbiAgX2NvbmZpZzogSW50ZXJwb2xhdGlvbkNvbmZpZ1R5cGU7XG4gIF9pbnRlcnBvbGF0aW9uOiAoaW5wdXQ6IG51bWJlcikgPT4gbnVtYmVyIHwgc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmVudDogQW5pbWF0ZWROb2RlLCBjb25maWc6IEludGVycG9sYXRpb25Db25maWdUeXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuX2ludGVycG9sYXRpb24gPSBjcmVhdGVJbnRlcnBvbGF0aW9uKGNvbmZpZyk7XG4gIH1cblxuICBfX21ha2VOYXRpdmUoKSB7XG4gICAgdGhpcy5fcGFyZW50Ll9fbWFrZU5hdGl2ZSgpO1xuICAgIHN1cGVyLl9fbWFrZU5hdGl2ZSgpO1xuICB9XG5cbiAgX19nZXRWYWx1ZSgpOiBudW1iZXIgfCBzdHJpbmcge1xuICAgIGNvbnN0IHBhcmVudFZhbHVlOiBudW1iZXIgPSB0aGlzLl9wYXJlbnQuX19nZXRWYWx1ZSgpO1xuICAgIGludmFyaWFudChcbiAgICAgIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ251bWJlcicsXG4gICAgICAnQ2Fubm90IGludGVycG9sYXRlIGFuIGlucHV0IHdoaWNoIGlzIG5vdCBhIG51bWJlci4nLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRpb24ocGFyZW50VmFsdWUpO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUoY29uZmlnOiBJbnRlcnBvbGF0aW9uQ29uZmlnVHlwZSk6IEFuaW1hdGVkSW50ZXJwb2xhdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZEludGVycG9sYXRpb24odGhpcywgY29uZmlnKTtcbiAgfVxuXG4gIF9fYXR0YWNoKCk6IHZvaWQge1xuICAgIHRoaXMuX3BhcmVudC5fX2FkZENoaWxkKHRoaXMpO1xuICB9XG5cbiAgX19kZXRhY2goKTogdm9pZCB7XG4gICAgdGhpcy5fcGFyZW50Ll9fcmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgc3VwZXIuX19kZXRhY2goKTtcbiAgfVxuXG4gIF9fdHJhbnNmb3JtRGF0YVR5cGUocmFuZ2U6IEFycmF5PGFueT4pIHtcbiAgICAvLyBDaGFuZ2UgdGhlIHN0cmluZyBhcnJheSB0eXBlIHRvIG51bWJlciBhcnJheVxuICAgIC8vIFNvIHdlIGNhbiByZXVzZSB0aGUgc2FtZSBsb2dpYyBpbiBpT1MgYW5kIEFuZHJvaWQgcGxhdGZvcm1cbiAgICAvKiAkRmxvd0ZpeE1lKD49MC43MC4wIHNpdGU9cmVhY3RfbmF0aXZlX2ZiKSBUaGlzIGNvbW1lbnQgc3VwcHJlc3NlcyBhblxuICAgICAqIGVycm9yIGZvdW5kIHdoZW4gRmxvdyB2MC43MCB3YXMgZGVwbG95ZWQuIFRvIHNlZSB0aGUgZXJyb3IgZGVsZXRlIHRoaXNcbiAgICAgKiBjb21tZW50IGFuZCBydW4gRmxvdy4gKi9cbiAgICByZXR1cm4gcmFuZ2UubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoL2RlZyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGRlZ3JlZXMgPSBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xuICAgICAgICBjb25zdCByYWRpYW5zID0gKGRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MC4wO1xuICAgICAgICByZXR1cm4gcmFkaWFucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFzc3VtZSByYWRpYW5zXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX19nZXROYXRpdmVDb25maWcoKTogYW55IHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgTmF0aXZlQW5pbWF0ZWRIZWxwZXIudmFsaWRhdGVJbnRlcnBvbGF0aW9uKHRoaXMuX2NvbmZpZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0UmFuZ2U6IHRoaXMuX2NvbmZpZy5pbnB1dFJhbmdlLFxuICAgICAgLy8gT25seSB0aGUgYG91dHB1dFJhbmdlYCBjYW4gY29udGFpbiBzdHJpbmdzIHNvIHdlIGRvbid0IG5lZWQgdG8gdHJhbnNmb3JtIGBpbnB1dFJhbmdlYCBoZXJlXG4gICAgICBvdXRwdXRSYW5nZTogdGhpcy5fX3RyYW5zZm9ybURhdGFUeXBlKHRoaXMuX2NvbmZpZy5vdXRwdXRSYW5nZSksXG4gICAgICBleHRyYXBvbGF0ZUxlZnQ6XG4gICAgICAgIHRoaXMuX2NvbmZpZy5leHRyYXBvbGF0ZUxlZnQgfHwgdGhpcy5fY29uZmlnLmV4dHJhcG9sYXRlIHx8ICdleHRlbmQnLFxuICAgICAgZXh0cmFwb2xhdGVSaWdodDpcbiAgICAgICAgdGhpcy5fY29uZmlnLmV4dHJhcG9sYXRlUmlnaHQgfHwgdGhpcy5fY29uZmlnLmV4dHJhcG9sYXRlIHx8ICdleHRlbmQnLFxuICAgICAgdHlwZTogJ2ludGVycG9sYXRpb24nLFxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRlZEludGVycG9sYXRpb247XG4iXX0=