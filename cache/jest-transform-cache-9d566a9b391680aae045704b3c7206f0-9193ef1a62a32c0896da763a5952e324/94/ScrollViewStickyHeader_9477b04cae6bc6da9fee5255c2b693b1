4fbb1b218f097427701d81467f065fec









'use strict';var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self, call) {if (!self) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call && (typeof call === "object" || typeof call === "function") ? call : self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;}

var AnimatedImplementation = require('AnimatedImplementation');
var React = require('React');
var StyleSheet = require('StyleSheet');
var View = require('View');



var AnimatedView = AnimatedImplementation.createAnimatedComponent(View);var




















ScrollViewStickyHeader = function (_React$Component) {_inherits(ScrollViewStickyHeader, _React$Component);function ScrollViewStickyHeader() {var _ref;var _temp, _this, _ret;_classCallCheck(this, ScrollViewStickyHeader);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ScrollViewStickyHeader.__proto__ || Object.getPrototypeOf(ScrollViewStickyHeader)).call.apply(_ref, [this].concat(args))), _this), _this.
    state = {
      measured: false,
      layoutY: 0,
      layoutHeight: 0,
      nextHeaderLayoutY: _this.props.nextHeaderLayoutY }, _this.






    _onLayout = function (event) {
      _this.setState({
        measured: true,
        layoutY: event.nativeEvent.layout.y,
        layoutHeight: event.nativeEvent.layout.height });


      _this.props.onLayout(event);
      var child = React.Children.only(_this.props.children);
      if (child.props.onLayout) {
        child.props.onLayout(event);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);}_createClass(ScrollViewStickyHeader, [{ key: 'setNextHeaderY', value: function setNextHeaderY(y) {this.setState({ nextHeaderLayoutY: y });} }, { key: 'render', value: function render()

    {var _props =
      this.props,inverted = _props.inverted,scrollViewHeight = _props.scrollViewHeight;var _state =
      this.state,measured = _state.measured,layoutHeight = _state.layoutHeight,layoutY = _state.layoutY,nextHeaderLayoutY = _state.nextHeaderLayoutY;
      var inputRange = [-1, 0];
      var outputRange = [0, 0];

      if (measured) {
        if (inverted) {














          if (scrollViewHeight != null) {
            var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;
            if (stickStartPoint > 0) {
              inputRange.push(stickStartPoint);
              outputRange.push(0);
              inputRange.push(stickStartPoint + 1);
              outputRange.push(1);


              var collisionPoint =
              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;
              if (collisionPoint > stickStartPoint) {
                inputRange.push(collisionPoint, collisionPoint + 1);
                outputRange.push(
                collisionPoint - stickStartPoint,
                collisionPoint - stickStartPoint);

              }
            }
          }
        } else {










          inputRange.push(layoutY);
          outputRange.push(0);


          var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;
          if (_collisionPoint >= layoutY) {
            inputRange.push(_collisionPoint, _collisionPoint + 1);
            outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);
          } else {
            inputRange.push(layoutY + 1);
            outputRange.push(1);
          }
        }
      }

      var translateY = this.props.scrollAnimatedValue.interpolate({
        inputRange: inputRange,
        outputRange: outputRange });

      var child = React.Children.only(this.props.children);

      return (
        React.createElement(AnimatedView, {
            collapsable: false,
            onLayout: this._onLayout,
            style: [child.props.style, styles.header, { transform: [{ translateY: translateY }] }] },
          React.cloneElement(child, {
            style: styles.fill,
            onLayout: undefined })));



    } }]);return ScrollViewStickyHeader;}(React.Component);


var styles = StyleSheet.create({
  header: {
    zIndex: 10 },

  fill: {
    flex: 1 } });



module.exports = ScrollViewStickyHeader;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbFZpZXdTdGlja3lIZWFkZXIuanMiXSwibmFtZXMiOlsiQW5pbWF0ZWRJbXBsZW1lbnRhdGlvbiIsInJlcXVpcmUiLCJSZWFjdCIsIlN0eWxlU2hlZXQiLCJWaWV3IiwiQW5pbWF0ZWRWaWV3IiwiY3JlYXRlQW5pbWF0ZWRDb21wb25lbnQiLCJTY3JvbGxWaWV3U3RpY2t5SGVhZGVyIiwic3RhdGUiLCJtZWFzdXJlZCIsImxheW91dFkiLCJsYXlvdXRIZWlnaHQiLCJuZXh0SGVhZGVyTGF5b3V0WSIsInByb3BzIiwiX29uTGF5b3V0Iiwic2V0U3RhdGUiLCJldmVudCIsIm5hdGl2ZUV2ZW50IiwibGF5b3V0IiwieSIsImhlaWdodCIsIm9uTGF5b3V0IiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZHJlbiIsImludmVydGVkIiwic2Nyb2xsVmlld0hlaWdodCIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsInN0aWNrU3RhcnRQb2ludCIsInB1c2giLCJjb2xsaXNpb25Qb2ludCIsInRyYW5zbGF0ZVkiLCJzY3JvbGxBbmltYXRlZFZhbHVlIiwiaW50ZXJwb2xhdGUiLCJzdHlsZSIsInN0eWxlcyIsImhlYWRlciIsInRyYW5zZm9ybSIsImNsb25lRWxlbWVudCIsImZpbGwiLCJ1bmRlZmluZWQiLCJDb21wb25lbnQiLCJjcmVhdGUiLCJ6SW5kZXgiLCJmbGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBU0EsYTs7QUFFQSxJQUFNQSx5QkFBeUJDLFFBQVEsd0JBQVIsQ0FBL0I7QUFDQSxJQUFNQyxRQUFRRCxRQUFRLE9BQVIsQ0FBZDtBQUNBLElBQU1FLGFBQWFGLFFBQVEsWUFBUixDQUFuQjtBQUNBLElBQU1HLE9BQU9ILFFBQVEsTUFBUixDQUFiOzs7O0FBSUEsSUFBTUksZUFBZUwsdUJBQXVCTSx1QkFBdkIsQ0FBK0NGLElBQS9DLENBQXJCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCTUcs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L0IsQ0FBMkM7QUFDNURQLDhCQUQ0RDtBQUU1REMsZ0NBRjRELEVBQTNDLENBQW5COztBQUlBLFVBQU1QLFFBQVFwQixNQUFNcUIsUUFBTixDQUFlQyxJQUFmLENBQW9CLEtBQUtYLEtBQUwsQ0FBV1ksUUFBL0IsQ0FBZDs7QUFFQTtBQUNFLDRCQUFDLFlBQUQ7QUFDRSx5QkFBYSxLQURmO0FBRUUsc0JBQVUsS0FBS1gsU0FGakI7QUFHRSxtQkFBTyxDQUFDUSxNQUFNVCxLQUFOLENBQVl1QixLQUFiLEVBQW9CQyxPQUFPQyxNQUEzQixFQUFtQyxFQUFDQyxXQUFXLENBQUMsRUFBQ04sc0JBQUQsRUFBRCxDQUFaLEVBQW5DLENBSFQ7QUFJRy9CLGdCQUFNc0MsWUFBTixDQUFtQmxCLEtBQW5CLEVBQTBCO0FBQ3pCYyxtQkFBT0MsT0FBT0ksSUFEVztBQUV6QnBCLHNCQUFVcUIsU0FGZSxFQUExQixDQUpILENBREY7Ozs7QUFXRCxLLHFDQS9Ha0N4QyxNQUFNeUMsUzs7O0FBa0gzQyxJQUFNTixTQUFTbEMsV0FBV3lDLE1BQVgsQ0FBa0I7QUFDL0JOLFVBQVE7QUFDTk8sWUFBUSxFQURGLEVBRHVCOztBQUkvQkosUUFBTTtBQUNKSyxVQUFNLENBREYsRUFKeUIsRUFBbEIsQ0FBZjs7OztBQVNBQyxPQUFPQyxPQUFQLEdBQWlCekMsc0JBQWpCIiwiZmlsZSI6IlNjcm9sbFZpZXdTdGlja3lIZWFkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKiBAZm9ybWF0XG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgQW5pbWF0ZWRJbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJ0FuaW1hdGVkSW1wbGVtZW50YXRpb24nKTtcbmNvbnN0IFJlYWN0ID0gcmVxdWlyZSgnUmVhY3QnKTtcbmNvbnN0IFN0eWxlU2hlZXQgPSByZXF1aXJlKCdTdHlsZVNoZWV0Jyk7XG5jb25zdCBWaWV3ID0gcmVxdWlyZSgnVmlldycpO1xuXG5pbXBvcnQgdHlwZSB7TGF5b3V0RXZlbnR9IGZyb20gJ0NvcmVFdmVudFR5cGVzJztcblxuY29uc3QgQW5pbWF0ZWRWaWV3ID0gQW5pbWF0ZWRJbXBsZW1lbnRhdGlvbi5jcmVhdGVBbmltYXRlZENvbXBvbmVudChWaWV3KTtcblxudHlwZSBQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5FbGVtZW50PGFueT4sXG4gIG5leHRIZWFkZXJMYXlvdXRZOiA/bnVtYmVyLFxuICBvbkxheW91dDogKGV2ZW50OiBMYXlvdXRFdmVudCkgPT4gdm9pZCxcbiAgc2Nyb2xsQW5pbWF0ZWRWYWx1ZTogQW5pbWF0ZWRJbXBsZW1lbnRhdGlvbi5WYWx1ZSxcbiAgLy8gV2lsbCBjYXVzZSBzdGlja3kgaGVhZGVycyB0byBzdGljayBhdCB0aGUgYm90dG9tIG9mIHRoZSBTY3JvbGxWaWV3IGluc3RlYWRcbiAgLy8gb2YgdGhlIHRvcC5cbiAgaW52ZXJ0ZWQ6ID9ib29sZWFuLFxuICAvLyBUaGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgU2Nyb2xsVmlldy4gQ3VycmVudGx5IG9ubHkgc2V0IHdoZW4gaW52ZXJ0ZWQuXG4gIHNjcm9sbFZpZXdIZWlnaHQ6ID9udW1iZXIsXG59O1xuXG50eXBlIFN0YXRlID0ge1xuICBtZWFzdXJlZDogYm9vbGVhbixcbiAgbGF5b3V0WTogbnVtYmVyLFxuICBsYXlvdXRIZWlnaHQ6IG51bWJlcixcbiAgbmV4dEhlYWRlckxheW91dFk6ID9udW1iZXIsXG59O1xuXG5jbGFzcyBTY3JvbGxWaWV3U3RpY2t5SGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0ZSA9IHtcbiAgICBtZWFzdXJlZDogZmFsc2UsXG4gICAgbGF5b3V0WTogMCxcbiAgICBsYXlvdXRIZWlnaHQ6IDAsXG4gICAgbmV4dEhlYWRlckxheW91dFk6IHRoaXMucHJvcHMubmV4dEhlYWRlckxheW91dFksXG4gIH07XG5cbiAgc2V0TmV4dEhlYWRlclkoeTogbnVtYmVyKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bmV4dEhlYWRlckxheW91dFk6IHl9KTtcbiAgfVxuXG4gIF9vbkxheW91dCA9IGV2ZW50ID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1lYXN1cmVkOiB0cnVlLFxuICAgICAgbGF5b3V0WTogZXZlbnQubmF0aXZlRXZlbnQubGF5b3V0LnksXG4gICAgICBsYXlvdXRIZWlnaHQ6IGV2ZW50Lm5hdGl2ZUV2ZW50LmxheW91dC5oZWlnaHQsXG4gICAgfSk7XG5cbiAgICB0aGlzLnByb3BzLm9uTGF5b3V0KGV2ZW50KTtcbiAgICBjb25zdCBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgaWYgKGNoaWxkLnByb3BzLm9uTGF5b3V0KSB7XG4gICAgICBjaGlsZC5wcm9wcy5vbkxheW91dChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7aW52ZXJ0ZWQsIHNjcm9sbFZpZXdIZWlnaHR9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7bWVhc3VyZWQsIGxheW91dEhlaWdodCwgbGF5b3V0WSwgbmV4dEhlYWRlckxheW91dFl9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBpbnB1dFJhbmdlOiBBcnJheTxudW1iZXI+ID0gWy0xLCAwXTtcbiAgICBjb25zdCBvdXRwdXRSYW5nZTogQXJyYXk8bnVtYmVyPiA9IFswLCAwXTtcblxuICAgIGlmIChtZWFzdXJlZCkge1xuICAgICAgaWYgKGludmVydGVkKSB7XG4gICAgICAgIC8vIFRoZSBpbnRlcnBvbGF0aW9uIGxvb2tzIGxpa2U6XG4gICAgICAgIC8vIC0gTmVnYXRpdmUgc2Nyb2xsOiBubyB0cmFuc2xhdGlvblxuICAgICAgICAvLyAtIGBzdGlja1N0YXJ0UG9pbnRgIGlzIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgaGVhZGVyIHdpbGwgc3RhcnQgc3RpY2tpbmcuXG4gICAgICAgIC8vICAgSXQgaXMgY2FsY3VsYXRlZCB1c2luZyB0aGUgU2Nyb2xsVmlldyB2aWV3cG9ydCBoZWlnaHQgc28gaXQgaXMgYSB0aGUgYm90dG9tLlxuICAgICAgICAvLyAtIEhlYWRlcnMgdGhhdCBhcmUgaW4gdGhlIGluaXRpYWwgdmlld3BvcnQgd2lsbCBuZXZlciBzdGljaywgYHN0aWNrU3RhcnRQb2ludGBcbiAgICAgICAgLy8gICB3aWxsIGJlIG5lZ2F0aXZlLlxuICAgICAgICAvLyAtIEZyb20gMCB0byBgc3RpY2tTdGFydFBvaW50YCBubyB0cmFuc2xhdGlvbi4gVGhpcyB3aWxsIGNhdXNlIHRoZSBoZWFkZXJcbiAgICAgICAgLy8gICB0byBzY3JvbGwgbm9ybWFsbHkgdW50aWwgaXQgcmVhY2hlcyB0aGUgdG9wIG9mIHRoZSBzY3JvbGwgdmlldy5cbiAgICAgICAgLy8gLSBGcm9tIGBzdGlja1N0YXJ0UG9pbnRgIHRvIHdoZW4gdGhlIG5leHQgaGVhZGVyIHkgaGl0cyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGhlYWRlcjogdHJhbnNsYXRlXG4gICAgICAgIC8vICAgZXF1YWxseSB0byBzY3JvbGwuIFRoaXMgd2lsbCBjYXVzZSB0aGUgaGVhZGVyIHRvIHN0YXkgYXQgdGhlIHRvcCBvZiB0aGUgc2Nyb2xsIHZpZXcuXG4gICAgICAgIC8vIC0gUGFzdCB0aGUgY29sbGlzaW9uIHdpdGggdGhlIG5leHQgaGVhZGVyIHk6IG5vIG1vcmUgdHJhbnNsYXRpb24uIFRoaXMgd2lsbCBjYXVzZSB0aGVcbiAgICAgICAgLy8gICBoZWFkZXIgdG8gY29udGludWUgc2Nyb2xsaW5nIHVwIGFuZCBtYWtlIHJvb20gZm9yIHRoZSBuZXh0IHN0aWNreSBoZWFkZXIuXG4gICAgICAgIC8vICAgSW4gdGhlIGNhc2UgdGhhdCB0aGVyZSBpcyBubyBuZXh0IGhlYWRlciBqdXN0IHRyYW5zbGF0ZSBlcXVhbGx5IHRvXG4gICAgICAgIC8vICAgc2Nyb2xsIGluZGVmaW5pdGVseS5cbiAgICAgICAgaWYgKHNjcm9sbFZpZXdIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHN0aWNrU3RhcnRQb2ludCA9IGxheW91dFkgKyBsYXlvdXRIZWlnaHQgLSBzY3JvbGxWaWV3SGVpZ2h0O1xuICAgICAgICAgIGlmIChzdGlja1N0YXJ0UG9pbnQgPiAwKSB7XG4gICAgICAgICAgICBpbnB1dFJhbmdlLnB1c2goc3RpY2tTdGFydFBvaW50KTtcbiAgICAgICAgICAgIG91dHB1dFJhbmdlLnB1c2goMCk7XG4gICAgICAgICAgICBpbnB1dFJhbmdlLnB1c2goc3RpY2tTdGFydFBvaW50ICsgMSk7XG4gICAgICAgICAgICBvdXRwdXRSYW5nZS5wdXNoKDEpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgc3RpY2t5IGhlYWRlciBoYXMgbm90IGxvYWRlZCB5ZXQgKHByb2JhYmx5IHdpbmRvd2luZykgb3IgaXMgdGhlIGxhc3RcbiAgICAgICAgICAgIC8vIHdlIGNhbiBqdXN0IGtlZXAgaXQgc3RpY2tlZCBmb3JldmVyLlxuICAgICAgICAgICAgY29uc3QgY29sbGlzaW9uUG9pbnQgPVxuICAgICAgICAgICAgICAobmV4dEhlYWRlckxheW91dFkgfHwgMCkgLSBsYXlvdXRIZWlnaHQgLSBzY3JvbGxWaWV3SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGNvbGxpc2lvblBvaW50ID4gc3RpY2tTdGFydFBvaW50KSB7XG4gICAgICAgICAgICAgIGlucHV0UmFuZ2UucHVzaChjb2xsaXNpb25Qb2ludCwgY29sbGlzaW9uUG9pbnQgKyAxKTtcbiAgICAgICAgICAgICAgb3V0cHV0UmFuZ2UucHVzaChcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25Qb2ludCAtIHN0aWNrU3RhcnRQb2ludCxcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25Qb2ludCAtIHN0aWNrU3RhcnRQb2ludCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBpbnRlcnBvbGF0aW9uIGxvb2tzIGxpa2U6XG4gICAgICAgIC8vIC0gTmVnYXRpdmUgc2Nyb2xsOiBubyB0cmFuc2xhdGlvblxuICAgICAgICAvLyAtIEZyb20gMCB0byB0aGUgeSBvZiB0aGUgaGVhZGVyOiBubyB0cmFuc2xhdGlvbi4gVGhpcyB3aWxsIGNhdXNlIHRoZSBoZWFkZXJcbiAgICAgICAgLy8gICB0byBzY3JvbGwgbm9ybWFsbHkgdW50aWwgaXQgcmVhY2hlcyB0aGUgdG9wIG9mIHRoZSBzY3JvbGwgdmlldy5cbiAgICAgICAgLy8gLSBGcm9tIGhlYWRlciB5IHRvIHdoZW4gdGhlIG5leHQgaGVhZGVyIHkgaGl0cyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGhlYWRlcjogdHJhbnNsYXRlXG4gICAgICAgIC8vICAgZXF1YWxseSB0byBzY3JvbGwuIFRoaXMgd2lsbCBjYXVzZSB0aGUgaGVhZGVyIHRvIHN0YXkgYXQgdGhlIHRvcCBvZiB0aGUgc2Nyb2xsIHZpZXcuXG4gICAgICAgIC8vIC0gUGFzdCB0aGUgY29sbGlzaW9uIHdpdGggdGhlIG5leHQgaGVhZGVyIHk6IG5vIG1vcmUgdHJhbnNsYXRpb24uIFRoaXMgd2lsbCBjYXVzZSB0aGVcbiAgICAgICAgLy8gICBoZWFkZXIgdG8gY29udGludWUgc2Nyb2xsaW5nIHVwIGFuZCBtYWtlIHJvb20gZm9yIHRoZSBuZXh0IHN0aWNreSBoZWFkZXIuXG4gICAgICAgIC8vICAgSW4gdGhlIGNhc2UgdGhhdCB0aGVyZSBpcyBubyBuZXh0IGhlYWRlciBqdXN0IHRyYW5zbGF0ZSBlcXVhbGx5IHRvXG4gICAgICAgIC8vICAgc2Nyb2xsIGluZGVmaW5pdGVseS5cbiAgICAgICAgaW5wdXRSYW5nZS5wdXNoKGxheW91dFkpO1xuICAgICAgICBvdXRwdXRSYW5nZS5wdXNoKDApO1xuICAgICAgICAvLyBJZiB0aGUgbmV4dCBzdGlja3kgaGVhZGVyIGhhcyBub3QgbG9hZGVkIHlldCAocHJvYmFibHkgd2luZG93aW5nKSBvciBpcyB0aGUgbGFzdFxuICAgICAgICAvLyB3ZSBjYW4ganVzdCBrZWVwIGl0IHN0aWNrZWQgZm9yZXZlci5cbiAgICAgICAgY29uc3QgY29sbGlzaW9uUG9pbnQgPSAobmV4dEhlYWRlckxheW91dFkgfHwgMCkgLSBsYXlvdXRIZWlnaHQ7XG4gICAgICAgIGlmIChjb2xsaXNpb25Qb2ludCA+PSBsYXlvdXRZKSB7XG4gICAgICAgICAgaW5wdXRSYW5nZS5wdXNoKGNvbGxpc2lvblBvaW50LCBjb2xsaXNpb25Qb2ludCArIDEpO1xuICAgICAgICAgIG91dHB1dFJhbmdlLnB1c2goY29sbGlzaW9uUG9pbnQgLSBsYXlvdXRZLCBjb2xsaXNpb25Qb2ludCAtIGxheW91dFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0UmFuZ2UucHVzaChsYXlvdXRZICsgMSk7XG4gICAgICAgICAgb3V0cHV0UmFuZ2UucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zbGF0ZVkgPSB0aGlzLnByb3BzLnNjcm9sbEFuaW1hdGVkVmFsdWUuaW50ZXJwb2xhdGUoe1xuICAgICAgaW5wdXRSYW5nZSxcbiAgICAgIG91dHB1dFJhbmdlLFxuICAgIH0pO1xuICAgIGNvbnN0IGNoaWxkID0gUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8QW5pbWF0ZWRWaWV3XG4gICAgICAgIGNvbGxhcHNhYmxlPXtmYWxzZX1cbiAgICAgICAgb25MYXlvdXQ9e3RoaXMuX29uTGF5b3V0fVxuICAgICAgICBzdHlsZT17W2NoaWxkLnByb3BzLnN0eWxlLCBzdHlsZXMuaGVhZGVyLCB7dHJhbnNmb3JtOiBbe3RyYW5zbGF0ZVl9XX1dfT5cbiAgICAgICAge1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgIHN0eWxlOiBzdHlsZXMuZmlsbCwgLy8gV2UgdHJhbnNmZXIgdGhlIGNoaWxkIHN0eWxlIHRvIHRoZSB3cmFwcGVyLlxuICAgICAgICAgIG9uTGF5b3V0OiB1bmRlZmluZWQsIC8vIHdlIGNhbGwgdGhpcyBtYW51YWxseSB0aHJvdWdoIG91ciB0aGlzLl9vbkxheW91dFxuICAgICAgICB9KX1cbiAgICAgIDwvQW5pbWF0ZWRWaWV3PlxuICAgICk7XG4gIH1cbn1cblxuY29uc3Qgc3R5bGVzID0gU3R5bGVTaGVldC5jcmVhdGUoe1xuICBoZWFkZXI6IHtcbiAgICB6SW5kZXg6IDEwLFxuICB9LFxuICBmaWxsOiB7XG4gICAgZmxleDogMSxcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjcm9sbFZpZXdTdGlja3lIZWFkZXI7XG4iXX0=