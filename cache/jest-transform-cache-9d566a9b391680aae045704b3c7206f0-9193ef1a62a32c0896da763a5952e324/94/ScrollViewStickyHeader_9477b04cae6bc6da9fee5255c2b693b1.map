{"version":3,"sources":["ScrollViewStickyHeader.js"],"names":["AnimatedImplementation","require","React","StyleSheet","View","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","_onLayout","setState","event","nativeEvent","layout","y","height","onLayout","child","Children","only","children","inverted","scrollViewHeight","inputRange","outputRange","stickStartPoint","push","collisionPoint","translateY","scrollAnimatedValue","interpolate","style","styles","header","transform","cloneElement","fill","undefined","Component","create","zIndex","flex","module","exports"],"mappings":"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","file":"ScrollViewStickyHeader.js","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst AnimatedImplementation = require('AnimatedImplementation');\nconst React = require('React');\nconst StyleSheet = require('StyleSheet');\nconst View = require('View');\n\nimport type {LayoutEvent} from 'CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\ntype Props = {\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n};\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n  };\n\n  setNextHeaderY(y: number) {\n    this.setState({nextHeaderLayoutY: y});\n  }\n\n  _onLayout = event => {\n    this.setState({\n      measured: true,\n      layoutY: event.nativeEvent.layout.y,\n      layoutHeight: event.nativeEvent.layout.height,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  render() {\n    const {inverted, scrollViewHeight} = this.props;\n    const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    const translateY = this.props.scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n    const child = React.Children.only(this.props.children);\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        onLayout={this._onLayout}\n        style={[child.props.style, styles.header, {transform: [{translateY}]}]}>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"]}