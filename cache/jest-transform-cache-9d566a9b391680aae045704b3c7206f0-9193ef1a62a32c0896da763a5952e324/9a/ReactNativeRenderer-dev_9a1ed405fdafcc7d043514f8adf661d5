ffeb881719704d3e36b97f567b71dc46












'use strict';function _extends() {_extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};return _extends.apply(this, arguments);}

if (__DEV__) {
  (function () {
    "use strict";

    require("InitializeCore");
    var ReactNativeViewConfigRegistry = require("ReactNativeViewConfigRegistry");
    var UIManager = require("UIManager");
    var RCTEventEmitter = require("RCTEventEmitter");
    var React = require("react");
    var deepFreezeAndThrowOnMutationInDev = require("deepFreezeAndThrowOnMutationInDev");
    var deepDiffer = require("deepDiffer");
    var flattenStyle = require("flattenStyle");
    var TextInputState = require("TextInputState");
    var checkPropTypes = require("prop-types/checkPropTypes");
    var tracking = require("schedule/tracking");
    var ExceptionsManager = require("ExceptionsManager");












    var validateFormat = function validateFormat() {};

    {
      validateFormat = function validateFormat(format) {
        if (format === undefined) {
          throw new Error("invariant requires an error message argument");
        }
      };
    }

    function invariant(condition, format, a, b, c, d, e, f) {
      validateFormat(format);

      if (!condition) {
        var error = void 0;
        if (format === undefined) {
          error = new Error(
          "Minified exception occurred; use the non-minified dev environment " +
          "for the full error message and additional helpful warnings.");

        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
          format.replace(/%s/g, function () {
            return args[argIndex++];
          }));

          error.name = "Invariant Violation";
        }

        error.framesToPop = 1;
        throw error;
      }
    }

    var invokeGuardedCallbackImpl = function invokeGuardedCallbackImpl(
    name,
    func,
    context,
    a,
    b,
    c,
    d,
    e,
    f)
    {
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      try {
        func.apply(context, funcArgs);
      } catch (error) {
        this.onError(error);
      }
    };

    {





















      if (
      typeof window !== "undefined" &&
      typeof window.dispatchEvent === "function" &&
      typeof document !== "undefined" &&
      typeof document.createEvent === "function")
      {
        var fakeNode = document.createElement("react");

        var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(
        name,
        func,
        context,
        a,
        b,
        c,
        d,
        e,
        f)
        {




          invariant(
          typeof document !== "undefined",
          "The `document` global was defined when React was initialized, but is not " +
          "defined anymore. This can happen in a test environment if a component " +
          "schedules an update from an asynchronous callback, but the test has already " +
          "finished running. To solve this, you can either unmount the component at " +
          "the end of your test (and ensure that any asynchronous operations get " +
          "canceled in `componentWillUnmount`), or you can change the test itself " +
          "to be asynchronous.");

          var evt = document.createEvent("Event");







          var didError = true;




          var windowEvent = window.event;




          var funcArgs = Array.prototype.slice.call(arguments, 3);
          function callCallback() {




            fakeNode.removeEventListener(evtType, callCallback, false);





            if (
            typeof window.event !== "undefined" &&
            window.hasOwnProperty("event"))
            {
              window.event = windowEvent;
            }

            func.apply(context, funcArgs);
            didError = false;
          }












          var error = void 0;

          var didSetError = false;
          var isCrossOriginError = false;

          function handleWindowError(event) {
            error = event.error;
            didSetError = true;
            if (error === null && event.colno === 0 && event.lineno === 0) {
              isCrossOriginError = true;
            }
            if (event.defaultPrevented) {



              if (error != null && typeof error === "object") {
                try {
                  error._suppressLogging = true;
                } catch (inner) {

                }
              }
            }
          }


          var evtType = "react-" + (name ? name : "invokeguardedcallback");


          window.addEventListener("error", handleWindowError);
          fakeNode.addEventListener(evtType, callCallback, false);



          evt.initEvent(evtType, false, false);
          fakeNode.dispatchEvent(evt);

          if (didError) {
            if (!didSetError) {

              error = new Error(
              "An error was thrown inside one of your components, but React " +
              "doesn't know what it was. This is likely due to browser " +
              'flakiness. React does its best to preserve the "Pause on ' +
              'exceptions" behavior of the DevTools, which requires some ' +
              "DEV-mode only tricks. It's possible that these don't work in " +
              "your browser. Try triggering the error in production mode, " +
              "or switching to a modern browser. If you suspect that this is " +
              "actually an issue with React, please file an issue.");

            } else if (isCrossOriginError) {
              error = new Error(
              "A cross-origin error was thrown. React doesn't have access to " +
              "the actual error object in development. " +
              "See https://fb.me/react-crossorigin-error for more information.");

            }
            this.onError(error);
          }


          window.removeEventListener("error", handleWindowError);
        };

        invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
      }
    }

    var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;


    var hasError = false;
    var caughtError = null;


    var hasRethrowError = false;
    var rethrowError = null;

    var reporter = {
      onError: function onError(error) {
        hasError = true;
        caughtError = error;
      } };















    function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
      hasError = false;
      caughtError = null;
      invokeGuardedCallbackImpl$1.apply(reporter, arguments);
    }











    function invokeGuardedCallbackAndCatchFirstError(
    name,
    func,
    context,
    a,
    b,
    c,
    d,
    e,
    f)
    {
      invokeGuardedCallback.apply(this, arguments);
      if (hasError) {
        var error = clearCaughtError();
        if (!hasRethrowError) {
          hasRethrowError = true;
          rethrowError = error;
        }
      }
    }





    function rethrowCaughtError() {
      if (hasRethrowError) {
        var error = rethrowError;
        hasRethrowError = false;
        rethrowError = null;
        throw error;
      }
    }

    function hasCaughtError() {
      return hasError;
    }

    function clearCaughtError() {
      if (hasError) {
        var error = caughtError;
        hasError = false;
        caughtError = null;
        return error;
      } else {
        invariant(
        false,
        "clearCaughtError was called but no error was captured. This error " +
        "is likely caused by a bug in React. Please file an issue.");

      }
    }




    var eventPluginOrder = null;




    var namesToPlugins = {};






    function recomputePluginOrdering() {
      if (!eventPluginOrder) {

        return;
      }
      for (var pluginName in namesToPlugins) {
        var pluginModule = namesToPlugins[pluginName];
        var pluginIndex = eventPluginOrder.indexOf(pluginName);
        invariant(
        pluginIndex > -1,
        "EventPluginRegistry: Cannot inject event plugins that do not exist in " +
        "the plugin ordering, `%s`.",
        pluginName);

        if (plugins[pluginIndex]) {
          continue;
        }
        invariant(
        pluginModule.extractEvents,
        "EventPluginRegistry: Event plugins must implement an `extractEvents` " +
        "method, but `%s` does not.",
        pluginName);

        plugins[pluginIndex] = pluginModule;
        var publishedEvents = pluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          invariant(
          publishEventForPlugin(
          publishedEvents[eventName],
          pluginModule,
          eventName),

          "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.",
          eventName,
          pluginName);

        }
      }
    }









    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
      invariant(
      !eventNameDispatchConfigs.hasOwnProperty(eventName),
      "EventPluginHub: More than one plugin attempted to publish the same " +
      "event name, `%s`.",
      eventName);

      eventNameDispatchConfigs[eventName] = dispatchConfig;

      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(
            phasedRegistrationName,
            pluginModule,
            eventName);

          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(
        dispatchConfig.registrationName,
        pluginModule,
        eventName);

        return true;
      }
      return false;
    }








    function publishRegistrationName(registrationName, pluginModule, eventName) {
      invariant(
      !registrationNameModules[registrationName],
      "EventPluginHub: More than one plugin attempted to publish the same " +
      "registration name, `%s`.",
      registrationName);

      registrationNameModules[registrationName] = pluginModule;
      registrationNameDependencies[registrationName] =
      pluginModule.eventTypes[eventName].dependencies;

      {
        var lowerCasedName = registrationName.toLowerCase();
      }
    }










    var plugins = [];




    var eventNameDispatchConfigs = {};




    var registrationNameModules = {};




    var registrationNameDependencies = {};



















    function injectEventPluginOrder(injectedEventPluginOrder) {
      invariant(
      !eventPluginOrder,
      "EventPluginRegistry: Cannot inject event plugin ordering more than " +
      "once. You are likely trying to load more than one copy of React.");


      eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
      recomputePluginOrdering();
    }











    function injectEventPluginsByName(injectedNamesToPlugins) {
      var isOrderingDirty = false;
      for (var pluginName in injectedNamesToPlugins) {
        if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
          continue;
        }
        var pluginModule = injectedNamesToPlugins[pluginName];
        if (
        !namesToPlugins.hasOwnProperty(pluginName) ||
        namesToPlugins[pluginName] !== pluginModule)
        {
          invariant(
          !namesToPlugins[pluginName],
          "EventPluginRegistry: Cannot inject two different event plugins " +
          "using the same name, `%s`.",
          pluginName);

          namesToPlugins[pluginName] = pluginModule;
          isOrderingDirty = true;
        }
      }
      if (isOrderingDirty) {
        recomputePluginOrdering();
      }
    }








    var warningWithoutStack = function warningWithoutStack() {};

    {
      warningWithoutStack = function warningWithoutStack(condition, format) {
        for (
        var _len = arguments.length,
        args = Array(_len > 2 ? _len - 2 : 0),
        _key = 2;
        _key < _len;
        _key++)
        {
          args[_key - 2] = arguments[_key];
        }

        if (format === undefined) {
          throw new Error(
          "`warningWithoutStack(condition, format, ...args)` requires a warning " +
          "message argument");

        }
        if (condition) {
          return;
        }
        if (typeof console !== "undefined") {
          var _console;

          var stringArgs = args.map(function (item) {
            return "" + item;
          });
          (_console = console).error.apply(
          _console,
          ["Warning: " + format].concat(stringArgs));

        }
        try {



          var argIndex = 0;
          var message =
          "Warning: " +
          format.replace(/%s/g, function () {
            return args[argIndex++];
          });
          throw new Error(message);
        } catch (x) {}
      };
    }

    var warningWithoutStack$1 = warningWithoutStack;

    var getFiberCurrentPropsFromNode = null;
    var getInstanceFromNode = null;
    var getNodeFromInstance = null;

    function setComponentTree(
    getFiberCurrentPropsFromNodeImpl,
    getInstanceFromNodeImpl,
    getNodeFromInstanceImpl)
    {
      getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
      getInstanceFromNode = getInstanceFromNodeImpl;
      getNodeFromInstance = getNodeFromInstanceImpl;
      {
        !(getNodeFromInstance && getInstanceFromNode) ?
        warningWithoutStack$1(
        false,
        "EventPluginUtils.setComponentTree(...): Injected " +
        "module is missing getNodeFromInstance or getInstanceFromNode.") :

        void 0;
      }
    }

    var validateEventDispatches = void 0;
    {
      validateEventDispatches = function validateEventDispatches(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;

        var listenersIsArr = Array.isArray(dispatchListeners);
        var listenersLen = listenersIsArr ?
        dispatchListeners.length :
        dispatchListeners ?
        1 :
        0;

        var instancesIsArr = Array.isArray(dispatchInstances);
        var instancesLen = instancesIsArr ?
        dispatchInstances.length :
        dispatchInstances ?
        1 :
        0;

        !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ?
        warningWithoutStack$1(false, "EventPluginUtils: Invalid `event`.") :
        void 0;
      };
    }








    function executeDispatch(event, simulated, listener, inst) {
      var type = event.type || "unknown-event";
      event.currentTarget = getNodeFromInstance(inst);
      invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
      event.currentTarget = null;
    }




    function executeDispatchesInOrder(event, simulated) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }

          executeDispatch(
          event,
          simulated,
          dispatchListeners[i],
          dispatchInstances[i]);

        }
      } else if (dispatchListeners) {
        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
      }
      event._dispatchListeners = null;
      event._dispatchInstances = null;
    }








    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }

          if (dispatchListeners[i](event, dispatchInstances[i])) {
            return dispatchInstances[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchInstances)) {
          return dispatchInstances;
        }
      }
      return null;
    }




    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchInstances = null;
      event._dispatchListeners = null;
      return ret;
    }










    function executeDirectDispatch(event) {
      {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchInstance = event._dispatchInstances;
      invariant(
      !Array.isArray(dispatchListener),
      "executeDirectDispatch(...): Invalid `event`.");

      event.currentTarget = dispatchListener ?
      getNodeFromInstance(dispatchInstance) :
      null;
      var res = dispatchListener ? dispatchListener(event) : null;
      event.currentTarget = null;
      event._dispatchListeners = null;
      event._dispatchInstances = null;
      return res;
    }





    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }














    function accumulateInto(current, next) {
      invariant(
      next != null,
      "accumulateInto(...): Accumulated items must not be null or undefined.");


      if (current == null) {
        return next;
      }



      if (Array.isArray(current)) {
        if (Array.isArray(next)) {
          current.push.apply(current, next);
          return current;
        }
        current.push(next);
        return current;
      }

      if (Array.isArray(next)) {

        return [current].concat(next);
      }

      return [current, next];
    }










    function forEachAccumulated(arr, cb, scope) {
      if (Array.isArray(arr)) {
        arr.forEach(cb, scope);
      } else if (arr) {
        cb.call(scope, arr);
      }
    }





    var eventQueue = null;








    var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
      if (event) {
        executeDispatchesInOrder(event, simulated);

        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
      return executeDispatchesAndRelease(e, true);
    };
    var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
      return executeDispatchesAndRelease(e, false);
    };

    function isInteractive(tag) {
      return (
        tag === "button" ||
        tag === "input" ||
        tag === "select" ||
        tag === "textarea");

    }

    function shouldPreventMouseEvent(name, type, props) {
      switch (name) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
          return !!(props.disabled && isInteractive(type));
        default:
          return false;}

    }



























    var injection = {




      injectEventPluginOrder: injectEventPluginOrder,




      injectEventPluginsByName: injectEventPluginsByName };







    function getListener(inst, registrationName) {
      var listener = void 0;



      var stateNode = inst.stateNode;
      if (!stateNode) {

        return null;
      }
      var props = getFiberCurrentPropsFromNode(stateNode);
      if (!props) {

        return null;
      }
      listener = props[registrationName];
      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
        return null;
      }
      invariant(
      !listener || typeof listener === "function",
      "Expected `%s` listener to be a function, instead got a value of `%s` type.",
      registrationName,
      typeof listener);

      return listener;
    }








    function extractEvents(
    topLevelType,
    targetInst,
    nativeEvent,
    nativeEventTarget)
    {
      var events = null;
      for (var i = 0; i < plugins.length; i++) {

        var possiblePlugin = plugins[i];
        if (possiblePlugin) {
          var extractedEvents = possiblePlugin.extractEvents(
          topLevelType,
          targetInst,
          nativeEvent,
          nativeEventTarget);

          if (extractedEvents) {
            events = accumulateInto(events, extractedEvents);
          }
        }
      }
      return events;
    }

    function runEventsInBatch(events, simulated) {
      if (events !== null) {
        eventQueue = accumulateInto(eventQueue, events);
      }



      var processingEventQueue = eventQueue;
      eventQueue = null;

      if (!processingEventQueue) {
        return;
      }

      if (simulated) {
        forEachAccumulated(
        processingEventQueue,
        executeDispatchesAndReleaseSimulated);

      } else {
        forEachAccumulated(
        processingEventQueue,
        executeDispatchesAndReleaseTopLevel);

      }
      invariant(
      !eventQueue,
      "processEventQueue(): Additional events were enqueued while processing " +
      "an event queue. Support for this has not yet been implemented.");


      rethrowCaughtError();
    }

    function runExtractedEventsInBatch(
    topLevelType,
    targetInst,
    nativeEvent,
    nativeEventTarget)
    {
      var events = extractEvents(
      topLevelType,
      targetInst,
      nativeEvent,
      nativeEventTarget);

      runEventsInBatch(events, false);
    }

    var FunctionalComponent = 0;
    var FunctionalComponentLazy = 1;
    var ClassComponent = 2;
    var ClassComponentLazy = 3;
    var IndeterminateComponent = 4;
    var HostRoot = 5;
    var HostPortal = 6;
    var HostComponent = 7;
    var HostText = 8;
    var Fragment = 9;
    var Mode = 10;
    var ContextConsumer = 11;
    var ContextProvider = 12;
    var ForwardRef = 13;
    var ForwardRefLazy = 14;
    var Profiler = 15;
    var PlaceholderComponent = 16;

    function getParent(inst) {
      do {
        inst = inst.return;





      } while (inst && inst.tag !== HostComponent);
      if (inst) {
        return inst;
      }
      return null;
    }





    function getLowestCommonAncestor(instA, instB) {
      var depthA = 0;
      for (var tempA = instA; tempA; tempA = getParent(tempA)) {
        depthA++;
      }
      var depthB = 0;
      for (var tempB = instB; tempB; tempB = getParent(tempB)) {
        depthB++;
      }


      while (depthA - depthB > 0) {
        instA = getParent(instA);
        depthA--;
      }


      while (depthB - depthA > 0) {
        instB = getParent(instB);
        depthB--;
      }


      var depth = depthA;
      while (depth--) {
        if (instA === instB || instA === instB.alternate) {
          return instA;
        }
        instA = getParent(instA);
        instB = getParent(instB);
      }
      return null;
    }




    function isAncestor(instA, instB) {
      while (instB) {
        if (instA === instB || instA === instB.alternate) {
          return true;
        }
        instB = getParent(instB);
      }
      return false;
    }




    function getParentInstance(inst) {
      return getParent(inst);
    }




    function traverseTwoPhase(inst, fn, arg) {
      var path = [];
      while (inst) {
        path.push(inst);
        inst = getParent(inst);
      }
      var i = void 0;
      for (i = path.length; i-- > 0;) {
        fn(path[i], "captured", arg);
      }
      for (i = 0; i < path.length; i++) {
        fn(path[i], "bubbled", arg);
      }
    }













    function listenerAtPhase(inst, event, propagationPhase) {
      var registrationName =
      event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(inst, registrationName);
    }

















    function accumulateDirectionalDispatches(inst, phase, event) {
      {
        !inst ?
        warningWithoutStack$1(false, "Dispatching inst must not be null") :
        void 0;
      }
      var listener = listenerAtPhase(inst, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(
        event._dispatchListeners,
        listener);

        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
      }
    }








    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
      }
    }




    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        var targetInst = event._targetInst;
        var parentInst = targetInst ? getParentInstance(targetInst) : null;
        traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
      }
    }






    function accumulateDispatches(inst, ignoredDirection, event) {
      if (inst && event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(inst, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(
          event._dispatchListeners,
          listener);

          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }
    }






    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event._targetInst, null, event);
      }
    }

    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }

    function accumulateTwoPhaseDispatchesSkipTarget(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
    }

    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }



    var EVENT_POOL_SIZE = 10;





    var EventInterface = {
      type: null,
      target: null,

      currentTarget: function currentTarget() {
        return null;
      },
      eventPhase: null,
      bubbles: null,
      cancelable: null,
      timeStamp: function timeStamp(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: null,
      isTrusted: null };


    function functionThatReturnsTrue() {
      return true;
    }

    function functionThatReturnsFalse() {
      return false;
    }



















    function SyntheticEvent(
    dispatchConfig,
    targetInst,
    nativeEvent,
    nativeEventTarget)
    {
      {

        delete this.nativeEvent;
        delete this.preventDefault;
        delete this.stopPropagation;
        delete this.isDefaultPrevented;
        delete this.isPropagationStopped;
      }

      this.dispatchConfig = dispatchConfig;
      this._targetInst = targetInst;
      this.nativeEvent = nativeEvent;

      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if (!Interface.hasOwnProperty(propName)) {
          continue;
        }
        {
          delete this[propName];
        }
        var normalize = Interface[propName];
        if (normalize) {
          this[propName] = normalize(nativeEvent);
        } else {
          if (propName === "target") {
            this.target = nativeEventTarget;
          } else {
            this[propName] = nativeEvent[propName];
          }
        }
      }

      var defaultPrevented =
      nativeEvent.defaultPrevented != null ?
      nativeEvent.defaultPrevented :
      nativeEvent.returnValue === false;
      if (defaultPrevented) {
        this.isDefaultPrevented = functionThatReturnsTrue;
      } else {
        this.isDefaultPrevented = functionThatReturnsFalse;
      }
      this.isPropagationStopped = functionThatReturnsFalse;
      return this;
    }

    _extends(SyntheticEvent.prototype, {
      preventDefault: function preventDefault() {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        if (!event) {
          return;
        }

        if (event.preventDefault) {
          event.preventDefault();
        } else if (typeof event.returnValue !== "unknown") {
          event.returnValue = false;
        }
        this.isDefaultPrevented = functionThatReturnsTrue;
      },

      stopPropagation: function stopPropagation() {
        var event = this.nativeEvent;
        if (!event) {
          return;
        }

        if (event.stopPropagation) {
          event.stopPropagation();
        } else if (typeof event.cancelBubble !== "unknown") {





          event.cancelBubble = true;
        }

        this.isPropagationStopped = functionThatReturnsTrue;
      },






      persist: function persist() {
        this.isPersistent = functionThatReturnsTrue;
      },






      isPersistent: functionThatReturnsFalse,




      destructor: function destructor() {
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
          {
            Object.defineProperty(
            this,
            propName,
            getPooledWarningPropertyDefinition(propName, Interface[propName]));

          }
        }
        this.dispatchConfig = null;
        this._targetInst = null;
        this.nativeEvent = null;
        this.isDefaultPrevented = functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        this._dispatchListeners = null;
        this._dispatchInstances = null;
        {
          Object.defineProperty(
          this,
          "nativeEvent",
          getPooledWarningPropertyDefinition("nativeEvent", null));

          Object.defineProperty(
          this,
          "isDefaultPrevented",
          getPooledWarningPropertyDefinition(
          "isDefaultPrevented",
          functionThatReturnsFalse));


          Object.defineProperty(
          this,
          "isPropagationStopped",
          getPooledWarningPropertyDefinition(
          "isPropagationStopped",
          functionThatReturnsFalse));


          Object.defineProperty(
          this,
          "preventDefault",
          getPooledWarningPropertyDefinition("preventDefault", function () {}));

          Object.defineProperty(
          this,
          "stopPropagation",
          getPooledWarningPropertyDefinition("stopPropagation", function () {}));

        }
      } });


    SyntheticEvent.Interface = EventInterface;




    SyntheticEvent.extend = function (Interface) {
      var Super = this;

      var E = function E() {};
      E.prototype = Super.prototype;
      var prototype = new E();

      function Class() {
        return Super.apply(this, arguments);
      }
      _extends(prototype, Class.prototype);
      Class.prototype = prototype;
      Class.prototype.constructor = Class;

      Class.Interface = _extends({}, Super.Interface, Interface);
      Class.extend = Super.extend;
      addEventPoolingTo(Class);

      return Class;
    };

    addEventPoolingTo(SyntheticEvent);








    function getPooledWarningPropertyDefinition(propName, getVal) {
      var isFunction = typeof getVal === "function";
      return {
        configurable: true,
        set: set,
        get: get$$1 };


      function set(val) {
        var action = isFunction ? "setting the method" : "setting the property";
        warn(action, "This is effectively a no-op");
        return val;
      }

      function get$$1() {
        var action = isFunction ? "accessing the method" : "accessing the property";
        var result = isFunction ?
        "This is a no-op function" :
        "This is set to null";
        warn(action, result);
        return getVal;
      }

      function warn(action, result) {
        var warningCondition = false;
        !warningCondition ?
        warningWithoutStack$1(
        false,
        "This synthetic event is reused for performance reasons. If you're seeing this, " +
        "you're %s `%s` on a released/nullified synthetic event. %s. " +
        "If you must keep the original synthetic event around, use event.persist(). " +
        "See https://fb.me/react-event-pooling for more information.",
        action,
        propName,
        result) :

        void 0;
      }
    }

    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
      var EventConstructor = this;
      if (EventConstructor.eventPool.length) {
        var instance = EventConstructor.eventPool.pop();
        EventConstructor.call(
        instance,
        dispatchConfig,
        targetInst,
        nativeEvent,
        nativeInst);

        return instance;
      }
      return new EventConstructor(
      dispatchConfig,
      targetInst,
      nativeEvent,
      nativeInst);

    }

    function releasePooledEvent(event) {
      var EventConstructor = this;
      invariant(
      event instanceof EventConstructor,
      "Trying to release an event instance into a pool of a different type.");

      event.destructor();
      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
        EventConstructor.eventPool.push(event);
      }
    }

    function addEventPoolingTo(EventConstructor) {
      EventConstructor.eventPool = [];
      EventConstructor.getPooled = getPooledEvent;
      EventConstructor.release = releasePooledEvent;
    }






    var ResponderSyntheticEvent = SyntheticEvent.extend({
      touchHistory: function touchHistory(nativeEvent) {
        return null;
      } });


    var TOP_TOUCH_START = "topTouchStart";
    var TOP_TOUCH_MOVE = "topTouchMove";
    var TOP_TOUCH_END = "topTouchEnd";
    var TOP_TOUCH_CANCEL = "topTouchCancel";
    var TOP_SCROLL = "topScroll";
    var TOP_SELECTION_CHANGE = "topSelectionChange";

    function isStartish(topLevelType) {
      return topLevelType === TOP_TOUCH_START;
    }

    function isMoveish(topLevelType) {
      return topLevelType === TOP_TOUCH_MOVE;
    }

    function isEndish(topLevelType) {
      return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;
    }

    var startDependencies = [TOP_TOUCH_START];
    var moveDependencies = [TOP_TOUCH_MOVE];
    var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];







    var MAX_TOUCH_BANK = 20;
    var touchBank = [];
    var touchHistory = {
      touchBank: touchBank,
      numberActiveTouches: 0,



      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0 };


    function timestampForTouch(touch) {



      return touch.timeStamp || touch.timestamp;
    }





    function createTouchRecord(touch) {
      return {
        touchActive: true,
        startPageX: touch.pageX,
        startPageY: touch.pageY,
        startTimeStamp: timestampForTouch(touch),
        currentPageX: touch.pageX,
        currentPageY: touch.pageY,
        currentTimeStamp: timestampForTouch(touch),
        previousPageX: touch.pageX,
        previousPageY: touch.pageY,
        previousTimeStamp: timestampForTouch(touch) };

    }

    function resetTouchRecord(touchRecord, touch) {
      touchRecord.touchActive = true;
      touchRecord.startPageX = touch.pageX;
      touchRecord.startPageY = touch.pageY;
      touchRecord.startTimeStamp = timestampForTouch(touch);
      touchRecord.currentPageX = touch.pageX;
      touchRecord.currentPageY = touch.pageY;
      touchRecord.currentTimeStamp = timestampForTouch(touch);
      touchRecord.previousPageX = touch.pageX;
      touchRecord.previousPageY = touch.pageY;
      touchRecord.previousTimeStamp = timestampForTouch(touch);
    }

    function getTouchIdentifier(_ref) {
      var identifier = _ref.identifier;

      invariant(identifier != null, "Touch object is missing identifier.");
      {
        !(identifier <= MAX_TOUCH_BANK) ?
        warningWithoutStack$1(
        false,
        "Touch identifier %s is greater than maximum supported %s which causes " +
        "performance issues backfilling array locations for all of the indices.",
        identifier,
        MAX_TOUCH_BANK) :

        void 0;
      }
      return identifier;
    }

    function recordTouchStart(touch) {
      var identifier = getTouchIdentifier(touch);
      var touchRecord = touchBank[identifier];
      if (touchRecord) {
        resetTouchRecord(touchRecord, touch);
      } else {
        touchBank[identifier] = createTouchRecord(touch);
      }
      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
    }

    function recordTouchMove(touch) {
      var touchRecord = touchBank[getTouchIdentifier(touch)];
      if (touchRecord) {
        touchRecord.touchActive = true;
        touchRecord.previousPageX = touchRecord.currentPageX;
        touchRecord.previousPageY = touchRecord.currentPageY;
        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      } else {
        console.error(
        "Cannot record touch move without a touch start.\n" + "Touch Move: %s\n",
        "Touch Bank: %s",
        printTouch(touch),
        printTouchBank());

      }
    }

    function recordTouchEnd(touch) {
      var touchRecord = touchBank[getTouchIdentifier(touch)];
      if (touchRecord) {
        touchRecord.touchActive = false;
        touchRecord.previousPageX = touchRecord.currentPageX;
        touchRecord.previousPageY = touchRecord.currentPageY;
        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      } else {
        console.error(
        "Cannot record touch end without a touch start.\n" + "Touch End: %s\n",
        "Touch Bank: %s",
        printTouch(touch),
        printTouchBank());

      }
    }

    function printTouch(touch) {
      return JSON.stringify({
        identifier: touch.identifier,
        pageX: touch.pageX,
        pageY: touch.pageY,
        timestamp: timestampForTouch(touch) });

    }

    function printTouchBank() {
      var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
      if (touchBank.length > MAX_TOUCH_BANK) {
        printed += " (original size: " + touchBank.length + ")";
      }
      return printed;
    }

    var ResponderTouchHistoryStore = {
      recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
        if (isMoveish(topLevelType)) {
          nativeEvent.changedTouches.forEach(recordTouchMove);
        } else if (isStartish(topLevelType)) {
          nativeEvent.changedTouches.forEach(recordTouchStart);
          touchHistory.numberActiveTouches = nativeEvent.touches.length;
          if (touchHistory.numberActiveTouches === 1) {
            touchHistory.indexOfSingleActiveTouch =
            nativeEvent.touches[0].identifier;
          }
        } else if (isEndish(topLevelType)) {
          nativeEvent.changedTouches.forEach(recordTouchEnd);
          touchHistory.numberActiveTouches = nativeEvent.touches.length;
          if (touchHistory.numberActiveTouches === 1) {
            for (var i = 0; i < touchBank.length; i++) {
              var touchTrackToCheck = touchBank[i];
              if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
                touchHistory.indexOfSingleActiveTouch = i;
                break;
              }
            }
            {
              var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
              !(activeRecord != null && activeRecord.touchActive) ?
              warningWithoutStack$1(false, "Cannot find single active touch.") :
              void 0;
            }
          }
        }
      },

      touchHistory: touchHistory };









    function accumulate(current, next) {
      invariant(
      next != null,
      "accumulate(...): Accumulated items must be not be null or undefined.");


      if (current == null) {
        return next;
      }



      if (Array.isArray(current)) {
        return current.concat(next);
      }

      if (Array.isArray(next)) {
        return [current].concat(next);
      }

      return [current, next];
    }





    var responderInst = null;





    var trackedTouchCount = 0;

    var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {
      var oldResponderInst = responderInst;
      responderInst = nextResponderInst;
      if (ResponderEventPlugin.GlobalResponderHandler !== null) {
        ResponderEventPlugin.GlobalResponderHandler.onChange(
        oldResponderInst,
        nextResponderInst,
        blockHostResponder);

      }
    };

    var eventTypes$1 = {




      startShouldSetResponder: {
        phasedRegistrationNames: {
          bubbled: "onStartShouldSetResponder",
          captured: "onStartShouldSetResponderCapture" },

        dependencies: startDependencies },











      scrollShouldSetResponder: {
        phasedRegistrationNames: {
          bubbled: "onScrollShouldSetResponder",
          captured: "onScrollShouldSetResponderCapture" },

        dependencies: [TOP_SCROLL] },









      selectionChangeShouldSetResponder: {
        phasedRegistrationNames: {
          bubbled: "onSelectionChangeShouldSetResponder",
          captured: "onSelectionChangeShouldSetResponderCapture" },

        dependencies: [TOP_SELECTION_CHANGE] },






      moveShouldSetResponder: {
        phasedRegistrationNames: {
          bubbled: "onMoveShouldSetResponder",
          captured: "onMoveShouldSetResponderCapture" },

        dependencies: moveDependencies },





      responderStart: {
        registrationName: "onResponderStart",
        dependencies: startDependencies },

      responderMove: {
        registrationName: "onResponderMove",
        dependencies: moveDependencies },

      responderEnd: {
        registrationName: "onResponderEnd",
        dependencies: endDependencies },

      responderRelease: {
        registrationName: "onResponderRelease",
        dependencies: endDependencies },

      responderTerminationRequest: {
        registrationName: "onResponderTerminationRequest",
        dependencies: [] },

      responderGrant: {
        registrationName: "onResponderGrant",
        dependencies: [] },

      responderReject: {
        registrationName: "onResponderReject",
        dependencies: [] },

      responderTerminate: {
        registrationName: "onResponderTerminate",
        dependencies: [] } };

































































































































































































    function setResponderAndExtractTransfer(
    topLevelType,
    targetInst,
    nativeEvent,
    nativeEventTarget)
    {
      var shouldSetEventType = isStartish(topLevelType) ?
      eventTypes$1.startShouldSetResponder :
      isMoveish(topLevelType) ?
      eventTypes$1.moveShouldSetResponder :
      topLevelType === TOP_SELECTION_CHANGE ?
      eventTypes$1.selectionChangeShouldSetResponder :
      eventTypes$1.scrollShouldSetResponder;


      var bubbleShouldSetFrom = !responderInst ?
      targetInst :
      getLowestCommonAncestor(responderInst, targetInst);





      var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
      var shouldSetEvent = ResponderSyntheticEvent.getPooled(
      shouldSetEventType,
      bubbleShouldSetFrom,
      nativeEvent,
      nativeEventTarget);

      shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
      if (skipOverBubbleShouldSetFrom) {
        accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
      } else {
        accumulateTwoPhaseDispatches(shouldSetEvent);
      }
      var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
      if (!shouldSetEvent.isPersistent()) {
        shouldSetEvent.constructor.release(shouldSetEvent);
      }

      if (!wantsResponderInst || wantsResponderInst === responderInst) {
        return null;
      }
      var extracted = void 0;
      var grantEvent = ResponderSyntheticEvent.getPooled(
      eventTypes$1.responderGrant,
      wantsResponderInst,
      nativeEvent,
      nativeEventTarget);

      grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

      accumulateDirectDispatches(grantEvent);
      var blockHostResponder = executeDirectDispatch(grantEvent) === true;
      if (responderInst) {
        var terminationRequestEvent = ResponderSyntheticEvent.getPooled(
        eventTypes$1.responderTerminationRequest,
        responderInst,
        nativeEvent,
        nativeEventTarget);

        terminationRequestEvent.touchHistory =
        ResponderTouchHistoryStore.touchHistory;
        accumulateDirectDispatches(terminationRequestEvent);
        var shouldSwitch =
        !hasDispatches(terminationRequestEvent) ||
        executeDirectDispatch(terminationRequestEvent);
        if (!terminationRequestEvent.isPersistent()) {
          terminationRequestEvent.constructor.release(terminationRequestEvent);
        }

        if (shouldSwitch) {
          var terminateEvent = ResponderSyntheticEvent.getPooled(
          eventTypes$1.responderTerminate,
          responderInst,
          nativeEvent,
          nativeEventTarget);

          terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(terminateEvent);
          extracted = accumulate(extracted, [grantEvent, terminateEvent]);
          changeResponder(wantsResponderInst, blockHostResponder);
        } else {
          var rejectEvent = ResponderSyntheticEvent.getPooled(
          eventTypes$1.responderReject,
          wantsResponderInst,
          nativeEvent,
          nativeEventTarget);

          rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(rejectEvent);
          extracted = accumulate(extracted, rejectEvent);
        }
      } else {
        extracted = accumulate(extracted, grantEvent);
        changeResponder(wantsResponderInst, blockHostResponder);
      }
      return extracted;
    }









    function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
      return (
        topLevelInst && (



        topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll ||
        trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE ||
        isStartish(topLevelType) ||
        isMoveish(topLevelType)));

    }








    function noResponderTouches(nativeEvent) {
      var touches = nativeEvent.touches;
      if (!touches || touches.length === 0) {
        return true;
      }
      for (var i = 0; i < touches.length; i++) {
        var activeTouch = touches[i];
        var target = activeTouch.target;
        if (target !== null && target !== undefined && target !== 0) {

          var targetInst = getInstanceFromNode(target);
          if (isAncestor(responderInst, targetInst)) {
            return false;
          }
        }
      }
      return true;
    }

    var ResponderEventPlugin = {

      _getResponder: function _getResponder() {
        return responderInst;
      },

      eventTypes: eventTypes$1,






      extractEvents: function extractEvents(
      topLevelType,
      targetInst,
      nativeEvent,
      nativeEventTarget)
      {
        if (isStartish(topLevelType)) {
          trackedTouchCount += 1;
        } else if (isEndish(topLevelType)) {
          if (trackedTouchCount >= 0) {
            trackedTouchCount -= 1;
          } else {
            console.error(
            "Ended a touch event which was not counted in `trackedTouchCount`.");

            return null;
          }
        }

        ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

        var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ?
        setResponderAndExtractTransfer(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget) :

        null;










        var isResponderTouchStart = responderInst && isStartish(topLevelType);
        var isResponderTouchMove = responderInst && isMoveish(topLevelType);
        var isResponderTouchEnd = responderInst && isEndish(topLevelType);
        var incrementalTouch = isResponderTouchStart ?
        eventTypes$1.responderStart :
        isResponderTouchMove ?
        eventTypes$1.responderMove :
        isResponderTouchEnd ?
        eventTypes$1.responderEnd :
        null;

        if (incrementalTouch) {
          var gesture = ResponderSyntheticEvent.getPooled(
          incrementalTouch,
          responderInst,
          nativeEvent,
          nativeEventTarget);

          gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(gesture);
          extracted = accumulate(extracted, gesture);
        }

        var isResponderTerminate =
        responderInst && topLevelType === TOP_TOUCH_CANCEL;
        var isResponderRelease =
        responderInst &&
        !isResponderTerminate &&
        isEndish(topLevelType) &&
        noResponderTouches(nativeEvent);
        var finalTouch = isResponderTerminate ?
        eventTypes$1.responderTerminate :
        isResponderRelease ?
        eventTypes$1.responderRelease :
        null;
        if (finalTouch) {
          var finalEvent = ResponderSyntheticEvent.getPooled(
          finalTouch,
          responderInst,
          nativeEvent,
          nativeEventTarget);

          finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(finalEvent);
          extracted = accumulate(extracted, finalEvent);
          changeResponder(null);
        }

        return extracted;
      },

      GlobalResponderHandler: null,

      injection: {





        injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
          ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
        } } };



    var customBubblingEventTypes$1 =
    ReactNativeViewConfigRegistry.customBubblingEventTypes;
    var customDirectEventTypes$1 =
    ReactNativeViewConfigRegistry.customDirectEventTypes;
    var eventTypes$2 = ReactNativeViewConfigRegistry.eventTypes;

    var ReactNativeBridgeEventPlugin = {
      eventTypes: eventTypes$2,




      extractEvents: function extractEvents(
      topLevelType,
      targetInst,
      nativeEvent,
      nativeEventTarget)
      {
        if (targetInst == null) {

          return null;
        }
        var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType];
        var directDispatchConfig = customDirectEventTypes$1[topLevelType];
        invariant(
        bubbleDispatchConfig || directDispatchConfig,
        'Unsupported top level event type "%s" dispatched',
        topLevelType);

        var event = SyntheticEvent.getPooled(
        bubbleDispatchConfig || directDispatchConfig,
        targetInst,
        nativeEvent,
        nativeEventTarget);

        if (bubbleDispatchConfig) {
          accumulateTwoPhaseDispatches(event);
        } else if (directDispatchConfig) {
          accumulateDirectDispatches(event);
        } else {
          return null;
        }
        return event;
      } };


    var ReactNativeEventPluginOrder = [
    "ResponderEventPlugin",
    "ReactNativeBridgeEventPlugin"];












    injection.injectEventPluginOrder(ReactNativeEventPluginOrder);





    injection.injectEventPluginsByName({
      ResponderEventPlugin: ResponderEventPlugin,
      ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin });


    var instanceCache = {};
    var instanceProps = {};

    function precacheFiberNode(hostInst, tag) {
      instanceCache[tag] = hostInst;
    }

    function uncacheFiberNode(tag) {
      delete instanceCache[tag];
      delete instanceProps[tag];
    }

    function getInstanceFromTag(tag) {
      return instanceCache[tag] || null;
    }

    function getTagFromInstance(inst) {
      var tag = inst.stateNode._nativeTag;
      if (tag === undefined) {
        tag = inst.stateNode.canonical._nativeTag;
      }
      invariant(tag, "All native instances should have a tag.");
      return tag;
    }

    function getFiberCurrentPropsFromNode$1(stateNode) {
      return instanceProps[stateNode._nativeTag] || null;
    }

    function updateFiberProps(tag, props) {
      instanceProps[tag] = props;
    }



    var restoreImpl = null;
    var restoreTarget = null;
    var restoreQueue = null;

    function restoreStateOfTarget(target) {


      var internalInstance = getInstanceFromNode(target);
      if (!internalInstance) {

        return;
      }
      invariant(
      typeof restoreImpl === "function",
      "setRestoreImplementation() needs to be called to handle a target for controlled " +
      "events. This error is likely caused by a bug in React. Please file an issue.");

      var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
      restoreImpl(internalInstance.stateNode, internalInstance.type, props);
    }

    function needsStateRestore() {
      return restoreTarget !== null || restoreQueue !== null;
    }

    function restoreStateIfNeeded() {
      if (!restoreTarget) {
        return;
      }
      var target = restoreTarget;
      var queuedTargets = restoreQueue;
      restoreTarget = null;
      restoreQueue = null;

      restoreStateOfTarget(target);
      if (queuedTargets) {
        for (var i = 0; i < queuedTargets.length; i++) {
          restoreStateOfTarget(queuedTargets[i]);
        }
      }
    }








    var _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, bookkeeping) {
      return fn(bookkeeping);
    };
    var _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {};

    var isBatching = false;
    function batchedUpdates(fn, bookkeeping) {
      if (isBatching) {


        return fn(bookkeeping);
      }
      isBatching = true;
      try {
        return _batchedUpdatesImpl(fn, bookkeeping);
      } finally {




        isBatching = false;
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        if (controlledComponentsHavePendingUpdates) {



          _flushInteractiveUpdatesImpl();
          restoreStateIfNeeded();
        }
      }
    }

    function setBatchingImplementation(
    batchedUpdatesImpl,
    interactiveUpdatesImpl,
    flushInteractiveUpdatesImpl)
    {
      _batchedUpdatesImpl = batchedUpdatesImpl;
      _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
    }







    var EMPTY_NATIVE_EVENT = {};








    var touchSubsequence = function touchSubsequence(touches, indices) {
      var ret = [];
      for (var i = 0; i < indices.length; i++) {
        ret.push(touches[indices[i]]);
      }
      return ret;
    };












    var removeTouchesAtIndices = function removeTouchesAtIndices(touches, indices) {
      var rippedOut = [];


      var temp = touches;
      for (var i = 0; i < indices.length; i++) {
        var index = indices[i];
        rippedOut.push(touches[index]);
        temp[index] = null;
      }
      var fillAt = 0;
      for (var j = 0; j < temp.length; j++) {
        var cur = temp[j];
        if (cur !== null) {
          temp[fillAt++] = cur;
        }
      }
      temp.length = fillAt;
      return rippedOut;
    };











    function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
      var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;
      var inst = getInstanceFromTag(rootNodeID);
      batchedUpdates(function () {
        runExtractedEventsInBatch(
        topLevelType,
        inst,
        nativeEvent,
        nativeEvent.target);

      });


    }








    function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {
      _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
    }

























    function receiveTouches(eventTopLevelType, touches, changedIndices) {
      var changedTouches =
      eventTopLevelType === "topTouchEnd" ||
      eventTopLevelType === "topTouchCancel" ?
      removeTouchesAtIndices(touches, changedIndices) :
      touchSubsequence(touches, changedIndices);

      for (var jj = 0; jj < changedTouches.length; jj++) {
        var touch = changedTouches[jj];


        touch.changedTouches = changedTouches;
        touch.touches = touches;
        var nativeEvent = touch;
        var rootNodeID = null;
        var target = nativeEvent.target;
        if (target !== null && target !== undefined) {
          if (target < 1) {
            {
              warningWithoutStack$1(
              false,
              "A view is reporting that a touch occurred on tag zero.");

            }
          } else {
            rootNodeID = target;
          }
        }

        _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);
      }
    }

    var ReactNativeEventEmitter = Object.freeze({
      getListener: getListener,
      registrationNames: registrationNameModules,
      _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,
      receiveEvent: receiveEvent,
      receiveTouches: receiveTouches });



    var ReactNativeGlobalResponderHandler = {
      onChange: function onChange(from, to, blockNativeResponder) {
        if (to !== null) {
          var tag = to.stateNode._nativeTag;
          UIManager.setJSResponder(tag, blockNativeResponder);
        } else {
          UIManager.clearJSResponder();
        }
      } };






    RCTEventEmitter.register(ReactNativeEventEmitter);

    setComponentTree(
    getFiberCurrentPropsFromNode$1,
    getInstanceFromTag,
    getTagFromInstance);


    ResponderEventPlugin.injection.injectGlobalResponderHandler(
    ReactNativeGlobalResponderHandler);


















    function get$1(key) {
      return key._reactInternalFiber;
    }

    function set(key, value) {
      key._reactInternalFiber = value;
    }

    var ReactSharedInternals =
    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;



    var hasSymbol = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.for : "@@for");

    var REACT_ELEMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.element") : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.portal") : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.fragment") : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ?
    (typeof Symbol === "function" ? Symbol.for : "@@for")("react.strict_mode") :
    0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.profiler") : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.provider") : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.context") : 0xeace;
    var REACT_ASYNC_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.async_mode") : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ?
    (typeof Symbol === "function" ? Symbol.for : "@@for")("react.forward_ref") :
    0xead0;
    var REACT_PLACEHOLDER_TYPE = hasSymbol ?
    (typeof Symbol === "function" ? Symbol.for : "@@for")("react.placeholder") :
    0xead1;

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
    var FAUX_ITERATOR_SYMBOL = "@@iterator";

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object") {
        return null;
      }
      var maybeIterator =
      MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] ||
      maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === "function") {
        return maybeIterator;
      }
      return null;
    }

    var Pending = 0;
    var Resolved = 1;
    var Rejected = 2;

    function getResultFromResolvedThenable(thenable) {
      return thenable._reactResult;
    }

    function refineResolvedThenable(thenable) {
      return thenable._reactStatus === Resolved ? thenable._reactResult : null;
    }

    function getComponentName(type) {
      if (type == null) {

        return null;
      }
      {
        if (typeof type.tag === "number") {
          warningWithoutStack$1(
          false,
          "Received an unexpected object in getComponentName(). " +
          "This is likely a bug in React. Please file an issue.");

        }
      }
      if (typeof type === "function") {
        return type.displayName || type.name || null;
      }
      if (typeof type === "string") {
        return type;
      }
      switch (type) {
        case REACT_ASYNC_MODE_TYPE:
          return "AsyncMode";
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_PLACEHOLDER_TYPE:
          return "Placeholder";}

      if (typeof type === "object") {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            return "Context.Consumer";
          case REACT_PROVIDER_TYPE:
            return "Context.Provider";
          case REACT_FORWARD_REF_TYPE:
            var renderFn = type.render;
            var functionName = renderFn.displayName || renderFn.name || "";
            return functionName !== "" ?
            "ForwardRef(" + functionName + ")" :
            "ForwardRef";}

        if (typeof type.then === "function") {
          var thenable = type;
          var resolvedThenable = refineResolvedThenable(thenable);
          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }
        }
      }
      return null;
    }


    var NoEffect = 0;
    var PerformedWork = 1;


    var Placement = 2;
    var Update = 4;
    var PlacementAndUpdate = 6;
    var Deletion = 8;
    var ContentReset = 16;
    var Callback = 32;
    var DidCapture = 64;
    var Ref = 128;
    var Snapshot = 256;


    var LifecycleEffectMask = 420;


    var HostEffectMask = 511;

    var Incomplete = 512;
    var ShouldCapture = 1024;

    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;

    var MOUNTING = 1;
    var MOUNTED = 2;
    var UNMOUNTED = 3;

    function isFiberMountedImpl(fiber) {
      var node = fiber;
      if (!fiber.alternate) {


        if ((node.effectTag & Placement) !== NoEffect) {
          return MOUNTING;
        }
        while (node.return) {
          node = node.return;
          if ((node.effectTag & Placement) !== NoEffect) {
            return MOUNTING;
          }
        }
      } else {
        while (node.return) {
          node = node.return;
        }
      }
      if (node.tag === HostRoot) {


        return MOUNTED;
      }


      return UNMOUNTED;
    }

    function isFiberMounted(fiber) {
      return isFiberMountedImpl(fiber) === MOUNTED;
    }

    function isMounted(component) {
      {
        var owner = ReactCurrentOwner$1.current;
        if (
        owner !== null && (
        owner.tag === ClassComponent || owner.tag === ClassComponentLazy))
        {
          var ownerFiber = owner;
          var instance = ownerFiber.stateNode;
          !instance._warnedAboutRefsInRender ?
          warningWithoutStack$1(
          false,
          "%s is accessing isMounted inside its render() function. " +
          "render() should be a pure function of props and state. It should " +
          "never access something that requires stale data from the previous " +
          "render, such as refs. Move this logic to componentDidMount and " +
          "componentDidUpdate instead.",
          getComponentName(ownerFiber.type) || "A component") :

          void 0;
          instance._warnedAboutRefsInRender = true;
        }
      }

      var fiber = get$1(component);
      if (!fiber) {
        return false;
      }
      return isFiberMountedImpl(fiber) === MOUNTED;
    }

    function assertIsMounted(fiber) {
      invariant(
      isFiberMountedImpl(fiber) === MOUNTED,
      "Unable to find node on an unmounted component.");

    }

    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {

        var state = isFiberMountedImpl(fiber);
        invariant(
        state !== UNMOUNTED,
        "Unable to find node on an unmounted component.");

        if (state === MOUNTING) {
          return null;
        }
        return fiber;
      }



      var a = fiber;
      var b = alternate;
      while (true) {
        var parentA = a.return;
        var parentB = parentA ? parentA.alternate : null;
        if (!parentA || !parentB) {

          break;
        }




        if (parentA.child === parentB.child) {
          var child = parentA.child;
          while (child) {
            if (child === a) {

              assertIsMounted(parentA);
              return fiber;
            }
            if (child === b) {

              assertIsMounted(parentA);
              return alternate;
            }
            child = child.sibling;
          }


          invariant(false, "Unable to find node on an unmounted component.");
        }

        if (a.return !== b.return) {




          a = parentA;
          b = parentB;
        } else {





          var didFindChild = false;
          var _child = parentA.child;
          while (_child) {
            if (_child === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {

            _child = parentB.child;
            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            invariant(
            didFindChild,
            "Child was not found in either parent set. This indicates a bug " +
            "in React related to the return pointer. Please file an issue.");

          }
        }

        invariant(
        a.alternate === b,
        "Return fibers should always be each others' alternates. " +
        "This error is likely caused by a bug in React. Please file an issue.");

      }


      invariant(
      a.tag === HostRoot,
      "Unable to find node on an unmounted component.");

      if (a.stateNode.current === a) {

        return fiber;
      }

      return alternate;
    }

    function findCurrentHostFiber(parent) {
      var currentParent = findCurrentFiberUsingSlowPath(parent);
      if (!currentParent) {
        return null;
      }


      var node = currentParent;
      while (true) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        } else if (node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === currentParent) {
          return null;
        }
        while (!node.sibling) {
          if (!node.return || node.return === currentParent) {
            return null;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }


      return null;
    }


    var emptyObject = {};











    var removedKeys = null;
    var removedKeyCount = 0;

    function defaultDiffer(prevProp, nextProp) {
      if (typeof nextProp !== "object" || nextProp === null) {

        return true;
      } else {

        return deepDiffer(prevProp, nextProp);
      }
    }

    function restoreDeletedValuesInNestedArray(
    updatePayload,
    node,
    validAttributes)
    {
      if (Array.isArray(node)) {
        var i = node.length;
        while (i-- && removedKeyCount > 0) {
          restoreDeletedValuesInNestedArray(
          updatePayload,
          node[i],
          validAttributes);

        }
      } else if (node && removedKeyCount > 0) {
        var obj = node;
        for (var propKey in removedKeys) {
          if (!removedKeys[propKey]) {
            continue;
          }
          var nextProp = obj[propKey];
          if (nextProp === undefined) {
            continue;
          }

          var attributeConfig = validAttributes[propKey];
          if (!attributeConfig) {
            continue;
          }

          if (typeof nextProp === "function") {
            nextProp = true;
          }
          if (typeof nextProp === "undefined") {
            nextProp = null;
          }

          if (typeof attributeConfig !== "object") {

            updatePayload[propKey] = nextProp;
          } else if (
          typeof attributeConfig.diff === "function" ||
          typeof attributeConfig.process === "function")
          {

            var nextValue =
            typeof attributeConfig.process === "function" ?
            attributeConfig.process(nextProp) :
            nextProp;
            updatePayload[propKey] = nextValue;
          }
          removedKeys[propKey] = false;
          removedKeyCount--;
        }
      }
    }

    function diffNestedArrayProperty(
    updatePayload,
    prevArray,
    nextArray,
    validAttributes)
    {
      var minLength =
      prevArray.length < nextArray.length ? prevArray.length : nextArray.length;
      var i = void 0;
      for (i = 0; i < minLength; i++) {


        updatePayload = diffNestedProperty(
        updatePayload,
        prevArray[i],
        nextArray[i],
        validAttributes);

      }
      for (; i < prevArray.length; i++) {

        updatePayload = clearNestedProperty(
        updatePayload,
        prevArray[i],
        validAttributes);

      }
      for (; i < nextArray.length; i++) {

        updatePayload = addNestedProperty(
        updatePayload,
        nextArray[i],
        validAttributes);

      }
      return updatePayload;
    }

    function diffNestedProperty(
    updatePayload,
    prevProp,
    nextProp,
    validAttributes)
    {
      if (!updatePayload && prevProp === nextProp) {


        return updatePayload;
      }

      if (!prevProp || !nextProp) {
        if (nextProp) {
          return addNestedProperty(updatePayload, nextProp, validAttributes);
        }
        if (prevProp) {
          return clearNestedProperty(updatePayload, prevProp, validAttributes);
        }
        return updatePayload;
      }

      if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {

        return diffProperties(updatePayload, prevProp, nextProp, validAttributes);
      }

      if (Array.isArray(prevProp) && Array.isArray(nextProp)) {

        return diffNestedArrayProperty(
        updatePayload,
        prevProp,
        nextProp,
        validAttributes);

      }

      if (Array.isArray(prevProp)) {
        return diffProperties(
        updatePayload,

        flattenStyle(prevProp),

        nextProp,
        validAttributes);

      }

      return diffProperties(
      updatePayload,
      prevProp,

      flattenStyle(nextProp),
      validAttributes);

    }






    function addNestedProperty(updatePayload, nextProp, validAttributes) {
      if (!nextProp) {
        return updatePayload;
      }

      if (!Array.isArray(nextProp)) {

        return addProperties(updatePayload, nextProp, validAttributes);
      }

      for (var i = 0; i < nextProp.length; i++) {

        updatePayload = addNestedProperty(
        updatePayload,
        nextProp[i],
        validAttributes);

      }

      return updatePayload;
    }





    function clearNestedProperty(updatePayload, prevProp, validAttributes) {
      if (!prevProp) {
        return updatePayload;
      }

      if (!Array.isArray(prevProp)) {

        return clearProperties(updatePayload, prevProp, validAttributes);
      }

      for (var i = 0; i < prevProp.length; i++) {

        updatePayload = clearNestedProperty(
        updatePayload,
        prevProp[i],
        validAttributes);

      }
      return updatePayload;
    }







    function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
      var attributeConfig = void 0;
      var nextProp = void 0;
      var prevProp = void 0;

      for (var propKey in nextProps) {
        attributeConfig = validAttributes[propKey];
        if (!attributeConfig) {
          continue;
        }

        prevProp = prevProps[propKey];
        nextProp = nextProps[propKey];



        if (typeof nextProp === "function") {
          nextProp = true;


          if (typeof prevProp === "function") {
            prevProp = true;
          }
        }



        if (typeof nextProp === "undefined") {
          nextProp = null;
          if (typeof prevProp === "undefined") {
            prevProp = null;
          }
        }

        if (removedKeys) {
          removedKeys[propKey] = false;
        }

        if (updatePayload && updatePayload[propKey] !== undefined) {






          if (typeof attributeConfig !== "object") {

            updatePayload[propKey] = nextProp;
          } else if (
          typeof attributeConfig.diff === "function" ||
          typeof attributeConfig.process === "function")
          {

            var nextValue =
            typeof attributeConfig.process === "function" ?
            attributeConfig.process(nextProp) :
            nextProp;
            updatePayload[propKey] = nextValue;
          }
          continue;
        }

        if (prevProp === nextProp) {
          continue;
        }


        if (typeof attributeConfig !== "object") {

          if (defaultDiffer(prevProp, nextProp)) {

            (updatePayload || (updatePayload = {}))[propKey] = nextProp;
          }
        } else if (
        typeof attributeConfig.diff === "function" ||
        typeof attributeConfig.process === "function")
        {

          var shouldUpdate =
          prevProp === undefined || (
          typeof attributeConfig.diff === "function" ?
          attributeConfig.diff(prevProp, nextProp) :
          defaultDiffer(prevProp, nextProp));
          if (shouldUpdate) {
            var _nextValue =
            typeof attributeConfig.process === "function" ?
            attributeConfig.process(nextProp) :
            nextProp;
            (updatePayload || (updatePayload = {}))[propKey] = _nextValue;
          }
        } else {

          removedKeys = null;
          removedKeyCount = 0;


          updatePayload = diffNestedProperty(
          updatePayload,
          prevProp,
          nextProp,
          attributeConfig);

          if (removedKeyCount > 0 && updatePayload) {
            restoreDeletedValuesInNestedArray(
            updatePayload,
            nextProp,
            attributeConfig);

            removedKeys = null;
          }
        }
      }




      for (var _propKey in prevProps) {
        if (nextProps[_propKey] !== undefined) {
          continue;
        }
        attributeConfig = validAttributes[_propKey];
        if (!attributeConfig) {
          continue;
        }

        if (updatePayload && updatePayload[_propKey] !== undefined) {

          continue;
        }

        prevProp = prevProps[_propKey];
        if (prevProp === undefined) {
          continue;
        }

        if (
        typeof attributeConfig !== "object" ||
        typeof attributeConfig.diff === "function" ||
        typeof attributeConfig.process === "function")
        {


          (updatePayload || (updatePayload = {}))[_propKey] = null;
          if (!removedKeys) {
            removedKeys = {};
          }
          if (!removedKeys[_propKey]) {
            removedKeys[_propKey] = true;
            removedKeyCount++;
          }
        } else {



          updatePayload = clearNestedProperty(
          updatePayload,
          prevProp,
          attributeConfig);

        }
      }
      return updatePayload;
    }




    function addProperties(updatePayload, props, validAttributes) {

      return diffProperties(updatePayload, emptyObject, props, validAttributes);
    }





    function clearProperties(updatePayload, prevProps, validAttributes) {

      return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);
    }

    function create(props, validAttributes) {
      return addProperties(
      null,
      props,
      validAttributes);

    }

    function diff(prevProps, nextProps, validAttributes) {
      return diffProperties(
      null,
      prevProps,
      nextProps,
      validAttributes);

    }





    function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
      return function () {
        if (!callback) {
          return undefined;
        }




        if (typeof context.__isMounted === "boolean") {
          if (!context.__isMounted) {
            return undefined;
          }
        }













        return callback.apply(context, arguments);
      };
    }

    function throwOnStylesProp(component, props) {
      if (props.styles !== undefined) {
        var owner = component._owner || null;
        var name = component.constructor.displayName;
        var msg =
        "`styles` is not a supported property of `" +
        name +
        "`, did " +
        "you mean `style` (singular)?";
        if (owner && owner.constructor && owner.constructor.displayName) {
          msg +=
          "\n\nCheck the `" +
          owner.constructor.displayName +
          "` parent " +
          " component.";
        }
        throw new Error(msg);
      }
    }

    function warnForStyleProps(props, validAttributes) {
      for (var key in validAttributes.style) {
        if (!(validAttributes[key] || props[key] === undefined)) {
          console.error(
          "You are setting the style `{ " +
          key +
          ": ... }` as a prop. You " +
          "should nest it in a style object. " +
          "E.g. `{ style: { " +
          key +
          ": ... } }`");

        }
      }
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }










    var ReactNativeFiberHostComponent = function () {
      function ReactNativeFiberHostComponent(tag, viewConfig) {
        _classCallCheck(this, ReactNativeFiberHostComponent);

        this._nativeTag = tag;
        this._children = [];
        this.viewConfig = viewConfig;
      }

      ReactNativeFiberHostComponent.prototype.blur = function blur() {
        TextInputState.blurTextInput(this._nativeTag);
      };

      ReactNativeFiberHostComponent.prototype.focus = function focus() {
        TextInputState.focusTextInput(this._nativeTag);
      };

      ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {
        UIManager.measure(
        this._nativeTag,
        mountSafeCallback_NOT_REALLY_SAFE(this, callback));

      };

      ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(
      callback)
      {
        UIManager.measureInWindow(
        this._nativeTag,
        mountSafeCallback_NOT_REALLY_SAFE(this, callback));

      };

      ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(
      relativeToNativeNode,
      onSuccess,
      onFail)
      {
        UIManager.measureLayout(
        this._nativeTag,
        relativeToNativeNode,
        mountSafeCallback_NOT_REALLY_SAFE(this, onFail),
        mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));

      };

      ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(
      nativeProps)
      {
        {
          warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
        }

        var updatePayload = create(nativeProps, this.viewConfig.validAttributes);




        if (updatePayload != null) {
          UIManager.updateView(
          this._nativeTag,
          this.viewConfig.uiViewClassName,
          updatePayload);

        }
      };

      return ReactNativeFiberHostComponent;
    }();

    var hasNativePerformanceNow =
    typeof performance === "object" && typeof performance.now === "function";

    var now$1 = hasNativePerformanceNow ?
    function () {
      return performance.now();
    } :
    function () {
      return Date.now();
    };

    var scheduledCallback = null;
    var frameDeadline = 0;

    var frameDeadlineObject = {
      timeRemaining: function timeRemaining() {
        return frameDeadline - now$1();
      },
      didTimeout: false };


    function setTimeoutCallback() {




      frameDeadline = now$1() + 5;

      var callback = scheduledCallback;
      scheduledCallback = null;
      if (callback !== null) {
        callback(frameDeadlineObject);
      }
    }




    function scheduleDeferredCallback$1(callback, options) {

      scheduledCallback = callback;
      var timeoutId = setTimeout(setTimeoutCallback, 1);
      return timeoutId;
    }

    function cancelDeferredCallback$1(callbackID) {
      scheduledCallback = null;
      clearTimeout(callbackID);
    }




    function shim() {
      invariant(
      false,
      "The current renderer does not support persistence. " +
      "This error is likely caused by a bug in React. " +
      "Please file an issue.");

    }


    var supportsPersistence = false;
    var cloneInstance = shim;
    var createContainerChildSet = shim;
    var appendChildToContainerChildSet = shim;
    var finalizeContainerChildren = shim;
    var replaceContainerChildren = shim;




    function shim$1() {
      invariant(
      false,
      "The current renderer does not support hyration. " +
      "This error is likely caused by a bug in React. " +
      "Please file an issue.");

    }


    var supportsHydration = false;
    var canHydrateInstance = shim$1;
    var canHydrateTextInstance = shim$1;
    var getNextHydratableSibling = shim$1;
    var getFirstHydratableChild = shim$1;
    var hydrateInstance = shim$1;
    var hydrateTextInstance = shim$1;
    var didNotMatchHydratedContainerTextInstance = shim$1;
    var didNotMatchHydratedTextInstance = shim$1;
    var didNotHydrateContainerInstance = shim$1;
    var didNotHydrateInstance = shim$1;
    var didNotFindHydratableContainerInstance = shim$1;
    var didNotFindHydratableContainerTextInstance = shim$1;
    var didNotFindHydratableInstance = shim$1;
    var didNotFindHydratableTextInstance = shim$1;




    var UPDATE_SIGNAL = {};
    {
      Object.freeze(UPDATE_SIGNAL);
    }




    var nextReactTag = 3;
    function allocateTag() {
      var tag = nextReactTag;
      if (tag % 10 === 1) {
        tag += 2;
      }
      nextReactTag = tag + 2;
      return tag;
    }

    function recursivelyUncacheFiberNode(node) {
      if (typeof node === "number") {

        uncacheFiberNode(node);
      } else {
        uncacheFiberNode(node._nativeTag);

        node._children.forEach(recursivelyUncacheFiberNode);
      }
    }

    function appendInitialChild(parentInstance, child) {
      parentInstance._children.push(child);
    }

    function createInstance(
    type,
    props,
    rootContainerInstance,
    hostContext,
    internalInstanceHandle)
    {
      var tag = allocateTag();
      var viewConfig = ReactNativeViewConfigRegistry.get(type);

      {
        for (var key in viewConfig.validAttributes) {
          if (props.hasOwnProperty(key)) {
            deepFreezeAndThrowOnMutationInDev(props[key]);
          }
        }
      }

      invariant(
      type !== "RCTView" || !hostContext.isInAParentText,
      "Nesting of <View> within <Text> is not currently supported.");


      var updatePayload = create(props, viewConfig.validAttributes);

      UIManager.createView(
      tag,
      viewConfig.uiViewClassName,
      rootContainerInstance,
      updatePayload);


      var component = new ReactNativeFiberHostComponent(tag, viewConfig);

      precacheFiberNode(internalInstanceHandle, tag);
      updateFiberProps(tag, props);



      return component;
    }

    function createTextInstance(
    text,
    rootContainerInstance,
    hostContext,
    internalInstanceHandle)
    {
      invariant(
      hostContext.isInAParentText,
      "Text strings must be rendered within a <Text> component.");


      var tag = allocateTag();

      UIManager.createView(
      tag,
      "RCTRawText",
      rootContainerInstance,
      { text: text });


      precacheFiberNode(internalInstanceHandle, tag);

      return tag;
    }

    function finalizeInitialChildren(
    parentInstance,
    type,
    props,
    rootContainerInstance,
    hostContext)
    {

      if (parentInstance._children.length === 0) {
        return false;
      }



      var nativeTags = parentInstance._children.map(function (child) {
        return typeof child === "number" ?
        child :
        child._nativeTag;
      });

      UIManager.setChildren(
      parentInstance._nativeTag,
      nativeTags);


      return false;
    }

    function getRootHostContext(rootContainerInstance) {
      return { isInAParentText: false };
    }

    function getChildHostContext(parentHostContext, type, rootContainerInstance) {
      var prevIsInAParentText = parentHostContext.isInAParentText;
      var isInAParentText =
      type === "AndroidTextInput" ||
      type === "RCTMultilineTextInputView" ||
      type === "RCTSinglelineTextInputView" ||
      type === "RCTText" ||
      type === "RCTVirtualText";

      if (prevIsInAParentText !== isInAParentText) {
        return { isInAParentText: isInAParentText };
      } else {
        return parentHostContext;
      }
    }

    function getPublicInstance(instance) {
      return instance;
    }

    function prepareForCommit(containerInfo) {

    }

    function prepareUpdate(
    instance,
    type,
    oldProps,
    newProps,
    rootContainerInstance,
    hostContext)
    {
      return UPDATE_SIGNAL;
    }

    function resetAfterCommit(containerInfo) {

    }

    var now = now$1;
    var isPrimaryRenderer = true;
    var scheduleDeferredCallback = scheduleDeferredCallback$1;
    var cancelDeferredCallback = cancelDeferredCallback$1;

    var scheduleTimeout = setTimeout;
    var cancelTimeout = clearTimeout;
    var noTimeout = -1;

    function shouldDeprioritizeSubtree(type, props) {
      return false;
    }

    function shouldSetTextContent(type, props) {






      return false;
    }





    var supportsMutation = true;

    function appendChild(parentInstance, child) {
      var childTag = typeof child === "number" ? child : child._nativeTag;
      var children = parentInstance._children;
      var index = children.indexOf(child);

      if (index >= 0) {
        children.splice(index, 1);
        children.push(child);

        UIManager.manageChildren(
        parentInstance._nativeTag,
        [index],
        [children.length - 1],
        [],
        [],
        []);

      } else {
        children.push(child);

        UIManager.manageChildren(
        parentInstance._nativeTag,
        [],
        [],
        [childTag],
        [children.length - 1],
        []);

      }
    }

    function appendChildToContainer(parentInstance, child) {
      var childTag = typeof child === "number" ? child : child._nativeTag;
      UIManager.setChildren(
      parentInstance,
      [childTag]);

    }

    function commitTextUpdate(textInstance, oldText, newText) {
      UIManager.updateView(
      textInstance,
      "RCTRawText",
      { text: newText });

    }

    function commitUpdate(
    instance,
    updatePayloadTODO,
    type,
    oldProps,
    newProps,
    internalInstanceHandle)
    {
      var viewConfig = instance.viewConfig;

      updateFiberProps(instance._nativeTag, newProps);

      var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);




      if (updatePayload != null) {
        UIManager.updateView(
        instance._nativeTag,
        viewConfig.uiViewClassName,
        updatePayload);

      }
    }

    function insertBefore(parentInstance, child, beforeChild) {
      var children = parentInstance._children;
      var index = children.indexOf(child);


      if (index >= 0) {
        children.splice(index, 1);
        var beforeChildIndex = children.indexOf(beforeChild);
        children.splice(beforeChildIndex, 0, child);

        UIManager.manageChildren(
        parentInstance._nativeTag,
        [index],
        [beforeChildIndex],
        [],
        [],
        []);

      } else {
        var _beforeChildIndex = children.indexOf(beforeChild);
        children.splice(_beforeChildIndex, 0, child);

        var childTag = typeof child === "number" ? child : child._nativeTag;

        UIManager.manageChildren(
        parentInstance._nativeTag,
        [],
        [],
        [childTag],
        [_beforeChildIndex],
        []);

      }
    }

    function insertInContainerBefore(parentInstance, child, beforeChild) {




      invariant(
      typeof parentInstance !== "number",
      "Container does not support insertBefore operation");

    }

    function removeChild(parentInstance, child) {
      recursivelyUncacheFiberNode(child);
      var children = parentInstance._children;
      var index = children.indexOf(child);

      children.splice(index, 1);

      UIManager.manageChildren(
      parentInstance._nativeTag,
      [],
      [],
      [],
      [],
      [index]);

    }

    function removeChildFromContainer(parentInstance, child) {
      recursivelyUncacheFiberNode(child);
      UIManager.manageChildren(
      parentInstance,
      [],
      [],
      [],
      [],
      [0]);

    }

    function resetTextContent(instance) {

    }

    var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      var sourceInfo = "";
      if (source) {
        var path = source.fileName;
        var fileName = path.replace(BEFORE_SLASH_RE, "");
        {


          if (/^index\./.test(fileName)) {
            var match = path.match(BEFORE_SLASH_RE);
            if (match) {
              var pathBeforeSlash = match[1];
              if (pathBeforeSlash) {
                var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                fileName = folderName + "/" + fileName;
              }
            }
          }
        }
        sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
      } else if (ownerName) {
        sourceInfo = " (created by " + ownerName + ")";
      }
      return "\n    in " + (name || "Unknown") + sourceInfo;
    };

    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

    function describeFiber(fiber) {
      switch (fiber.tag) {
        case IndeterminateComponent:
        case FunctionalComponent:
        case FunctionalComponentLazy:
        case ClassComponent:
        case ClassComponentLazy:
        case HostComponent:
        case Mode:
          var owner = fiber._debugOwner;
          var source = fiber._debugSource;
          var name = getComponentName(fiber.type);
          var ownerName = null;
          if (owner) {
            ownerName = getComponentName(owner.type);
          }
          return describeComponentFrame(name, source, ownerName);
        default:
          return "";}

    }

    function getStackByFiberInDevAndProd(workInProgress) {
      var info = "";
      var node = workInProgress;
      do {
        info += describeFiber(node);
        node = node.return;
      } while (node);
      return info;
    }

    var current = null;
    var phase = null;

    function getCurrentFiberOwnerNameInDevOrNull() {
      {
        if (current === null) {
          return null;
        }
        var owner = current._debugOwner;
        if (owner !== null && typeof owner !== "undefined") {
          return getComponentName(owner.type);
        }
      }
      return null;
    }

    function getCurrentFiberStackInDev() {
      {
        if (current === null) {
          return "";
        }


        return getStackByFiberInDevAndProd(current);
      }
      return "";
    }

    function resetCurrentFiber() {
      {
        ReactDebugCurrentFrame.getCurrentStack = null;
        current = null;
        phase = null;
      }
    }

    function setCurrentFiber(fiber) {
      {
        ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
        current = fiber;
        phase = null;
      }
    }

    function setCurrentPhase(lifeCyclePhase) {
      {
        phase = lifeCyclePhase;
      }
    }

    var debugRenderPhaseSideEffects = false;
    var debugRenderPhaseSideEffectsForStrictMode = false;
    var enableGetDerivedStateFromCatch = false;
    var enableSuspense = false;
    var enableUserTimingAPI = true;
    var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
    var warnAboutDeprecatedLifecycles = false;
    var warnAboutLegacyContextAPI = false;
    var enableProfilerTimer = true;
    var enableSchedulerTracking = true;





    var reactEmoji = "\u269B";
    var warningEmoji = "\u26D4";
    var supportsUserTiming =
    typeof performance !== "undefined" &&
    typeof performance.mark === "function" &&
    typeof performance.clearMarks === "function" &&
    typeof performance.measure === "function" &&
    typeof performance.clearMeasures === "function";



    var currentFiber = null;




    var currentPhase = null;
    var currentPhaseFiber = null;



    var isCommitting = false;
    var hasScheduledUpdateInCurrentCommit = false;
    var hasScheduledUpdateInCurrentPhase = false;
    var commitCountInCurrentWorkLoop = 0;
    var effectCountInCurrentCommit = 0;
    var isWaitingForCallback = false;


    var labelsInCurrentCommit = new Set();

    var formatMarkName = function formatMarkName(markName) {
      return reactEmoji + " " + markName;
    };

    var formatLabel = function formatLabel(label, warning) {
      var prefix = warning ? warningEmoji + " " : reactEmoji + " ";
      var suffix = warning ? " Warning: " + warning : "";
      return "" + prefix + label + suffix;
    };

    var beginMark = function beginMark(markName) {
      performance.mark(formatMarkName(markName));
    };

    var clearMark = function clearMark(markName) {
      performance.clearMarks(formatMarkName(markName));
    };

    var endMark = function endMark(label, markName, warning) {
      var formattedMarkName = formatMarkName(markName);
      var formattedLabel = formatLabel(label, warning);
      try {
        performance.measure(formattedLabel, formattedMarkName);
      } catch (err) {}





      performance.clearMarks(formattedMarkName);
      performance.clearMeasures(formattedLabel);
    };

    var getFiberMarkName = function getFiberMarkName(label, debugID) {
      return label + " (#" + debugID + ")";
    };

    var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
      if (phase === null) {

        return componentName + " [" + (isMounted ? "update" : "mount") + "]";
      } else {

        return componentName + "." + phase;
      }
    };

    var beginFiberMark = function beginFiberMark(fiber, phase) {
      var componentName = getComponentName(fiber.type) || "Unknown";
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);

      if (isCommitting && labelsInCurrentCommit.has(label)) {



        return false;
      }
      labelsInCurrentCommit.add(label);

      var markName = getFiberMarkName(label, debugID);
      beginMark(markName);
      return true;
    };

    var clearFiberMark = function clearFiberMark(fiber, phase) {
      var componentName = getComponentName(fiber.type) || "Unknown";
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);
      var markName = getFiberMarkName(label, debugID);
      clearMark(markName);
    };

    var endFiberMark = function endFiberMark(fiber, phase, warning) {
      var componentName = getComponentName(fiber.type) || "Unknown";
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);
      var markName = getFiberMarkName(label, debugID);
      endMark(label, markName, warning);
    };

    var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {


      switch (fiber.tag) {
        case HostRoot:
        case HostComponent:
        case HostText:
        case HostPortal:
        case Fragment:
        case ContextProvider:
        case ContextConsumer:
        case Mode:
          return true;
        default:
          return false;}

    };

    var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
      if (currentPhase !== null && currentPhaseFiber !== null) {
        clearFiberMark(currentPhaseFiber, currentPhase);
      }
      currentPhaseFiber = null;
      currentPhase = null;
      hasScheduledUpdateInCurrentPhase = false;
    };

    var pauseTimers = function pauseTimers() {


      var fiber = currentFiber;
      while (fiber) {
        if (fiber._debugIsCurrentlyTiming) {
          endFiberMark(fiber, null, null);
        }
        fiber = fiber.return;
      }
    };

    var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
      if (fiber.return !== null) {
        resumeTimersRecursively(fiber.return);
      }
      if (fiber._debugIsCurrentlyTiming) {
        beginFiberMark(fiber, null);
      }
    };

    var resumeTimers = function resumeTimers() {

      if (currentFiber !== null) {
        resumeTimersRecursively(currentFiber);
      }
    };

    function recordEffect() {
      if (enableUserTimingAPI) {
        effectCountInCurrentCommit++;
      }
    }

    function recordScheduleUpdate() {
      if (enableUserTimingAPI) {
        if (isCommitting) {
          hasScheduledUpdateInCurrentCommit = true;
        }
        if (
        currentPhase !== null &&
        currentPhase !== "componentWillMount" &&
        currentPhase !== "componentWillReceiveProps")
        {
          hasScheduledUpdateInCurrentPhase = true;
        }
      }
    }

    function startRequestCallbackTimer() {
      if (enableUserTimingAPI) {
        if (supportsUserTiming && !isWaitingForCallback) {
          isWaitingForCallback = true;
          beginMark("(Waiting for async callback...)");
        }
      }
    }

    function stopRequestCallbackTimer(didExpire, expirationTime) {
      if (enableUserTimingAPI) {
        if (supportsUserTiming) {
          isWaitingForCallback = false;
          var warning = didExpire ? "React was blocked by main thread" : null;
          endMark(
          "(Waiting for async callback... will force flush in " +
          expirationTime +
          " ms)",
          "(Waiting for async callback...)",
          warning);

        }
      }
    }

    function startWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        }

        currentFiber = fiber;
        if (!beginFiberMark(fiber, null)) {
          return;
        }
        fiber._debugIsCurrentlyTiming = true;
      }
    }

    function cancelWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        }


        fiber._debugIsCurrentlyTiming = false;
        clearFiberMark(fiber, null);
      }
    }

    function stopWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        }

        currentFiber = fiber.return;
        if (!fiber._debugIsCurrentlyTiming) {
          return;
        }
        fiber._debugIsCurrentlyTiming = false;
        endFiberMark(fiber, null, null);
      }
    }

    function stopFailedWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        }

        currentFiber = fiber.return;
        if (!fiber._debugIsCurrentlyTiming) {
          return;
        }
        fiber._debugIsCurrentlyTiming = false;
        var warning = "An error was thrown inside this error boundary";
        endFiberMark(fiber, null, warning);
      }
    }

    function startPhaseTimer(fiber, phase) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        clearPendingPhaseMeasurement();
        if (!beginFiberMark(fiber, phase)) {
          return;
        }
        currentPhaseFiber = fiber;
        currentPhase = phase;
      }
    }

    function stopPhaseTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        if (currentPhase !== null && currentPhaseFiber !== null) {
          var warning = hasScheduledUpdateInCurrentPhase ?
          "Scheduled a cascading update" :
          null;
          endFiberMark(currentPhaseFiber, currentPhase, warning);
        }
        currentPhase = null;
        currentPhaseFiber = null;
      }
    }

    function startWorkLoopTimer(nextUnitOfWork) {
      if (enableUserTimingAPI) {
        currentFiber = nextUnitOfWork;
        if (!supportsUserTiming) {
          return;
        }
        commitCountInCurrentWorkLoop = 0;


        beginMark("(React Tree Reconciliation)");

        resumeTimers();
      }
    }

    function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        var warning = null;
        if (interruptedBy !== null) {
          if (interruptedBy.tag === HostRoot) {
            warning = "A top-level update interrupted the previous render";
          } else {
            var componentName = getComponentName(interruptedBy.type) || "Unknown";
            warning =
            "An update to " + componentName + " interrupted the previous render";
          }
        } else if (commitCountInCurrentWorkLoop > 1) {
          warning = "There were cascading updates";
        }
        commitCountInCurrentWorkLoop = 0;
        var label = didCompleteRoot ?
        "(React Tree Reconciliation: Completed Root)" :
        "(React Tree Reconciliation: Yielded)";

        pauseTimers();
        endMark(label, "(React Tree Reconciliation)", warning);
      }
    }

    function startCommitTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        isCommitting = true;
        hasScheduledUpdateInCurrentCommit = false;
        labelsInCurrentCommit.clear();
        beginMark("(Committing Changes)");
      }
    }

    function stopCommitTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        var warning = null;
        if (hasScheduledUpdateInCurrentCommit) {
          warning = "Lifecycle hook scheduled a cascading update";
        } else if (commitCountInCurrentWorkLoop > 0) {
          warning = "Caused by a cascading update in earlier commit";
        }
        hasScheduledUpdateInCurrentCommit = false;
        commitCountInCurrentWorkLoop++;
        isCommitting = false;
        labelsInCurrentCommit.clear();

        endMark("(Committing Changes)", "(Committing Changes)", warning);
      }
    }

    function startCommitSnapshotEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        effectCountInCurrentCommit = 0;
        beginMark("(Committing Snapshot Effects)");
      }
    }

    function stopCommitSnapshotEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        var count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = 0;
        endMark(
        "(Committing Snapshot Effects: " + count + " Total)",
        "(Committing Snapshot Effects)",
        null);

      }
    }

    function startCommitHostEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        effectCountInCurrentCommit = 0;
        beginMark("(Committing Host Effects)");
      }
    }

    function stopCommitHostEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        var count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = 0;
        endMark(
        "(Committing Host Effects: " + count + " Total)",
        "(Committing Host Effects)",
        null);

      }
    }

    function startCommitLifeCyclesTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        effectCountInCurrentCommit = 0;
        beginMark("(Calling Lifecycle Methods)");
      }
    }

    function stopCommitLifeCyclesTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        var count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = 0;
        endMark(
        "(Calling Lifecycle Methods: " + count + " Total)",
        "(Calling Lifecycle Methods)",
        null);

      }
    }

    var valueStack = [];

    var fiberStack = void 0;

    {
      fiberStack = [];
    }

    var index = -1;

    function createCursor(defaultValue) {
      return {
        current: defaultValue };

    }

    function pop(cursor, fiber) {
      if (index < 0) {
        {
          warningWithoutStack$1(false, "Unexpected pop.");
        }
        return;
      }

      {
        if (fiber !== fiberStack[index]) {
          warningWithoutStack$1(false, "Unexpected Fiber popped.");
        }
      }

      cursor.current = valueStack[index];

      valueStack[index] = null;

      {
        fiberStack[index] = null;
      }

      index--;
    }

    function push(cursor, value, fiber) {
      index++;

      valueStack[index] = cursor.current;

      {
        fiberStack[index] = fiber;
      }

      cursor.current = value;
    }

    function checkThatStackIsEmpty() {
      {
        if (index !== -1) {
          warningWithoutStack$1(
          false,
          "Expected an empty stack. Something was not reset properly.");

        }
      }
    }

    function resetStackAfterFatalErrorInDev() {
      {
        index = -1;
        valueStack.length = 0;
        fiberStack.length = 0;
      }
    }

    var warnedAboutMissingGetChildContext = void 0;

    {
      warnedAboutMissingGetChildContext = {};
    }

    var emptyContextObject = {};
    {
      Object.freeze(emptyContextObject);
    }


    var contextStackCursor = createCursor(emptyContextObject);

    var didPerformWorkStackCursor = createCursor(false);



    var previousContext = emptyContextObject;

    function getUnmaskedContext(
    workInProgress,
    Component,
    didPushOwnContextIfProvider)
    {
      if (didPushOwnContextIfProvider && isContextProvider(Component)) {




        return previousContext;
      }
      return contextStackCursor.current;
    }

    function cacheContext(workInProgress, unmaskedContext, maskedContext) {
      var instance = workInProgress.stateNode;
      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
    }

    function getMaskedContext(workInProgress, unmaskedContext) {
      var type = workInProgress.type;
      var contextTypes = type.contextTypes;
      if (!contextTypes) {
        return emptyContextObject;
      }




      var instance = workInProgress.stateNode;
      if (
      instance &&
      instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext)
      {
        return instance.__reactInternalMemoizedMaskedChildContext;
      }

      var context = {};
      for (var key in contextTypes) {
        context[key] = unmaskedContext[key];
      }

      {
        var name = getComponentName(type) || "Unknown";
        checkPropTypes(
        contextTypes,
        context,
        "context",
        name,
        getCurrentFiberStackInDev);

      }



      if (instance) {
        cacheContext(workInProgress, unmaskedContext, context);
      }

      return context;
    }

    function hasContextChanged() {
      return didPerformWorkStackCursor.current;
    }

    function isContextProvider(type) {
      var childContextTypes = type.childContextTypes;
      return childContextTypes !== null && childContextTypes !== undefined;
    }

    function popContext(fiber) {
      pop(didPerformWorkStackCursor, fiber);
      pop(contextStackCursor, fiber);
    }

    function popTopLevelContextObject(fiber) {
      pop(didPerformWorkStackCursor, fiber);
      pop(contextStackCursor, fiber);
    }

    function pushTopLevelContextObject(fiber, context, didChange) {
      invariant(
      contextStackCursor.current === emptyContextObject,
      "Unexpected context found on stack. " +
      "This error is likely caused by a bug in React. Please file an issue.");


      push(contextStackCursor, context, fiber);
      push(didPerformWorkStackCursor, didChange, fiber);
    }

    function processChildContext(fiber, type, parentContext) {
      var instance = fiber.stateNode;
      var childContextTypes = type.childContextTypes;



      if (typeof instance.getChildContext !== "function") {
        {
          var componentName = getComponentName(type) || "Unknown";

          if (!warnedAboutMissingGetChildContext[componentName]) {
            warnedAboutMissingGetChildContext[componentName] = true;
            warningWithoutStack$1(
            false,
            "%s.childContextTypes is specified but there is no getChildContext() method " +
            "on the instance. You can either define getChildContext() on %s or remove " +
            "childContextTypes from it.",
            componentName,
            componentName);

          }
        }
        return parentContext;
      }

      var childContext = void 0;
      {
        setCurrentPhase("getChildContext");
      }
      startPhaseTimer(fiber, "getChildContext");
      childContext = instance.getChildContext();
      stopPhaseTimer();
      {
        setCurrentPhase(null);
      }
      for (var contextKey in childContext) {
        invariant(
        contextKey in childContextTypes,
        '%s.getChildContext(): key "%s" is not defined in childContextTypes.',
        getComponentName(type) || "Unknown",
        contextKey);

      }
      {
        var name = getComponentName(type) || "Unknown";
        checkPropTypes(
        childContextTypes,
        childContext,
        "child context",
        name,





        getCurrentFiberStackInDev);

      }

      return _extends({}, parentContext, childContext);
    }

    function pushContextProvider(workInProgress) {
      var instance = workInProgress.stateNode;



      var memoizedMergedChildContext =
      instance && instance.__reactInternalMemoizedMergedChildContext ||
      emptyContextObject;



      previousContext = contextStackCursor.current;
      push(contextStackCursor, memoizedMergedChildContext, workInProgress);
      push(
      didPerformWorkStackCursor,
      didPerformWorkStackCursor.current,
      workInProgress);


      return true;
    }

    function invalidateContextProvider(workInProgress, type, didChange) {
      var instance = workInProgress.stateNode;
      invariant(
      instance,
      "Expected to have an instance by this point. " +
      "This error is likely caused by a bug in React. Please file an issue.");


      if (didChange) {



        var mergedContext = processChildContext(
        workInProgress,
        type,
        previousContext);

        instance.__reactInternalMemoizedMergedChildContext = mergedContext;



        pop(didPerformWorkStackCursor, workInProgress);
        pop(contextStackCursor, workInProgress);

        push(contextStackCursor, mergedContext, workInProgress);
        push(didPerformWorkStackCursor, didChange, workInProgress);
      } else {
        pop(didPerformWorkStackCursor, workInProgress);
        push(didPerformWorkStackCursor, didChange, workInProgress);
      }
    }

    function findCurrentUnmaskedContext(fiber) {


      invariant(
      isFiberMounted(fiber) && (
      fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy),
      "Expected subtree parent to be a mounted class component. " +
      "This error is likely caused by a bug in React. Please file an issue.");


      var node = fiber;
      do {
        switch (node.tag) {
          case HostRoot:
            return node.stateNode.context;
          case ClassComponent:{
              var Component = node.type;
              if (isContextProvider(Component)) {
                return node.stateNode.__reactInternalMemoizedMergedChildContext;
              }
              break;
            }
          case ClassComponentLazy:{
              var _Component = getResultFromResolvedThenable(node.type);
              if (isContextProvider(_Component)) {
                return node.stateNode.__reactInternalMemoizedMergedChildContext;
              }
              break;
            }}

        node = node.return;
      } while (node !== null);
      invariant(
      false,
      "Found unexpected detached subtree parent. " +
      "This error is likely caused by a bug in React. Please file an issue.");

    }

    var onCommitFiberRoot = null;
    var onCommitFiberUnmount = null;
    var hasLoggedError = false;

    function catchErrors(fn) {
      return function (arg) {
        try {
          return fn(arg);
        } catch (err) {
          if (true && !hasLoggedError) {
            hasLoggedError = true;
            warningWithoutStack$1(
            false,
            "React DevTools encountered an error: %s",
            err);

          }
        }
      };
    }

    var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";

    function injectInternals(internals) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {

        return false;
      }
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled) {



        return true;
      }
      if (!hook.supportsFiber) {
        {
          warningWithoutStack$1(
          false,
          "The installed version of React DevTools is too old and will not work " +
          "with the current version of React. Please update React DevTools. " +
          "https://fb.me/react-devtools");

        }

        return true;
      }
      try {
        var rendererID = hook.inject(internals);

        onCommitFiberRoot = catchErrors(function (root) {
          return hook.onCommitFiberRoot(rendererID, root);
        });
        onCommitFiberUnmount = catchErrors(function (fiber) {
          return hook.onCommitFiberUnmount(rendererID, fiber);
        });
      } catch (err) {

        {
          warningWithoutStack$1(
          false,
          "React DevTools encountered an error: %s.",
          err);

        }
      }

      return true;
    }

    function onCommitRoot(root) {
      if (typeof onCommitFiberRoot === "function") {
        onCommitFiberRoot(root);
      }
    }

    function onCommitUnmount(fiber) {
      if (typeof onCommitFiberUnmount === "function") {
        onCommitFiberUnmount(fiber);
      }
    }




    var maxSigned31BitInt = 1073741823;

    var NoWork = 0;
    var Sync = 1;
    var Never = maxSigned31BitInt;

    var UNIT_SIZE = 10;
    var MAGIC_NUMBER_OFFSET = 2;


    function msToExpirationTime(ms) {

      return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
    }

    function expirationTimeToMs(expirationTime) {
      return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
    }

    function ceiling(num, precision) {
      return ((num / precision | 0) + 1) * precision;
    }

    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
      return (
        MAGIC_NUMBER_OFFSET +
        ceiling(
        currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,
        bucketSizeMs / UNIT_SIZE));


    }

    var LOW_PRIORITY_EXPIRATION = 5000;
    var LOW_PRIORITY_BATCH_SIZE = 250;

    function computeAsyncExpiration(currentTime) {
      return computeExpirationBucket(
      currentTime,
      LOW_PRIORITY_EXPIRATION,
      LOW_PRIORITY_BATCH_SIZE);

    }












    var HIGH_PRIORITY_EXPIRATION = 500;
    var HIGH_PRIORITY_BATCH_SIZE = 100;

    function computeInteractiveExpiration(currentTime) {
      return computeExpirationBucket(
      currentTime,
      HIGH_PRIORITY_EXPIRATION,
      HIGH_PRIORITY_BATCH_SIZE);

    }

    var NoContext = 0;
    var AsyncMode = 1;
    var StrictMode = 2;
    var ProfileMode = 4;

    var hasBadMapPolyfill = void 0;

    {
      hasBadMapPolyfill = false;
      try {
        var nonExtensibleObject = Object.preventExtensions({});
        var testMap = new Map([[nonExtensibleObject, null]]);
        var testSet = new Set([nonExtensibleObject]);



        testMap.set(0, 0);
        testSet.add(0);
      } catch (e) {

        hasBadMapPolyfill = true;
      }
    }




    var debugCounter = void 0;

    {
      debugCounter = 1;
    }

    function FiberNode(tag, pendingProps, key, mode) {

      this.tag = tag;
      this.key = key;
      this.type = null;
      this.stateNode = null;


      this.return = null;
      this.child = null;
      this.sibling = null;
      this.index = 0;

      this.ref = null;

      this.pendingProps = pendingProps;
      this.memoizedProps = null;
      this.updateQueue = null;
      this.memoizedState = null;
      this.firstContextDependency = null;

      this.mode = mode;


      this.effectTag = NoEffect;
      this.nextEffect = null;

      this.firstEffect = null;
      this.lastEffect = null;

      this.expirationTime = NoWork;
      this.childExpirationTime = NoWork;

      this.alternate = null;

      if (enableProfilerTimer) {
        this.actualDuration = 0;
        this.actualStartTime = -1;
        this.selfBaseDuration = 0;
        this.treeBaseDuration = 0;
      }

      {
        this._debugID = debugCounter++;
        this._debugSource = null;
        this._debugOwner = null;
        this._debugIsCurrentlyTiming = false;
        if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
          Object.preventExtensions(this);
        }
      }
    }














    var createFiber = function createFiber(tag, pendingProps, key, mode) {

      return new FiberNode(tag, pendingProps, key, mode);
    };

    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }

    function resolveLazyComponentTag(fiber, Component) {
      if (typeof Component === "function") {
        return shouldConstruct(Component) ?
        ClassComponentLazy :
        FunctionalComponentLazy;
      } else if (
      Component !== undefined &&
      Component !== null &&
      Component.$$typeof)
      {
        return ForwardRefLazy;
      }
      return IndeterminateComponent;
    }


    function createWorkInProgress(current, pendingProps, expirationTime) {
      var workInProgress = current.alternate;
      if (workInProgress === null) {





        workInProgress = createFiber(
        current.tag,
        pendingProps,
        current.key,
        current.mode);

        workInProgress.type = current.type;
        workInProgress.stateNode = current.stateNode;

        {

          workInProgress._debugID = current._debugID;
          workInProgress._debugSource = current._debugSource;
          workInProgress._debugOwner = current._debugOwner;
        }

        workInProgress.alternate = current;
        current.alternate = workInProgress;
      } else {
        workInProgress.pendingProps = pendingProps;



        workInProgress.effectTag = NoEffect;


        workInProgress.nextEffect = null;
        workInProgress.firstEffect = null;
        workInProgress.lastEffect = null;

        if (enableProfilerTimer) {




          workInProgress.actualDuration = 0;
          workInProgress.actualStartTime = -1;
        }
      }


      workInProgress.childExpirationTime = current.childExpirationTime;
      if (pendingProps !== current.pendingProps) {

        workInProgress.expirationTime = expirationTime;
      } else {

        workInProgress.expirationTime = current.expirationTime;
      }

      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.firstContextDependency = current.firstContextDependency;


      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;

      if (enableProfilerTimer) {
        workInProgress.selfBaseDuration = current.selfBaseDuration;
        workInProgress.treeBaseDuration = current.treeBaseDuration;
      }

      return workInProgress;
    }

    function createHostRootFiber(isAsync) {
      var mode = isAsync ? AsyncMode | StrictMode : NoContext;

      if (enableProfilerTimer && isDevToolsPresent) {



        mode |= ProfileMode;
      }

      return createFiber(HostRoot, null, null, mode);
    }

    function createFiberFromElement(element, mode, expirationTime) {
      var owner = null;
      {
        owner = element._owner;
      }

      var fiber = void 0;
      var type = element.type;
      var key = element.key;
      var pendingProps = element.props;

      var fiberTag = void 0;
      if (typeof type === "function") {
        fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;
      } else if (typeof type === "string") {
        fiberTag = HostComponent;
      } else {
        getTag: switch (type) {
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(
            pendingProps.children,
            mode,
            expirationTime,
            key);

          case REACT_ASYNC_MODE_TYPE:
            fiberTag = Mode;
            mode |= AsyncMode | StrictMode;
            break;
          case REACT_STRICT_MODE_TYPE:
            fiberTag = Mode;
            mode |= StrictMode;
            break;
          case REACT_PROFILER_TYPE:
            return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
          case REACT_PLACEHOLDER_TYPE:
            fiberTag = PlaceholderComponent;
            break;
          default:{
              if (typeof type === "object" && type !== null) {
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                    fiberTag = ContextProvider;
                    break getTag;
                  case REACT_CONTEXT_TYPE:

                    fiberTag = ContextConsumer;
                    break getTag;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = ForwardRef;
                    break getTag;
                  default:{
                      if (typeof type.then === "function") {
                        fiberTag = IndeterminateComponent;
                        break getTag;
                      }
                    }}

              }
              var info = "";
              {
                if (
                type === undefined ||
                typeof type === "object" &&
                type !== null &&
                Object.keys(type).length === 0)
                {
                  info +=
                  " You likely forgot to export your component from the file " +
                  "it's defined in, or you might have mixed up default and " +
                  "named imports.";
                }
                var ownerName = owner ? getComponentName(owner.type) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              invariant(
              false,
              "Element type is invalid: expected a string (for built-in " +
              "components) or a class/function (for composite components) " +
              "but got: %s.%s",
              type == null ? type : typeof type,
              info);

            }}

      }

      fiber = createFiber(fiberTag, pendingProps, key, mode);
      fiber.type = type;
      fiber.expirationTime = expirationTime;

      {
        fiber._debugSource = element._source;
        fiber._debugOwner = element._owner;
      }

      return fiber;
    }

    function createFiberFromFragment(elements, mode, expirationTime, key) {
      var fiber = createFiber(Fragment, elements, key, mode);
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
      {
        if (
        typeof pendingProps.id !== "string" ||
        typeof pendingProps.onRender !== "function")
        {
          warningWithoutStack$1(
          false,
          'Profiler must specify an "id" string and "onRender" function as props');

        }
      }

      var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
      fiber.type = REACT_PROFILER_TYPE;
      fiber.expirationTime = expirationTime;

      return fiber;
    }

    function createFiberFromText(content, mode, expirationTime) {
      var fiber = createFiber(HostText, content, null, mode);
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromHostInstanceForDeletion() {
      var fiber = createFiber(HostComponent, null, null, NoContext);
      fiber.type = "DELETED";
      return fiber;
    }

    function createFiberFromPortal(portal, mode, expirationTime) {
      var pendingProps = portal.children !== null ? portal.children : [];
      var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
      fiber.expirationTime = expirationTime;
      fiber.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation };

      return fiber;
    }


    function assignFiberPropertiesInDEV(target, source) {
      if (target === null) {


        target = createFiber(IndeterminateComponent, null, null, NoContext);
      }







      target.tag = source.tag;
      target.key = source.key;
      target.type = source.type;
      target.stateNode = source.stateNode;
      target.return = source.return;
      target.child = source.child;
      target.sibling = source.sibling;
      target.index = source.index;
      target.ref = source.ref;
      target.pendingProps = source.pendingProps;
      target.memoizedProps = source.memoizedProps;
      target.updateQueue = source.updateQueue;
      target.memoizedState = source.memoizedState;
      target.firstContextDependency = source.firstContextDependency;
      target.mode = source.mode;
      target.effectTag = source.effectTag;
      target.nextEffect = source.nextEffect;
      target.firstEffect = source.firstEffect;
      target.lastEffect = source.lastEffect;
      target.expirationTime = source.expirationTime;
      target.childExpirationTime = source.childExpirationTime;
      target.alternate = source.alternate;
      if (enableProfilerTimer) {
        target.actualDuration = source.actualDuration;
        target.actualStartTime = source.actualStartTime;
        target.selfBaseDuration = source.selfBaseDuration;
        target.treeBaseDuration = source.treeBaseDuration;
      }
      target._debugID = source._debugID;
      target._debugSource = source._debugSource;
      target._debugOwner = source._debugOwner;
      target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
      return target;
    }

















    function createFiberRoot(containerInfo, isAsync, hydrate) {


      var uninitializedFiber = createHostRootFiber(isAsync);

      var root = void 0;
      if (enableSchedulerTracking) {
        root = {
          current: uninitializedFiber,
          containerInfo: containerInfo,
          pendingChildren: null,

          earliestPendingTime: NoWork,
          latestPendingTime: NoWork,
          earliestSuspendedTime: NoWork,
          latestSuspendedTime: NoWork,
          latestPingedTime: NoWork,

          didError: false,

          pendingCommitExpirationTime: NoWork,
          finishedWork: null,
          timeoutHandle: noTimeout,
          context: null,
          pendingContext: null,
          hydrate: hydrate,
          nextExpirationTimeToWorkOn: NoWork,
          expirationTime: NoWork,
          firstBatch: null,
          nextScheduledRoot: null,

          interactionThreadID: tracking.unstable_getThreadID(),
          memoizedInteractions: new Set(),
          pendingInteractionMap: new Map() };

      } else {
        root = {
          current: uninitializedFiber,
          containerInfo: containerInfo,
          pendingChildren: null,

          earliestPendingTime: NoWork,
          latestPendingTime: NoWork,
          earliestSuspendedTime: NoWork,
          latestSuspendedTime: NoWork,
          latestPingedTime: NoWork,

          didError: false,

          pendingCommitExpirationTime: NoWork,
          finishedWork: null,
          timeoutHandle: noTimeout,
          context: null,
          pendingContext: null,
          hydrate: hydrate,
          nextExpirationTimeToWorkOn: NoWork,
          expirationTime: NoWork,
          firstBatch: null,
          nextScheduledRoot: null };

      }

      uninitializedFiber.stateNode = root;





      return root;
    }















    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (
        var _len = arguments.length,
        args = Array(_len > 1 ? _len - 1 : 0),
        _key = 1;
        _key < _len;
        _key++)
        {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message =
        "Warning: " +
        format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.warn(message);
        }
        try {



          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error(
          "`lowPriorityWarning(condition, format, ...args)` requires a warning " +
          "message argument");

        }
        if (!condition) {
          for (
          var _len2 = arguments.length,
          args = Array(_len2 > 2 ? _len2 - 2 : 0),
          _key2 = 2;
          _key2 < _len2;
          _key2++)
          {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    var ReactStrictModeWarnings = {
      discardPendingWarnings: function discardPendingWarnings() {},
      flushPendingDeprecationWarnings: function flushPendingDeprecationWarnings() {},
      flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},
      recordDeprecationWarnings: function recordDeprecationWarnings(fiber, instance) {},
      recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},
      recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},
      flushLegacyContextWarning: function flushLegacyContextWarning() {} };


    {
      var LIFECYCLE_SUGGESTIONS = {
        UNSAFE_componentWillMount: "componentDidMount",
        UNSAFE_componentWillReceiveProps: "static getDerivedStateFromProps",
        UNSAFE_componentWillUpdate: "componentDidUpdate" };


      var pendingComponentWillMountWarnings = [];
      var pendingComponentWillReceivePropsWarnings = [];
      var pendingComponentWillUpdateWarnings = [];
      var pendingUnsafeLifecycleWarnings = new Map();
      var pendingLegacyContextWarning = new Map();


      var didWarnAboutDeprecatedLifecycles = new Set();
      var didWarnAboutUnsafeLifecycles = new Set();
      var didWarnAboutLegacyContext = new Set();

      var setToSortedString = function setToSortedString(set) {
        var array = [];
        set.forEach(function (value) {
          array.push(value);
        });
        return array.sort().join(", ");
      };

      ReactStrictModeWarnings.discardPendingWarnings = function () {
        pendingComponentWillMountWarnings = [];
        pendingComponentWillReceivePropsWarnings = [];
        pendingComponentWillUpdateWarnings = [];
        pendingUnsafeLifecycleWarnings = new Map();
        pendingLegacyContextWarning = new Map();
      };

      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
        pendingUnsafeLifecycleWarnings.forEach(function (
        lifecycleWarningsMap,
        strictRoot)
        {
          var lifecyclesWarningMesages = [];

          Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
            var lifecycleWarnings = lifecycleWarningsMap[lifecycle];
            if (lifecycleWarnings.length > 0) {
              var componentNames = new Set();
              lifecycleWarnings.forEach(function (fiber) {
                componentNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });

              var formatted = lifecycle.replace("UNSAFE_", "");
              var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
              var sortedComponentNames = setToSortedString(componentNames);

              lifecyclesWarningMesages.push(
              formatted +
              ": Please update the following components to use " + (
              suggestion + " instead: " + sortedComponentNames));

            }
          });

          if (lifecyclesWarningMesages.length > 0) {
            var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);

            warningWithoutStack$1(
            false,
            "Unsafe lifecycle methods were found within a strict-mode tree:%s" +
            "\n\n%s" +
            "\n\nLearn more about this warning here:" +
            "\nhttps://fb.me/react-strict-mode-warnings",
            strictRootComponentStack,
            lifecyclesWarningMesages.join("\n\n"));

          }
        });

        pendingUnsafeLifecycleWarnings = new Map();
      };

      var findStrictRoot = function findStrictRoot(fiber) {
        var maybeStrictRoot = null;

        var node = fiber;
        while (node !== null) {
          if (node.mode & StrictMode) {
            maybeStrictRoot = node;
          }
          node = node.return;
        }

        return maybeStrictRoot;
      };

      ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
        if (pendingComponentWillMountWarnings.length > 0) {
          var uniqueNames = new Set();
          pendingComponentWillMountWarnings.forEach(function (fiber) {
            uniqueNames.add(getComponentName(fiber.type) || "Component");
            didWarnAboutDeprecatedLifecycles.add(fiber.type);
          });

          var sortedNames = setToSortedString(uniqueNames);

          lowPriorityWarning$1(
          false,
          "componentWillMount is deprecated and will be removed in the next major version. " +
          "Use componentDidMount instead. As a temporary workaround, " +
          "you can rename to UNSAFE_componentWillMount." +
          "\n\nPlease update the following components: %s" +
          "\n\nLearn more about this warning here:" +
          "\nhttps://fb.me/react-async-component-lifecycle-hooks",
          sortedNames);


          pendingComponentWillMountWarnings = [];
        }

        if (pendingComponentWillReceivePropsWarnings.length > 0) {
          var _uniqueNames = new Set();
          pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
            _uniqueNames.add(getComponentName(fiber.type) || "Component");
            didWarnAboutDeprecatedLifecycles.add(fiber.type);
          });

          var _sortedNames = setToSortedString(_uniqueNames);

          lowPriorityWarning$1(
          false,
          "componentWillReceiveProps is deprecated and will be removed in the next major version. " +
          "Use static getDerivedStateFromProps instead." +
          "\n\nPlease update the following components: %s" +
          "\n\nLearn more about this warning here:" +
          "\nhttps://fb.me/react-async-component-lifecycle-hooks",
          _sortedNames);


          pendingComponentWillReceivePropsWarnings = [];
        }

        if (pendingComponentWillUpdateWarnings.length > 0) {
          var _uniqueNames2 = new Set();
          pendingComponentWillUpdateWarnings.forEach(function (fiber) {
            _uniqueNames2.add(getComponentName(fiber.type) || "Component");
            didWarnAboutDeprecatedLifecycles.add(fiber.type);
          });

          var _sortedNames2 = setToSortedString(_uniqueNames2);

          lowPriorityWarning$1(
          false,
          "componentWillUpdate is deprecated and will be removed in the next major version. " +
          "Use componentDidUpdate instead. As a temporary workaround, " +
          "you can rename to UNSAFE_componentWillUpdate." +
          "\n\nPlease update the following components: %s" +
          "\n\nLearn more about this warning here:" +
          "\nhttps://fb.me/react-async-component-lifecycle-hooks",
          _sortedNames2);


          pendingComponentWillUpdateWarnings = [];
        }
      };

      ReactStrictModeWarnings.recordDeprecationWarnings = function (
      fiber,
      instance)
      {

        if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
          return;
        }


        if (
        typeof instance.componentWillMount === "function" &&
        instance.componentWillMount.__suppressDeprecationWarning !== true)
        {
          pendingComponentWillMountWarnings.push(fiber);
        }
        if (
        typeof instance.componentWillReceiveProps === "function" &&
        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true)
        {
          pendingComponentWillReceivePropsWarnings.push(fiber);
        }
        if (
        typeof instance.componentWillUpdate === "function" &&
        instance.componentWillUpdate.__suppressDeprecationWarning !== true)
        {
          pendingComponentWillUpdateWarnings.push(fiber);
        }
      };

      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (
      fiber,
      instance)
      {
        var strictRoot = findStrictRoot(fiber);
        if (strictRoot === null) {
          warningWithoutStack$1(
          false,
          "Expected to find a StrictMode component in a strict mode tree. " +
          "This error is likely caused by a bug in React. Please file an issue.");

          return;
        }






        if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
          return;
        }

        var warningsForRoot = void 0;
        if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
          warningsForRoot = {
            UNSAFE_componentWillMount: [],
            UNSAFE_componentWillReceiveProps: [],
            UNSAFE_componentWillUpdate: [] };


          pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
        } else {
          warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
        }

        var unsafeLifecycles = [];
        if (
        typeof instance.componentWillMount === "function" &&
        instance.componentWillMount.__suppressDeprecationWarning !== true ||
        typeof instance.UNSAFE_componentWillMount === "function")
        {
          unsafeLifecycles.push("UNSAFE_componentWillMount");
        }
        if (
        typeof instance.componentWillReceiveProps === "function" &&
        instance.componentWillReceiveProps.__suppressDeprecationWarning !==
        true ||
        typeof instance.UNSAFE_componentWillReceiveProps === "function")
        {
          unsafeLifecycles.push("UNSAFE_componentWillReceiveProps");
        }
        if (
        typeof instance.componentWillUpdate === "function" &&
        instance.componentWillUpdate.__suppressDeprecationWarning !== true ||
        typeof instance.UNSAFE_componentWillUpdate === "function")
        {
          unsafeLifecycles.push("UNSAFE_componentWillUpdate");
        }

        if (unsafeLifecycles.length > 0) {
          unsafeLifecycles.forEach(function (lifecycle) {
            warningsForRoot[lifecycle].push(fiber);
          });
        }
      };

      ReactStrictModeWarnings.recordLegacyContextWarning = function (
      fiber,
      instance)
      {
        var strictRoot = findStrictRoot(fiber);
        if (strictRoot === null) {
          warningWithoutStack$1(
          false,
          "Expected to find a StrictMode component in a strict mode tree. " +
          "This error is likely caused by a bug in React. Please file an issue.");

          return;
        }


        if (didWarnAboutLegacyContext.has(fiber.type)) {
          return;
        }

        var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

        if (
        fiber.type.contextTypes != null ||
        fiber.type.childContextTypes != null ||
        instance !== null && typeof instance.getChildContext === "function")
        {
          if (warningsForRoot === undefined) {
            warningsForRoot = [];
            pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
          }
          warningsForRoot.push(fiber);
        }
      };

      ReactStrictModeWarnings.flushLegacyContextWarning = function () {
        pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
          var uniqueNames = new Set();
          fiberArray.forEach(function (fiber) {
            uniqueNames.add(getComponentName(fiber.type) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });

          var sortedNames = setToSortedString(uniqueNames);
          var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);

          warningWithoutStack$1(
          false,
          "Legacy context API has been detected within a strict-mode tree: %s" +
          "\n\nPlease update the following components: %s" +
          "\n\nLearn more about this warning here:" +
          "\nhttps://fb.me/react-strict-mode-warnings",
          strictRootComponentStack,
          sortedNames);

        });
      };
    }





    var ReactFiberInstrumentation = {
      debugTool: null };


    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;





    function markPendingPriorityLevel(root, expirationTime) {



      root.didError = false;


      var earliestPendingTime = root.earliestPendingTime;
      if (earliestPendingTime === NoWork) {

        root.earliestPendingTime = root.latestPendingTime = expirationTime;
      } else {
        if (earliestPendingTime > expirationTime) {

          root.earliestPendingTime = expirationTime;
        } else {
          var latestPendingTime = root.latestPendingTime;
          if (latestPendingTime < expirationTime) {

            root.latestPendingTime = expirationTime;
          }
        }
      }
      findNextExpirationTimeToWorkOn(expirationTime, root);
    }

    function markCommittedPriorityLevels(root, earliestRemainingTime) {
      root.didError = false;

      if (earliestRemainingTime === NoWork) {

        root.earliestPendingTime = NoWork;
        root.latestPendingTime = NoWork;
        root.earliestSuspendedTime = NoWork;
        root.latestSuspendedTime = NoWork;
        root.latestPingedTime = NoWork;
        findNextExpirationTimeToWorkOn(NoWork, root);
        return;
      }


      var latestPendingTime = root.latestPendingTime;
      if (latestPendingTime !== NoWork) {
        if (latestPendingTime < earliestRemainingTime) {

          root.earliestPendingTime = root.latestPendingTime = NoWork;
        } else {
          var earliestPendingTime = root.earliestPendingTime;
          if (earliestPendingTime < earliestRemainingTime) {


            root.earliestPendingTime = root.latestPendingTime;
          }
        }
      }





      var earliestSuspendedTime = root.earliestSuspendedTime;
      if (earliestSuspendedTime === NoWork) {


        markPendingPriorityLevel(root, earliestRemainingTime);
        findNextExpirationTimeToWorkOn(NoWork, root);
        return;
      }

      var latestSuspendedTime = root.latestSuspendedTime;
      if (earliestRemainingTime > latestSuspendedTime) {


        root.earliestSuspendedTime = NoWork;
        root.latestSuspendedTime = NoWork;
        root.latestPingedTime = NoWork;



        markPendingPriorityLevel(root, earliestRemainingTime);
        findNextExpirationTimeToWorkOn(NoWork, root);
        return;
      }

      if (earliestRemainingTime < earliestSuspendedTime) {


        markPendingPriorityLevel(root, earliestRemainingTime);
        findNextExpirationTimeToWorkOn(NoWork, root);
        return;
      }



      findNextExpirationTimeToWorkOn(NoWork, root);
    }

    function hasLowerPriorityWork(root, erroredExpirationTime) {
      var latestPendingTime = root.latestPendingTime;
      var latestSuspendedTime = root.latestSuspendedTime;
      var latestPingedTime = root.latestPingedTime;
      return (
        latestPendingTime !== NoWork &&
        latestPendingTime > erroredExpirationTime ||
        latestSuspendedTime !== NoWork &&
        latestSuspendedTime > erroredExpirationTime ||
        latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime);

    }

    function isPriorityLevelSuspended(root, expirationTime) {
      var earliestSuspendedTime = root.earliestSuspendedTime;
      var latestSuspendedTime = root.latestSuspendedTime;
      return (
        earliestSuspendedTime !== NoWork &&
        expirationTime >= earliestSuspendedTime &&
        expirationTime <= latestSuspendedTime);

    }

    function markSuspendedPriorityLevel(root, suspendedTime) {
      root.didError = false;
      clearPing(root, suspendedTime);


      var earliestPendingTime = root.earliestPendingTime;
      var latestPendingTime = root.latestPendingTime;
      if (earliestPendingTime === suspendedTime) {
        if (latestPendingTime === suspendedTime) {

          root.earliestPendingTime = root.latestPendingTime = NoWork;
        } else {


          root.earliestPendingTime = latestPendingTime;
        }
      } else if (latestPendingTime === suspendedTime) {


        root.latestPendingTime = earliestPendingTime;
      }


      var earliestSuspendedTime = root.earliestSuspendedTime;
      var latestSuspendedTime = root.latestSuspendedTime;
      if (earliestSuspendedTime === NoWork) {

        root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
      } else {
        if (earliestSuspendedTime > suspendedTime) {

          root.earliestSuspendedTime = suspendedTime;
        } else if (latestSuspendedTime < suspendedTime) {

          root.latestSuspendedTime = suspendedTime;
        }
      }

      findNextExpirationTimeToWorkOn(suspendedTime, root);
    }

    function markPingedPriorityLevel(root, pingedTime) {
      root.didError = false;




      var latestPingedTime = root.latestPingedTime;
      if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {
        root.latestPingedTime = pingedTime;
      }
      findNextExpirationTimeToWorkOn(pingedTime, root);
    }

    function clearPing(root, completedTime) {


      var latestPingedTime = root.latestPingedTime;
      if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {
        root.latestPingedTime = NoWork;
      }
    }

    function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
      var earliestExpirationTime = renderExpirationTime;

      var earliestPendingTime = root.earliestPendingTime;
      var earliestSuspendedTime = root.earliestSuspendedTime;
      if (
      earliestExpirationTime === NoWork ||
      earliestPendingTime !== NoWork &&
      earliestPendingTime < earliestExpirationTime)
      {
        earliestExpirationTime = earliestPendingTime;
      }
      if (
      earliestExpirationTime === NoWork ||
      earliestSuspendedTime !== NoWork &&
      earliestSuspendedTime < earliestExpirationTime)
      {
        earliestExpirationTime = earliestSuspendedTime;
      }
      return earliestExpirationTime;
    }

    function didExpireAtExpirationTime(root, currentTime) {
      var expirationTime = root.expirationTime;
      if (expirationTime !== NoWork && currentTime >= expirationTime) {

        root.nextExpirationTimeToWorkOn = currentTime;
      }
    }

    function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
      var earliestSuspendedTime = root.earliestSuspendedTime;
      var latestSuspendedTime = root.latestSuspendedTime;
      var earliestPendingTime = root.earliestPendingTime;
      var latestPingedTime = root.latestPingedTime;



      var nextExpirationTimeToWorkOn =
      earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;



      if (
      nextExpirationTimeToWorkOn === NoWork && (
      completedExpirationTime === NoWork ||
      latestSuspendedTime > completedExpirationTime))
      {



        nextExpirationTimeToWorkOn = latestSuspendedTime;
      }

      var expirationTime = nextExpirationTimeToWorkOn;
      if (
      expirationTime !== NoWork &&
      earliestSuspendedTime !== NoWork &&
      earliestSuspendedTime < expirationTime)
      {

        expirationTime = earliestSuspendedTime;
      }

      root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
      root.expirationTime = expirationTime;
    }














































































    var UpdateState = 0;
    var ReplaceState = 1;
    var ForceUpdate = 2;
    var CaptureUpdate = 3;




    var hasForceUpdate = false;

    var didWarnUpdateInsideUpdate = void 0;
    var currentlyProcessingQueue = void 0;
    var resetCurrentlyProcessingQueue = void 0;
    {
      didWarnUpdateInsideUpdate = false;
      currentlyProcessingQueue = null;
      resetCurrentlyProcessingQueue = function resetCurrentlyProcessingQueue() {
        currentlyProcessingQueue = null;
      };
    }

    function createUpdateQueue(baseState) {
      var queue = {
        baseState: baseState,
        firstUpdate: null,
        lastUpdate: null,
        firstCapturedUpdate: null,
        lastCapturedUpdate: null,
        firstEffect: null,
        lastEffect: null,
        firstCapturedEffect: null,
        lastCapturedEffect: null };

      return queue;
    }

    function cloneUpdateQueue(currentQueue) {
      var queue = {
        baseState: currentQueue.baseState,
        firstUpdate: currentQueue.firstUpdate,
        lastUpdate: currentQueue.lastUpdate,



        firstCapturedUpdate: null,
        lastCapturedUpdate: null,

        firstEffect: null,
        lastEffect: null,

        firstCapturedEffect: null,
        lastCapturedEffect: null };

      return queue;
    }

    function createUpdate(expirationTime) {
      return {
        expirationTime: expirationTime,

        tag: UpdateState,
        payload: null,
        callback: null,

        next: null,
        nextEffect: null };

    }

    function appendUpdateToQueue(queue, update) {

      if (queue.lastUpdate === null) {

        queue.firstUpdate = queue.lastUpdate = update;
      } else {
        queue.lastUpdate.next = update;
        queue.lastUpdate = update;
      }
    }

    function enqueueUpdate(fiber, update) {

      var alternate = fiber.alternate;
      var queue1 = void 0;
      var queue2 = void 0;
      if (alternate === null) {

        queue1 = fiber.updateQueue;
        queue2 = null;
        if (queue1 === null) {
          queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
        }
      } else {

        queue1 = fiber.updateQueue;
        queue2 = alternate.updateQueue;
        if (queue1 === null) {
          if (queue2 === null) {

            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
            queue2 = alternate.updateQueue = createUpdateQueue(
            alternate.memoizedState);

          } else {

            queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
          }
        } else {
          if (queue2 === null) {

            queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
          } else {

          }
        }
      }
      if (queue2 === null || queue1 === queue2) {

        appendUpdateToQueue(queue1, update);
      } else {



        if (queue1.lastUpdate === null || queue2.lastUpdate === null) {

          appendUpdateToQueue(queue1, update);
          appendUpdateToQueue(queue2, update);
        } else {


          appendUpdateToQueue(queue1, update);

          queue2.lastUpdate = update;
        }
      }

      {
        if (
        (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) && (
        currentlyProcessingQueue === queue1 ||
        queue2 !== null && currentlyProcessingQueue === queue2) &&
        !didWarnUpdateInsideUpdate)
        {
          warningWithoutStack$1(
          false,
          "An update (setState, replaceState, or forceUpdate) was scheduled " +
          "from inside an update function. Update functions should be pure, " +
          "with zero side-effects. Consider using componentDidUpdate or a " +
          "callback.");

          didWarnUpdateInsideUpdate = true;
        }
      }
    }

    function enqueueCapturedUpdate(workInProgress, update) {


      var workInProgressQueue = workInProgress.updateQueue;
      if (workInProgressQueue === null) {
        workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(
        workInProgress.memoizedState);

      } else {



        workInProgressQueue = ensureWorkInProgressQueueIsAClone(
        workInProgress,
        workInProgressQueue);

      }


      if (workInProgressQueue.lastCapturedUpdate === null) {

        workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
      } else {
        workInProgressQueue.lastCapturedUpdate.next = update;
        workInProgressQueue.lastCapturedUpdate = update;
      }
    }

    function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
      var current = workInProgress.alternate;
      if (current !== null) {


        if (queue === current.updateQueue) {
          queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
        }
      }
      return queue;
    }

    function getStateFromUpdate(
    workInProgress,
    queue,
    update,
    prevState,
    nextProps,
    instance)
    {
      switch (update.tag) {
        case ReplaceState:{
            var _payload = update.payload;
            if (typeof _payload === "function") {

              {
                if (
                debugRenderPhaseSideEffects ||
                debugRenderPhaseSideEffectsForStrictMode &&
                workInProgress.mode & StrictMode)
                {
                  _payload.call(instance, prevState, nextProps);
                }
              }
              return _payload.call(instance, prevState, nextProps);
            }

            return _payload;
          }
        case CaptureUpdate:{
            workInProgress.effectTag =
            workInProgress.effectTag & ~ShouldCapture | DidCapture;
          }

        case UpdateState:{
            var _payload2 = update.payload;
            var partialState = void 0;
            if (typeof _payload2 === "function") {

              {
                if (
                debugRenderPhaseSideEffects ||
                debugRenderPhaseSideEffectsForStrictMode &&
                workInProgress.mode & StrictMode)
                {
                  _payload2.call(instance, prevState, nextProps);
                }
              }
              partialState = _payload2.call(instance, prevState, nextProps);
            } else {

              partialState = _payload2;
            }
            if (partialState === null || partialState === undefined) {

              return prevState;
            }

            return _extends({}, prevState, partialState);
          }
        case ForceUpdate:{
            hasForceUpdate = true;
            return prevState;
          }}

      return prevState;
    }

    function processUpdateQueue(
    workInProgress,
    queue,
    props,
    instance,
    renderExpirationTime)
    {
      hasForceUpdate = false;

      queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);

      {
        currentlyProcessingQueue = queue;
      }


      var newBaseState = queue.baseState;
      var newFirstUpdate = null;
      var newExpirationTime = NoWork;


      var update = queue.firstUpdate;
      var resultState = newBaseState;
      while (update !== null) {
        var updateExpirationTime = update.expirationTime;
        if (updateExpirationTime > renderExpirationTime) {

          if (newFirstUpdate === null) {


            newFirstUpdate = update;


            newBaseState = resultState;
          }


          if (
          newExpirationTime === NoWork ||
          newExpirationTime > updateExpirationTime)
          {
            newExpirationTime = updateExpirationTime;
          }
        } else {


          resultState = getStateFromUpdate(
          workInProgress,
          queue,
          update,
          resultState,
          props,
          instance);

          var _callback = update.callback;
          if (_callback !== null) {
            workInProgress.effectTag |= Callback;

            update.nextEffect = null;
            if (queue.lastEffect === null) {
              queue.firstEffect = queue.lastEffect = update;
            } else {
              queue.lastEffect.nextEffect = update;
              queue.lastEffect = update;
            }
          }
        }

        update = update.next;
      }


      var newFirstCapturedUpdate = null;
      update = queue.firstCapturedUpdate;
      while (update !== null) {
        var _updateExpirationTime = update.expirationTime;
        if (_updateExpirationTime > renderExpirationTime) {

          if (newFirstCapturedUpdate === null) {


            newFirstCapturedUpdate = update;


            if (newFirstUpdate === null) {
              newBaseState = resultState;
            }
          }


          if (
          newExpirationTime === NoWork ||
          newExpirationTime > _updateExpirationTime)
          {
            newExpirationTime = _updateExpirationTime;
          }
        } else {


          resultState = getStateFromUpdate(
          workInProgress,
          queue,
          update,
          resultState,
          props,
          instance);

          var _callback2 = update.callback;
          if (_callback2 !== null) {
            workInProgress.effectTag |= Callback;

            update.nextEffect = null;
            if (queue.lastCapturedEffect === null) {
              queue.firstCapturedEffect = queue.lastCapturedEffect = update;
            } else {
              queue.lastCapturedEffect.nextEffect = update;
              queue.lastCapturedEffect = update;
            }
          }
        }
        update = update.next;
      }

      if (newFirstUpdate === null) {
        queue.lastUpdate = null;
      }
      if (newFirstCapturedUpdate === null) {
        queue.lastCapturedUpdate = null;
      } else {
        workInProgress.effectTag |= Callback;
      }
      if (newFirstUpdate === null && newFirstCapturedUpdate === null) {


        newBaseState = resultState;
      }

      queue.baseState = newBaseState;
      queue.firstUpdate = newFirstUpdate;
      queue.firstCapturedUpdate = newFirstCapturedUpdate;








      workInProgress.expirationTime = newExpirationTime;
      workInProgress.memoizedState = resultState;

      {
        currentlyProcessingQueue = null;
      }
    }

    function callCallback(callback, context) {
      invariant(
      typeof callback === "function",
      "Invalid argument passed as callback. Expected a function. Instead " +
      "received: %s",
      callback);

      callback.call(context);
    }

    function resetHasForceUpdateBeforeProcessing() {
      hasForceUpdate = false;
    }

    function checkHasForceUpdateAfterProcessing() {
      return hasForceUpdate;
    }

    function commitUpdateQueue(
    finishedWork,
    finishedQueue,
    instance,
    renderExpirationTime)
    {




      if (finishedQueue.firstCapturedUpdate !== null) {

        if (finishedQueue.lastUpdate !== null) {
          finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
          finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
        }

        finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
      }


      commitUpdateEffects(finishedQueue.firstEffect, instance);
      finishedQueue.firstEffect = finishedQueue.lastEffect = null;

      commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
      finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
    }

    function commitUpdateEffects(effect, instance) {
      while (effect !== null) {
        var _callback3 = effect.callback;
        if (_callback3 !== null) {
          effect.callback = null;
          callCallback(_callback3, instance);
        }
        effect = effect.nextEffect;
      }
    }

    function createCapturedValue(value, source) {


      return {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source) };

    }








    var warning = warningWithoutStack$1;

    {
      warning = function warning(condition, format) {
        if (condition) {
          return;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();


        for (
        var _len = arguments.length,
        args = Array(_len > 2 ? _len - 2 : 0),
        _key = 2;
        _key < _len;
        _key++)
        {
          args[_key - 2] = arguments[_key];
        }

        warningWithoutStack$1.apply(
        undefined,
        [false, format + "%s"].concat(args, [stack]));

      };
    }

    var warning$1 = warning;

    var valueCursor = createCursor(null);

    var rendererSigil = void 0;
    {

      rendererSigil = {};
    }

    var currentlyRenderingFiber = null;
    var lastContextDependency = null;
    var lastContextWithAllBitsObserved = null;

    function resetContextDependences() {


      currentlyRenderingFiber = null;
      lastContextDependency = null;
      lastContextWithAllBitsObserved = null;
    }

    function pushProvider(providerFiber, nextValue) {
      var context = providerFiber.type._context;

      if (isPrimaryRenderer) {
        push(valueCursor, context._currentValue, providerFiber);

        context._currentValue = nextValue;
        {
          !(
          context._currentRenderer === undefined ||
          context._currentRenderer === null ||
          context._currentRenderer === rendererSigil) ?

          warningWithoutStack$1(
          false,
          "Detected multiple renderers concurrently rendering the " +
          "same context provider. This is currently unsupported.") :

          void 0;
          context._currentRenderer = rendererSigil;
        }
      } else {
        push(valueCursor, context._currentValue2, providerFiber);

        context._currentValue2 = nextValue;
        {
          !(
          context._currentRenderer2 === undefined ||
          context._currentRenderer2 === null ||
          context._currentRenderer2 === rendererSigil) ?

          warningWithoutStack$1(
          false,
          "Detected multiple renderers concurrently rendering the " +
          "same context provider. This is currently unsupported.") :

          void 0;
          context._currentRenderer2 = rendererSigil;
        }
      }
    }

    function popProvider(providerFiber) {
      var currentValue = valueCursor.current;

      pop(valueCursor, providerFiber);

      var context = providerFiber.type._context;
      if (isPrimaryRenderer) {
        context._currentValue = currentValue;
      } else {
        context._currentValue2 = currentValue;
      }
    }

    function calculateChangedBits(context, newValue, oldValue) {



      if (
      oldValue === newValue && (
      oldValue !== 0 || 1 / oldValue === 1 / newValue) ||
      oldValue !== oldValue && newValue !== newValue)
        {

          return 0;
        } else {
        var changedBits =
        typeof context._calculateChangedBits === "function" ?
        context._calculateChangedBits(oldValue, newValue) :
        maxSigned31BitInt;

        {
          !((changedBits & maxSigned31BitInt) === changedBits) ?
          warning$1(
          false,
          "calculateChangedBits: Expected the return value to be a " +
          "31-bit integer. Instead received: %s",
          changedBits) :

          void 0;
        }
        return changedBits | 0;
      }
    }

    function propagateContextChange(
    workInProgress,
    context,
    changedBits,
    renderExpirationTime)
    {
      var fiber = workInProgress.child;
      if (fiber !== null) {

        fiber.return = workInProgress;
      }
      while (fiber !== null) {
        var nextFiber = void 0;


        var dependency = fiber.firstContextDependency;
        if (dependency !== null) {
          do {

            if (
            dependency.context === context &&
            (dependency.observedBits & changedBits) !== 0)
            {


              if (
              fiber.tag === ClassComponent ||
              fiber.tag === ClassComponentLazy)
              {

                var update = createUpdate(renderExpirationTime);
                update.tag = ForceUpdate;




                enqueueUpdate(fiber, update);
              }

              if (
              fiber.expirationTime === NoWork ||
              fiber.expirationTime > renderExpirationTime)
              {
                fiber.expirationTime = renderExpirationTime;
              }
              var alternate = fiber.alternate;
              if (
              alternate !== null && (
              alternate.expirationTime === NoWork ||
              alternate.expirationTime > renderExpirationTime))
              {
                alternate.expirationTime = renderExpirationTime;
              }


              var node = fiber.return;
              while (node !== null) {
                alternate = node.alternate;
                if (
                node.childExpirationTime === NoWork ||
                node.childExpirationTime > renderExpirationTime)
                {
                  node.childExpirationTime = renderExpirationTime;
                  if (
                  alternate !== null && (
                  alternate.childExpirationTime === NoWork ||
                  alternate.childExpirationTime > renderExpirationTime))
                  {
                    alternate.childExpirationTime = renderExpirationTime;
                  }
                } else if (
                alternate !== null && (
                alternate.childExpirationTime === NoWork ||
                alternate.childExpirationTime > renderExpirationTime))
                {
                  alternate.childExpirationTime = renderExpirationTime;
                } else {


                  break;
                }
                node = node.return;
              }
            }
            nextFiber = fiber.child;
            dependency = dependency.next;
          } while (dependency !== null);
        } else if (fiber.tag === ContextProvider) {

          nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
        } else {

          nextFiber = fiber.child;
        }

        if (nextFiber !== null) {

          nextFiber.return = fiber;
        } else {

          nextFiber = fiber;
          while (nextFiber !== null) {
            if (nextFiber === workInProgress) {

              nextFiber = null;
              break;
            }
            var sibling = nextFiber.sibling;
            if (sibling !== null) {

              sibling.return = nextFiber.return;
              nextFiber = sibling;
              break;
            }

            nextFiber = nextFiber.return;
          }
        }
        fiber = nextFiber;
      }
    }

    function prepareToReadContext(workInProgress, renderExpirationTime) {
      currentlyRenderingFiber = workInProgress;
      lastContextDependency = null;
      lastContextWithAllBitsObserved = null;


      workInProgress.firstContextDependency = null;
    }

    function readContext(context, observedBits) {
      if (lastContextWithAllBitsObserved === context) {

      } else if (observedBits === false || observedBits === 0) {

      } else {
        var resolvedObservedBits = void 0;
        if (
        typeof observedBits !== "number" ||
        observedBits === maxSigned31BitInt)
        {

          lastContextWithAllBitsObserved = context;
          resolvedObservedBits = maxSigned31BitInt;
        } else {
          resolvedObservedBits = observedBits;
        }

        var contextItem = {
          context: context,
          observedBits: resolvedObservedBits,
          next: null };


        if (lastContextDependency === null) {
          invariant(
          currentlyRenderingFiber !== null,
          "Context.unstable_read(): Context can only be read while React is " +
          "rendering, e.g. inside the render method or getDerivedStateFromProps.");


          currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
        } else {

          lastContextDependency = lastContextDependency.next = contextItem;
        }
      }
      return isPrimaryRenderer ? context._currentValue : context._currentValue2;
    }

    var NO_CONTEXT = {};

    var contextStackCursor$1 = createCursor(NO_CONTEXT);
    var contextFiberStackCursor = createCursor(NO_CONTEXT);
    var rootInstanceStackCursor = createCursor(NO_CONTEXT);

    function requiredContext(c) {
      invariant(
      c !== NO_CONTEXT,
      "Expected host context to exist. This error is likely caused by a bug " +
      "in React. Please file an issue.");

      return c;
    }

    function getRootHostContainer() {
      var rootInstance = requiredContext(rootInstanceStackCursor.current);
      return rootInstance;
    }

    function pushHostContainer(fiber, nextRootInstance) {


      push(rootInstanceStackCursor, nextRootInstance, fiber);


      push(contextFiberStackCursor, fiber, fiber);






      push(contextStackCursor$1, NO_CONTEXT, fiber);
      var nextRootContext = getRootHostContext(nextRootInstance);

      pop(contextStackCursor$1, fiber);
      push(contextStackCursor$1, nextRootContext, fiber);
    }

    function popHostContainer(fiber) {
      pop(contextStackCursor$1, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }

    function getHostContext() {
      var context = requiredContext(contextStackCursor$1.current);
      return context;
    }

    function pushHostContext(fiber) {
      var rootInstance = requiredContext(rootInstanceStackCursor.current);
      var context = requiredContext(contextStackCursor$1.current);
      var nextContext = getChildHostContext(context, fiber.type, rootInstance);


      if (context === nextContext) {
        return;
      }



      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor$1, nextContext, fiber);
    }

    function popHostContext(fiber) {


      if (contextFiberStackCursor.current !== fiber) {
        return;
      }

      pop(contextStackCursor$1, fiber);
      pop(contextFiberStackCursor, fiber);
    }

    var commitTime = 0;
    var profilerStartTime = -1;

    function getCommitTime() {
      return commitTime;
    }

    function recordCommitTime() {
      if (!enableProfilerTimer) {
        return;
      }
      commitTime = now();
    }

    function startProfilerTimer(fiber) {
      if (!enableProfilerTimer) {
        return;
      }

      profilerStartTime = now();

      if (fiber.actualStartTime < 0) {
        fiber.actualStartTime = now();
      }
    }

    function stopProfilerTimerIfRunning(fiber) {
      if (!enableProfilerTimer) {
        return;
      }
      profilerStartTime = -1;
    }

    function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
      if (!enableProfilerTimer) {
        return;
      }

      if (profilerStartTime >= 0) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        if (overrideBaseTime) {
          fiber.selfBaseDuration = elapsedTime;
        }
        profilerStartTime = -1;
      }
    }



    var hasOwnProperty = Object.prototype.hasOwnProperty;





    function is(x, y) {

      if (x === y) {



        return x !== 0 || y !== 0 || 1 / x === 1 / y;
      } else {

        return x !== x && y !== y;
      }
    }






    function shallowEqual(objA, objB) {
      if (is(objA, objB)) {
        return true;
      }

      if (
      typeof objA !== "object" ||
      objA === null ||
      typeof objB !== "object" ||
      objB === null)
      {
        return false;
      }

      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);

      if (keysA.length !== keysB.length) {
        return false;
      }


      for (var i = 0; i < keysA.length; i++) {
        if (
        !hasOwnProperty.call(objB, keysA[i]) ||
        !is(objA[keysA[i]], objB[keysA[i]]))
        {
          return false;
        }
      }

      return true;
    }

    var fakeInternalInstance = {};
    var isArray = Array.isArray;



    var emptyRefsObject = new React.Component().refs;

    var didWarnAboutStateAssignmentForComponent = void 0;
    var didWarnAboutUninitializedState = void 0;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
    var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
    var didWarnAboutUndefinedDerivedState = void 0;
    var warnOnUndefinedDerivedState = void 0;
    var warnOnInvalidCallback = void 0;
    var didWarnAboutDirectlyAssigningPropsToState = void 0;

    {
      didWarnAboutStateAssignmentForComponent = new Set();
      didWarnAboutUninitializedState = new Set();
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
      didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
      didWarnAboutDirectlyAssigningPropsToState = new Set();
      didWarnAboutUndefinedDerivedState = new Set();

      var didWarnOnInvalidCallback = new Set();

      warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
        if (callback === null || typeof callback === "function") {
          return;
        }
        var key = callerName + "_" + callback;
        if (!didWarnOnInvalidCallback.has(key)) {
          didWarnOnInvalidCallback.add(key);
          warningWithoutStack$1(
          false,
          "%s(...): Expected the last optional `callback` argument to be a " +
          "function. Instead received: %s.",
          callerName,
          callback);

        }
      };

      warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {
        if (partialState === undefined) {
          var componentName = getComponentName(type) || "Component";
          if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
            didWarnAboutUndefinedDerivedState.add(componentName);
            warningWithoutStack$1(
            false,
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " +
            "You have returned undefined.",
            componentName);

          }
        }
      };






      Object.defineProperty(fakeInternalInstance, "_processChildContext", {
        enumerable: false,
        value: function value() {
          invariant(
          false,
          "_processChildContext is not available in React 16+. This likely " +
          "means you have multiple copies of React and are attempting to nest " +
          "a React 15 tree inside a React 16 tree using " +
          "unstable_renderSubtreeIntoContainer, which isn't supported. Try " +
          "to make sure you have only one copy of React (and ideally, switch " +
          "to ReactDOM.createPortal).");

        } });

      Object.freeze(fakeInternalInstance);
    }

    function applyDerivedStateFromProps(
    workInProgress,
    ctor,
    getDerivedStateFromProps,
    nextProps)
    {
      var prevState = workInProgress.memoizedState;

      {
        if (
        debugRenderPhaseSideEffects ||
        debugRenderPhaseSideEffectsForStrictMode &&
        workInProgress.mode & StrictMode)
        {

          getDerivedStateFromProps(nextProps, prevState);
        }
      }

      var partialState = getDerivedStateFromProps(nextProps, prevState);

      {
        warnOnUndefinedDerivedState(ctor, partialState);
      }

      var memoizedState =
      partialState === null || partialState === undefined ?
      prevState :
      _extends({}, prevState, partialState);
      workInProgress.memoizedState = memoizedState;



      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
        updateQueue.baseState = memoizedState;
      }
    }

    var classComponentUpdater = {
      isMounted: isMounted,
      enqueueSetState: function enqueueSetState(inst, payload, callback) {
        var fiber = get$1(inst);
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, fiber);

        var update = createUpdate(expirationTime);
        update.payload = payload;
        if (callback !== undefined && callback !== null) {
          {
            warnOnInvalidCallback(callback, "setState");
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      },
      enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
        var fiber = get$1(inst);
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, fiber);

        var update = createUpdate(expirationTime);
        update.tag = ReplaceState;
        update.payload = payload;

        if (callback !== undefined && callback !== null) {
          {
            warnOnInvalidCallback(callback, "replaceState");
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      },
      enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
        var fiber = get$1(inst);
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, fiber);

        var update = createUpdate(expirationTime);
        update.tag = ForceUpdate;

        if (callback !== undefined && callback !== null) {
          {
            warnOnInvalidCallback(callback, "forceUpdate");
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      } };


    function checkShouldComponentUpdate(
    workInProgress,
    ctor,
    oldProps,
    newProps,
    oldState,
    newState,
    nextLegacyContext)
    {
      var instance = workInProgress.stateNode;
      if (typeof instance.shouldComponentUpdate === "function") {
        startPhaseTimer(workInProgress, "shouldComponentUpdate");
        var shouldUpdate = instance.shouldComponentUpdate(
        newProps,
        newState,
        nextLegacyContext);

        stopPhaseTimer();

        {
          !(shouldUpdate !== undefined) ?
          warningWithoutStack$1(
          false,
          "%s.shouldComponentUpdate(): Returned undefined instead of a " +
          "boolean value. Make sure to return true or false.",
          getComponentName(ctor) || "Component") :

          void 0;
        }

        return shouldUpdate;
      }

      if (ctor.prototype && ctor.prototype.isPureReactComponent) {
        return (
          !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState));

      }

      return true;
    }

    function checkClassInstance(workInProgress, ctor, newProps) {
      var instance = workInProgress.stateNode;
      {
        var name = getComponentName(ctor) || "Component";
        var renderPresent = instance.render;

        if (!renderPresent) {
          if (ctor.prototype && typeof ctor.prototype.render === "function") {
            warningWithoutStack$1(
            false,
            "%s(...): No `render` method found on the returned component " +
            "instance: did you accidentally return an object from the constructor?",
            name);

          } else {
            warningWithoutStack$1(
            false,
            "%s(...): No `render` method found on the returned component " +
            "instance: you may have forgotten to define `render`.",
            name);

          }
        }

        var noGetInitialStateOnES6 =
        !instance.getInitialState ||
        instance.getInitialState.isReactClassApproved ||
        instance.state;
        !noGetInitialStateOnES6 ?
        warningWithoutStack$1(
        false,
        "getInitialState was defined on %s, a plain JavaScript class. " +
        "This is only supported for classes created using React.createClass. " +
        "Did you mean to define a state property instead?",
        name) :

        void 0;
        var noGetDefaultPropsOnES6 =
        !instance.getDefaultProps ||
        instance.getDefaultProps.isReactClassApproved;
        !noGetDefaultPropsOnES6 ?
        warningWithoutStack$1(
        false,
        "getDefaultProps was defined on %s, a plain JavaScript class. " +
        "This is only supported for classes created using React.createClass. " +
        "Use a static property to define defaultProps instead.",
        name) :

        void 0;
        var noInstancePropTypes = !instance.propTypes;
        !noInstancePropTypes ?
        warningWithoutStack$1(
        false,
        "propTypes was defined as an instance property on %s. Use a static " +
        "property to define propTypes instead.",
        name) :

        void 0;
        var noInstanceContextTypes = !instance.contextTypes;
        !noInstanceContextTypes ?
        warningWithoutStack$1(
        false,
        "contextTypes was defined as an instance property on %s. Use a static " +
        "property to define contextTypes instead.",
        name) :

        void 0;
        var noComponentShouldUpdate =
        typeof instance.componentShouldUpdate !== "function";
        !noComponentShouldUpdate ?
        warningWithoutStack$1(
        false,
        "%s has a method called " +
        "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " +
        "The name is phrased as a question because the function is " +
        "expected to return a value.",
        name) :

        void 0;
        if (
        ctor.prototype &&
        ctor.prototype.isPureReactComponent &&
        typeof instance.shouldComponentUpdate !== "undefined")
        {
          warningWithoutStack$1(
          false,
          "%s has a method called shouldComponentUpdate(). " +
          "shouldComponentUpdate should not be used when extending React.PureComponent. " +
          "Please extend React.Component if shouldComponentUpdate is used.",
          getComponentName(ctor) || "A pure component");

        }
        var noComponentDidUnmount =
        typeof instance.componentDidUnmount !== "function";
        !noComponentDidUnmount ?
        warningWithoutStack$1(
        false,
        "%s has a method called " +
        "componentDidUnmount(). But there is no such lifecycle method. " +
        "Did you mean componentWillUnmount()?",
        name) :

        void 0;
        var noComponentDidReceiveProps =
        typeof instance.componentDidReceiveProps !== "function";
        !noComponentDidReceiveProps ?
        warningWithoutStack$1(
        false,
        "%s has a method called " +
        "componentDidReceiveProps(). But there is no such lifecycle method. " +
        "If you meant to update the state in response to changing props, " +
        "use componentWillReceiveProps(). If you meant to fetch data or " +
        "run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
        name) :

        void 0;
        var noComponentWillRecieveProps =
        typeof instance.componentWillRecieveProps !== "function";
        !noComponentWillRecieveProps ?
        warningWithoutStack$1(
        false,
        "%s has a method called " +
        "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
        name) :

        void 0;
        var noUnsafeComponentWillRecieveProps =
        typeof instance.UNSAFE_componentWillRecieveProps !== "function";
        !noUnsafeComponentWillRecieveProps ?
        warningWithoutStack$1(
        false,
        "%s has a method called " +
        "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
        name) :

        void 0;
        var hasMutatedProps = instance.props !== newProps;
        !(instance.props === undefined || !hasMutatedProps) ?
        warningWithoutStack$1(
        false,
        "%s(...): When calling super() in `%s`, make sure to pass " +
        "up the same props that your component's constructor was passed.",
        name,
        name) :

        void 0;
        var noInstanceDefaultProps = !instance.defaultProps;
        !noInstanceDefaultProps ?
        warningWithoutStack$1(
        false,
        "Setting defaultProps as an instance property on %s is not supported and will be ignored." +
        " Instead, define defaultProps as a static property on %s.",
        name,
        name) :

        void 0;

        if (
        typeof instance.getSnapshotBeforeUpdate === "function" &&
        typeof instance.componentDidUpdate !== "function" &&
        !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor))
        {
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
          warningWithoutStack$1(
          false,
          "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " +
          "This component defines getSnapshotBeforeUpdate() only.",
          getComponentName(ctor));

        }

        var noInstanceGetDerivedStateFromProps =
        typeof instance.getDerivedStateFromProps !== "function";
        !noInstanceGetDerivedStateFromProps ?
        warningWithoutStack$1(
        false,
        "%s: getDerivedStateFromProps() is defined as an instance method " +
        "and will be ignored. Instead, declare it as a static method.",
        name) :

        void 0;
        var noInstanceGetDerivedStateFromCatch =
        typeof instance.getDerivedStateFromCatch !== "function";
        !noInstanceGetDerivedStateFromCatch ?
        warningWithoutStack$1(
        false,
        "%s: getDerivedStateFromCatch() is defined as an instance method " +
        "and will be ignored. Instead, declare it as a static method.",
        name) :

        void 0;
        var noStaticGetSnapshotBeforeUpdate =
        typeof ctor.getSnapshotBeforeUpdate !== "function";
        !noStaticGetSnapshotBeforeUpdate ?
        warningWithoutStack$1(
        false,
        "%s: getSnapshotBeforeUpdate() is defined as a static method " +
        "and will be ignored. Instead, declare it as an instance method.",
        name) :

        void 0;
        var _state = instance.state;
        if (_state && (typeof _state !== "object" || isArray(_state))) {
          warningWithoutStack$1(
          false,
          "%s.state: must be set to an object or null",
          name);

        }
        if (typeof instance.getChildContext === "function") {
          !(typeof ctor.childContextTypes === "object") ?
          warningWithoutStack$1(
          false,
          "%s.getChildContext(): childContextTypes must be defined in order to " +
          "use getChildContext().",
          name) :

          void 0;
        }
      }
    }

    function adoptClassInstance(workInProgress, instance) {
      instance.updater = classComponentUpdater;
      workInProgress.stateNode = instance;

      set(instance, workInProgress);
      {
        instance._reactInternalInstance = fakeInternalInstance;
      }
    }

    function constructClassInstance(
    workInProgress,
    ctor,
    props,
    renderExpirationTime)
    {
      var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
      var contextTypes = ctor.contextTypes;
      var isContextConsumer = contextTypes !== null && contextTypes !== undefined;
      var context = isContextConsumer ?
      getMaskedContext(workInProgress, unmaskedContext) :
      emptyContextObject;


      {
        if (
        debugRenderPhaseSideEffects ||
        debugRenderPhaseSideEffectsForStrictMode &&
        workInProgress.mode & StrictMode)
        {
          new ctor(props, context);
        }
      }

      var instance = new ctor(props, context);
      var state = workInProgress.memoizedState =
      instance.state !== null && instance.state !== undefined ?
      instance.state :
      null;
      adoptClassInstance(workInProgress, instance);

      {
        if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
          var componentName = getComponentName(ctor) || "Component";
          if (!didWarnAboutUninitializedState.has(componentName)) {
            didWarnAboutUninitializedState.add(componentName);
            warningWithoutStack$1(
            false,
            "`%s` uses `getDerivedStateFromProps` but its initial state is " +
            "%s. This is not recommended. Instead, define the initial state by " +
            "assigning an object to `this.state` in the constructor of `%s`. " +
            "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
            componentName,
            instance.state === null ? "null" : "undefined",
            componentName);

          }
        }




        if (
        typeof ctor.getDerivedStateFromProps === "function" ||
        typeof instance.getSnapshotBeforeUpdate === "function")
        {
          var foundWillMountName = null;
          var foundWillReceivePropsName = null;
          var foundWillUpdateName = null;
          if (
          typeof instance.componentWillMount === "function" &&
          instance.componentWillMount.__suppressDeprecationWarning !== true)
          {
            foundWillMountName = "componentWillMount";
          } else if (typeof instance.UNSAFE_componentWillMount === "function") {
            foundWillMountName = "UNSAFE_componentWillMount";
          }
          if (
          typeof instance.componentWillReceiveProps === "function" &&
          instance.componentWillReceiveProps.__suppressDeprecationWarning !== true)
          {
            foundWillReceivePropsName = "componentWillReceiveProps";
          } else if (
          typeof instance.UNSAFE_componentWillReceiveProps === "function")
          {
            foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
          }
          if (
          typeof instance.componentWillUpdate === "function" &&
          instance.componentWillUpdate.__suppressDeprecationWarning !== true)
          {
            foundWillUpdateName = "componentWillUpdate";
          } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
            foundWillUpdateName = "UNSAFE_componentWillUpdate";
          }
          if (
          foundWillMountName !== null ||
          foundWillReceivePropsName !== null ||
          foundWillUpdateName !== null)
          {
            var _componentName = getComponentName(ctor) || "Component";
            var newApiName =
            typeof ctor.getDerivedStateFromProps === "function" ?
            "getDerivedStateFromProps()" :
            "getSnapshotBeforeUpdate()";
            if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
              didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
              warningWithoutStack$1(
              false,
              "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
              "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" +
              "The above lifecycles should be removed. Learn more about this warning here:\n" +
              "https://fb.me/react-async-component-lifecycle-hooks",
              _componentName,
              newApiName,
              foundWillMountName !== null ? "\n  " + foundWillMountName : "",
              foundWillReceivePropsName !== null ?
              "\n  " + foundWillReceivePropsName :
              "",
              foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");

            }
          }
        }
      }



      if (isContextConsumer) {
        cacheContext(workInProgress, unmaskedContext, context);
      }

      return instance;
    }

    function callComponentWillMount(workInProgress, instance) {
      startPhaseTimer(workInProgress, "componentWillMount");
      var oldState = instance.state;

      if (typeof instance.componentWillMount === "function") {
        instance.componentWillMount();
      }
      if (typeof instance.UNSAFE_componentWillMount === "function") {
        instance.UNSAFE_componentWillMount();
      }

      stopPhaseTimer();

      if (oldState !== instance.state) {
        {
          warningWithoutStack$1(
          false,
          "%s.componentWillMount(): Assigning directly to this.state is " +
          "deprecated (except inside a component's " +
          "constructor). Use setState instead.",
          getComponentName(workInProgress.type) || "Component");

        }
        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
    }

    function callComponentWillReceiveProps(
    workInProgress,
    instance,
    newProps,
    nextLegacyContext)
    {
      var oldState = instance.state;
      startPhaseTimer(workInProgress, "componentWillReceiveProps");
      if (typeof instance.componentWillReceiveProps === "function") {
        instance.componentWillReceiveProps(newProps, nextLegacyContext);
      }
      if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
        instance.UNSAFE_componentWillReceiveProps(newProps, nextLegacyContext);
      }
      stopPhaseTimer();

      if (instance.state !== oldState) {
        {
          var componentName = getComponentName(workInProgress.type) || "Component";
          if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
            didWarnAboutStateAssignmentForComponent.add(componentName);
            warningWithoutStack$1(
            false,
            "%s.componentWillReceiveProps(): Assigning directly to " +
            "this.state is deprecated (except inside a component's " +
            "constructor). Use setState instead.",
            componentName);

          }
        }
        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
    }


    function mountClassInstance(
    workInProgress,
    ctor,
    newProps,
    renderExpirationTime)
    {
      {
        checkClassInstance(workInProgress, ctor, newProps);
      }

      var instance = workInProgress.stateNode;
      var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);

      instance.props = newProps;
      instance.state = workInProgress.memoizedState;
      instance.refs = emptyRefsObject;
      instance.context = getMaskedContext(workInProgress, unmaskedContext);

      {
        if (instance.state === newProps) {
          var componentName = getComponentName(ctor) || "Component";
          if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
            didWarnAboutDirectlyAssigningPropsToState.add(componentName);
            warningWithoutStack$1(
            false,
            "%s: It is not recommended to assign props directly to state " +
            "because updates to props won't be reflected in state. " +
            "In most cases, it is better to use props directly.",
            componentName);

          }
        }

        if (workInProgress.mode & StrictMode) {
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
          workInProgress,
          instance);


          ReactStrictModeWarnings.recordLegacyContextWarning(
          workInProgress,
          instance);

        }

        if (warnAboutDeprecatedLifecycles) {
          ReactStrictModeWarnings.recordDeprecationWarnings(
          workInProgress,
          instance);

        }
      }

      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        processUpdateQueue(
        workInProgress,
        updateQueue,
        newProps,
        instance,
        renderExpirationTime);

        instance.state = workInProgress.memoizedState;
      }

      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      if (typeof getDerivedStateFromProps === "function") {
        applyDerivedStateFromProps(
        workInProgress,
        ctor,
        getDerivedStateFromProps,
        newProps);

        instance.state = workInProgress.memoizedState;
      }



      if (
      typeof ctor.getDerivedStateFromProps !== "function" &&
      typeof instance.getSnapshotBeforeUpdate !== "function" && (
      typeof instance.UNSAFE_componentWillMount === "function" ||
      typeof instance.componentWillMount === "function"))
      {
        callComponentWillMount(workInProgress, instance);


        updateQueue = workInProgress.updateQueue;
        if (updateQueue !== null) {
          processUpdateQueue(
          workInProgress,
          updateQueue,
          newProps,
          instance,
          renderExpirationTime);

          instance.state = workInProgress.memoizedState;
        }
      }

      if (typeof instance.componentDidMount === "function") {
        workInProgress.effectTag |= Update;
      }
    }

    function resumeMountClassInstance(
    workInProgress,
    ctor,
    newProps,
    renderExpirationTime)
    {
      var instance = workInProgress.stateNode;

      var oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;

      var oldContext = instance.context;
      var nextLegacyUnmaskedContext = getUnmaskedContext(
      workInProgress,
      ctor,
      true);

      var nextLegacyContext = getMaskedContext(
      workInProgress,
      nextLegacyUnmaskedContext);


      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      var hasNewLifecycles =
      typeof getDerivedStateFromProps === "function" ||
      typeof instance.getSnapshotBeforeUpdate === "function";







      if (
      !hasNewLifecycles && (
      typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
      typeof instance.componentWillReceiveProps === "function"))
      {
        if (oldProps !== newProps || oldContext !== nextLegacyContext) {
          callComponentWillReceiveProps(
          workInProgress,
          instance,
          newProps,
          nextLegacyContext);

        }
      }

      resetHasForceUpdateBeforeProcessing();

      var oldState = workInProgress.memoizedState;
      var newState = instance.state = oldState;
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        processUpdateQueue(
        workInProgress,
        updateQueue,
        newProps,
        instance,
        renderExpirationTime);

        newState = workInProgress.memoizedState;
      }
      if (
      oldProps === newProps &&
      oldState === newState &&
      !hasContextChanged() &&
      !checkHasForceUpdateAfterProcessing())
      {


        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }
        return false;
      }

      if (typeof getDerivedStateFromProps === "function") {
        applyDerivedStateFromProps(
        workInProgress,
        ctor,
        getDerivedStateFromProps,
        newProps);

        newState = workInProgress.memoizedState;
      }

      var shouldUpdate =
      checkHasForceUpdateAfterProcessing() ||
      checkShouldComponentUpdate(
      workInProgress,
      ctor,
      oldProps,
      newProps,
      oldState,
      newState,
      nextLegacyContext);


      if (shouldUpdate) {


        if (
        !hasNewLifecycles && (
        typeof instance.UNSAFE_componentWillMount === "function" ||
        typeof instance.componentWillMount === "function"))
        {
          startPhaseTimer(workInProgress, "componentWillMount");
          if (typeof instance.componentWillMount === "function") {
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          stopPhaseTimer();
        }
        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }
      } else {


        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }



        workInProgress.memoizedProps = newProps;
        workInProgress.memoizedState = newState;
      }



      instance.props = newProps;
      instance.state = newState;
      instance.context = nextLegacyContext;

      return shouldUpdate;
    }


    function updateClassInstance(
    current,
    workInProgress,
    ctor,
    newProps,
    renderExpirationTime)
    {
      var instance = workInProgress.stateNode;

      var oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;

      var oldContext = instance.context;
      var nextLegacyUnmaskedContext = getUnmaskedContext(
      workInProgress,
      ctor,
      true);

      var nextLegacyContext = getMaskedContext(
      workInProgress,
      nextLegacyUnmaskedContext);


      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      var hasNewLifecycles =
      typeof getDerivedStateFromProps === "function" ||
      typeof instance.getSnapshotBeforeUpdate === "function";







      if (
      !hasNewLifecycles && (
      typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
      typeof instance.componentWillReceiveProps === "function"))
      {
        if (oldProps !== newProps || oldContext !== nextLegacyContext) {
          callComponentWillReceiveProps(
          workInProgress,
          instance,
          newProps,
          nextLegacyContext);

        }
      }

      resetHasForceUpdateBeforeProcessing();

      var oldState = workInProgress.memoizedState;
      var newState = instance.state = oldState;
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        processUpdateQueue(
        workInProgress,
        updateQueue,
        newProps,
        instance,
        renderExpirationTime);

        newState = workInProgress.memoizedState;
      }

      if (
      oldProps === newProps &&
      oldState === newState &&
      !hasContextChanged() &&
      !checkHasForceUpdateAfterProcessing())
      {


        if (typeof instance.componentDidUpdate === "function") {
          if (
          oldProps !== current.memoizedProps ||
          oldState !== current.memoizedState)
          {
            workInProgress.effectTag |= Update;
          }
        }
        if (typeof instance.getSnapshotBeforeUpdate === "function") {
          if (
          oldProps !== current.memoizedProps ||
          oldState !== current.memoizedState)
          {
            workInProgress.effectTag |= Snapshot;
          }
        }
        return false;
      }

      if (typeof getDerivedStateFromProps === "function") {
        applyDerivedStateFromProps(
        workInProgress,
        ctor,
        getDerivedStateFromProps,
        newProps);

        newState = workInProgress.memoizedState;
      }

      var shouldUpdate =
      checkHasForceUpdateAfterProcessing() ||
      checkShouldComponentUpdate(
      workInProgress,
      ctor,
      oldProps,
      newProps,
      oldState,
      newState,
      nextLegacyContext);


      if (shouldUpdate) {


        if (
        !hasNewLifecycles && (
        typeof instance.UNSAFE_componentWillUpdate === "function" ||
        typeof instance.componentWillUpdate === "function"))
        {
          startPhaseTimer(workInProgress, "componentWillUpdate");
          if (typeof instance.componentWillUpdate === "function") {
            instance.componentWillUpdate(newProps, newState, nextLegacyContext);
          }
          if (typeof instance.UNSAFE_componentWillUpdate === "function") {
            instance.UNSAFE_componentWillUpdate(
            newProps,
            newState,
            nextLegacyContext);

          }
          stopPhaseTimer();
        }
        if (typeof instance.componentDidUpdate === "function") {
          workInProgress.effectTag |= Update;
        }
        if (typeof instance.getSnapshotBeforeUpdate === "function") {
          workInProgress.effectTag |= Snapshot;
        }
      } else {


        if (typeof instance.componentDidUpdate === "function") {
          if (
          oldProps !== current.memoizedProps ||
          oldState !== current.memoizedState)
          {
            workInProgress.effectTag |= Update;
          }
        }
        if (typeof instance.getSnapshotBeforeUpdate === "function") {
          if (
          oldProps !== current.memoizedProps ||
          oldState !== current.memoizedState)
          {
            workInProgress.effectTag |= Snapshot;
          }
        }



        workInProgress.memoizedProps = newProps;
        workInProgress.memoizedState = newState;
      }



      instance.props = newProps;
      instance.state = newState;
      instance.context = nextLegacyContext;

      return shouldUpdate;
    }

    var didWarnAboutMaps = void 0;
    var didWarnAboutGenerators = void 0;
    var didWarnAboutStringRefInStrictMode = void 0;
    var ownerHasKeyUseWarning = void 0;
    var ownerHasFunctionTypeWarning = void 0;
    var warnForMissingKey = function warnForMissingKey(child) {};

    {
      didWarnAboutMaps = false;
      didWarnAboutGenerators = false;
      didWarnAboutStringRefInStrictMode = {};






      ownerHasKeyUseWarning = {};
      ownerHasFunctionTypeWarning = {};

      warnForMissingKey = function warnForMissingKey(child) {
        if (child === null || typeof child !== "object") {
          return;
        }
        if (!child._store || child._store.validated || child.key != null) {
          return;
        }
        invariant(
        typeof child._store === "object",
        "React Component in warnForMissingKey should have a _store. " +
        "This error is likely caused by a bug in React. Please file an issue.");

        child._store.validated = true;

        var currentComponentErrorInfo =
        "Each child in an array or iterator should have a unique " +
        '"key" prop. See https://fb.me/react-warning-keys for ' +
        "more information." +
        getCurrentFiberStackInDev();
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

        warning$1(
        false,
        "Each child in an array or iterator should have a unique " +
        '"key" prop. See https://fb.me/react-warning-keys for ' +
        "more information.");

      };
    }

    var isArray$1 = Array.isArray;

    function coerceRef(returnFiber, current$$1, element) {
      var mixedRef = element.ref;
      if (
      mixedRef !== null &&
      typeof mixedRef !== "function" &&
      typeof mixedRef !== "object")
      {
        {
          if (returnFiber.mode & StrictMode) {
            var componentName = getComponentName(returnFiber.type) || "Component";
            if (!didWarnAboutStringRefInStrictMode[componentName]) {
              warningWithoutStack$1(
              false,
              'A string ref, "%s", has been found within a strict mode tree. ' +
              "String refs are a source of potential bugs and should be avoided. " +
              "We recommend using createRef() instead." +
              "\n%s" +
              "\n\nLearn more about using refs safely here:" +
              "\nhttps://fb.me/react-strict-mode-string-ref",
              mixedRef,
              getStackByFiberInDevAndProd(returnFiber));

              didWarnAboutStringRefInStrictMode[componentName] = true;
            }
          }
        }

        if (element._owner) {
          var owner = element._owner;
          var inst = void 0;
          if (owner) {
            var ownerFiber = owner;
            invariant(
            ownerFiber.tag === ClassComponent ||
            ownerFiber.tag === ClassComponentLazy,
            "Stateless function components cannot have refs.");

            inst = ownerFiber.stateNode;
          }
          invariant(
          inst,
          "Missing owner for string ref %s. This error is likely caused by a " +
          "bug in React. Please file an issue.",
          mixedRef);

          var stringRef = "" + mixedRef;

          if (
          current$$1 !== null &&
          current$$1.ref !== null &&
          typeof current$$1.ref === "function" &&
          current$$1.ref._stringRef === stringRef)
          {
            return current$$1.ref;
          }
          var ref = function ref(value) {
            var refs = inst.refs;
            if (refs === emptyRefsObject) {

              refs = inst.refs = {};
            }
            if (value === null) {
              delete refs[stringRef];
            } else {
              refs[stringRef] = value;
            }
          };
          ref._stringRef = stringRef;
          return ref;
        } else {
          invariant(
          typeof mixedRef === "string",
          "Expected ref to be a function, a string, an object returned by React.createRef(), or null.");

          invariant(
          element._owner,
          "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" +
          " the following reasons:\n" +
          "1. You may be adding a ref to a functional component\n" +
          "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
          "3. You have multiple copies of React loaded\n" +
          "See https://fb.me/react-refs-must-have-owner for more information.",
          mixedRef);

        }
      }
      return mixedRef;
    }

    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (returnFiber.type !== "textarea") {
        var addendum = "";
        {
          addendum =
          " If you meant to render a collection of children, use an array " +
          "instead." +
          getCurrentFiberStackInDev();
        }
        invariant(
        false,
        "Objects are not valid as a React child (found: %s).%s",
        Object.prototype.toString.call(newChild) === "[object Object]" ?
        "object with keys {" + Object.keys(newChild).join(", ") + "}" :
        newChild,
        addendum);

      }
    }

    function warnOnFunctionType() {
      var currentComponentErrorInfo =
      "Functions are not valid as a React child. This may happen if " +
      "you return a Component instead of <Component /> from render. " +
      "Or maybe you meant to call this function rather than return it." +
      getCurrentFiberStackInDev();

      if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

      warning$1(
      false,
      "Functions are not valid as a React child. This may happen if " +
      "you return a Component instead of <Component /> from render. " +
      "Or maybe you meant to call this function rather than return it.");

    }





    function ChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (!shouldTrackSideEffects) {

          return;
        }





        var last = returnFiber.lastEffect;
        if (last !== null) {
          last.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } else {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }
        childToDelete.nextEffect = null;
        childToDelete.effectTag = Deletion;
      }

      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) {

          return null;
        }



        var childToDelete = currentFirstChild;
        while (childToDelete !== null) {
          deleteChild(returnFiber, childToDelete);
          childToDelete = childToDelete.sibling;
        }
        return null;
      }

      function mapRemainingChildren(returnFiber, currentFirstChild) {


        var existingChildren = new Map();

        var existingChild = currentFirstChild;
        while (existingChild !== null) {
          if (existingChild.key !== null) {
            existingChildren.set(existingChild.key, existingChild);
          } else {
            existingChildren.set(existingChild.index, existingChild);
          }
          existingChild = existingChild.sibling;
        }
        return existingChildren;
      }

      function useFiber(fiber, pendingProps, expirationTime) {


        var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
        clone.index = 0;
        clone.sibling = null;
        return clone;
      }

      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects) {

          return lastPlacedIndex;
        }
        var current$$1 = newFiber.alternate;
        if (current$$1 !== null) {
          var oldIndex = current$$1.index;
          if (oldIndex < lastPlacedIndex) {

            newFiber.effectTag = Placement;
            return lastPlacedIndex;
          } else {

            return oldIndex;
          }
        } else {

          newFiber.effectTag = Placement;
          return lastPlacedIndex;
        }
      }

      function placeSingleChild(newFiber) {


        if (shouldTrackSideEffects && newFiber.alternate === null) {
          newFiber.effectTag = Placement;
        }
        return newFiber;
      }

      function updateTextNode(
      returnFiber,
      current$$1,
      textContent,
      expirationTime)
      {
        if (current$$1 === null || current$$1.tag !== HostText) {

          var created = createFiberFromText(
          textContent,
          returnFiber.mode,
          expirationTime);

          created.return = returnFiber;
          return created;
        } else {

          var existing = useFiber(current$$1, textContent, expirationTime);
          existing.return = returnFiber;
          return existing;
        }
      }

      function updateElement(returnFiber, current$$1, element, expirationTime) {
        if (current$$1 !== null && current$$1.type === element.type) {

          var existing = useFiber(current$$1, element.props, expirationTime);
          existing.ref = coerceRef(returnFiber, current$$1, element);
          existing.return = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {

          var created = createFiberFromElement(
          element,
          returnFiber.mode,
          expirationTime);

          created.ref = coerceRef(returnFiber, current$$1, element);
          created.return = returnFiber;
          return created;
        }
      }

      function updatePortal(returnFiber, current$$1, portal, expirationTime) {
        if (
        current$$1 === null ||
        current$$1.tag !== HostPortal ||
        current$$1.stateNode.containerInfo !== portal.containerInfo ||
        current$$1.stateNode.implementation !== portal.implementation)
        {

          var created = createFiberFromPortal(
          portal,
          returnFiber.mode,
          expirationTime);

          created.return = returnFiber;
          return created;
        } else {

          var existing = useFiber(
          current$$1,
          portal.children || [],
          expirationTime);

          existing.return = returnFiber;
          return existing;
        }
      }

      function updateFragment(
      returnFiber,
      current$$1,
      fragment,
      expirationTime,
      key)
      {
        if (current$$1 === null || current$$1.tag !== Fragment) {

          var created = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          expirationTime,
          key);

          created.return = returnFiber;
          return created;
        } else {

          var existing = useFiber(current$$1, fragment, expirationTime);
          existing.return = returnFiber;
          return existing;
        }
      }

      function createChild(returnFiber, newChild, expirationTime) {
        if (typeof newChild === "string" || typeof newChild === "number") {



          var created = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          expirationTime);

          created.return = returnFiber;
          return created;
        }

        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:{
                var _created = createFiberFromElement(
                newChild,
                returnFiber.mode,
                expirationTime);

                _created.ref = coerceRef(returnFiber, null, newChild);
                _created.return = returnFiber;
                return _created;
              }
            case REACT_PORTAL_TYPE:{
                var _created2 = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                expirationTime);

                _created2.return = returnFiber;
                return _created2;
              }}


          if (isArray$1(newChild) || getIteratorFn(newChild)) {
            var _created3 = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            expirationTime,
            null);

            _created3.return = returnFiber;
            return _created3;
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === "function") {
            warnOnFunctionType();
          }
        }

        return null;
      }

      function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {


        var key = oldFiber !== null ? oldFiber.key : null;

        if (typeof newChild === "string" || typeof newChild === "number") {



          if (key !== null) {
            return null;
          }
          return updateTextNode(
          returnFiber,
          oldFiber,
          "" + newChild,
          expirationTime);

        }

        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:{
                if (newChild.key === key) {
                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment(
                    returnFiber,
                    oldFiber,
                    newChild.props.children,
                    expirationTime,
                    key);

                  }
                  return updateElement(
                  returnFiber,
                  oldFiber,
                  newChild,
                  expirationTime);

                } else {
                  return null;
                }
              }
            case REACT_PORTAL_TYPE:{
                if (newChild.key === key) {
                  return updatePortal(
                  returnFiber,
                  oldFiber,
                  newChild,
                  expirationTime);

                } else {
                  return null;
                }
              }}


          if (isArray$1(newChild) || getIteratorFn(newChild)) {
            if (key !== null) {
              return null;
            }

            return updateFragment(
            returnFiber,
            oldFiber,
            newChild,
            expirationTime,
            null);

          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === "function") {
            warnOnFunctionType();
          }
        }

        return null;
      }

      function updateFromMap(
      existingChildren,
      returnFiber,
      newIdx,
      newChild,
      expirationTime)
      {
        if (typeof newChild === "string" || typeof newChild === "number") {


          var matchedFiber = existingChildren.get(newIdx) || null;
          return updateTextNode(
          returnFiber,
          matchedFiber,
          "" + newChild,
          expirationTime);

        }

        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:{
                var _matchedFiber =
                existingChildren.get(
                newChild.key === null ? newIdx : newChild.key) ||
                null;
                if (newChild.type === REACT_FRAGMENT_TYPE) {
                  return updateFragment(
                  returnFiber,
                  _matchedFiber,
                  newChild.props.children,
                  expirationTime,
                  newChild.key);

                }
                return updateElement(
                returnFiber,
                _matchedFiber,
                newChild,
                expirationTime);

              }
            case REACT_PORTAL_TYPE:{
                var _matchedFiber2 =
                existingChildren.get(
                newChild.key === null ? newIdx : newChild.key) ||
                null;
                return updatePortal(
                returnFiber,
                _matchedFiber2,
                newChild,
                expirationTime);

              }}


          if (isArray$1(newChild) || getIteratorFn(newChild)) {
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateFragment(
            returnFiber,
            _matchedFiber3,
            newChild,
            expirationTime,
            null);

          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === "function") {
            warnOnFunctionType();
          }
        }

        return null;
      }




      function warnOnInvalidKey(child, knownKeys) {
        {
          if (typeof child !== "object" || child === null) {
            return knownKeys;
          }
          switch (child.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              warnForMissingKey(child);
              var key = child.key;
              if (typeof key !== "string") {
                break;
              }
              if (knownKeys === null) {
                knownKeys = new Set();
                knownKeys.add(key);
                break;
              }
              if (!knownKeys.has(key)) {
                knownKeys.add(key);
                break;
              }
              warning$1(
              false,
              "Encountered two children with the same key, `%s`. " +
              "Keys should be unique so that components maintain their identity " +
              "across updates. Non-unique keys may cause children to be " +
              "duplicated and/or omitted — the behavior is unsupported and " +
              "could change in a future version.",
              key);

              break;
            default:
              break;}

        }
        return knownKeys;
      }

      function reconcileChildrenArray(
      returnFiber,
      currentFirstChild,
      newChildren,
      expirationTime)
      {



















        {

          var knownKeys = null;
          for (var i = 0; i < newChildren.length; i++) {
            var child = newChildren[i];
            knownKeys = warnOnInvalidKey(child, knownKeys);
          }
        }

        var resultingFirstChild = null;
        var previousNewFiber = null;

        var oldFiber = currentFirstChild;
        var lastPlacedIndex = 0;
        var newIdx = 0;
        var nextOldFiber = null;
        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
          if (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = null;
          } else {
            nextOldFiber = oldFiber.sibling;
          }
          var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          newChildren[newIdx],
          expirationTime);

          if (newFiber === null) {




            if (oldFiber === null) {
              oldFiber = nextOldFiber;
            }
            break;
          }
          if (shouldTrackSideEffects) {
            if (oldFiber && newFiber.alternate === null) {


              deleteChild(returnFiber, oldFiber);
            }
          }
          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
          if (previousNewFiber === null) {

            resultingFirstChild = newFiber;
          } else {




            previousNewFiber.sibling = newFiber;
          }
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }

        if (newIdx === newChildren.length) {

          deleteRemainingChildren(returnFiber, oldFiber);
          return resultingFirstChild;
        }

        if (oldFiber === null) {


          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber = createChild(
            returnFiber,
            newChildren[newIdx],
            expirationTime);

            if (!_newFiber) {
              continue;
            }
            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {

              resultingFirstChild = _newFiber;
            } else {
              previousNewFiber.sibling = _newFiber;
            }
            previousNewFiber = _newFiber;
          }
          return resultingFirstChild;
        }


        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);


        for (; newIdx < newChildren.length; newIdx++) {
          var _newFiber2 = updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          newChildren[newIdx],
          expirationTime);

          if (_newFiber2) {
            if (shouldTrackSideEffects) {
              if (_newFiber2.alternate !== null) {




                existingChildren.delete(
                _newFiber2.key === null ? newIdx : _newFiber2.key);

              }
            }
            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = _newFiber2;
            } else {
              previousNewFiber.sibling = _newFiber2;
            }
            previousNewFiber = _newFiber2;
          }
        }

        if (shouldTrackSideEffects) {


          existingChildren.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        }

        return resultingFirstChild;
      }

      function reconcileChildrenIterator(
      returnFiber,
      currentFirstChild,
      newChildrenIterable,
      expirationTime)
      {



        var iteratorFn = getIteratorFn(newChildrenIterable);
        invariant(
        typeof iteratorFn === "function",
        "An object is not an iterable. This error is likely caused by a bug in " +
        "React. Please file an issue.");


        {


          if (
          typeof Symbol === "function" &&

          newChildrenIterable[typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag"] === "Generator")
          {
            !didWarnAboutGenerators ?
            warning$1(
            false,
            "Using Generators as children is unsupported and will likely yield " +
            "unexpected results because enumerating a generator mutates it. " +
            "You may convert it to an array with `Array.from()` or the " +
            "`[...spread]` operator before rendering. Keep in mind " +
            "you might need to polyfill these features for older browsers.") :

            void 0;
            didWarnAboutGenerators = true;
          }


          if (newChildrenIterable.entries === iteratorFn) {
            !didWarnAboutMaps ?
            warning$1(
            false,
            "Using Maps as children is unsupported and will likely yield " +
            "unexpected results. Convert it to a sequence/iterable of keyed " +
            "ReactElements instead.") :

            void 0;
            didWarnAboutMaps = true;
          }



          var _newChildren = iteratorFn.call(newChildrenIterable);
          if (_newChildren) {
            var knownKeys = null;
            var _step = _newChildren.next();
            for (; !_step.done; _step = _newChildren.next()) {
              var child = _step.value;
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
        }

        var newChildren = iteratorFn.call(newChildrenIterable);
        invariant(newChildren != null, "An iterable object provided no iterator.");

        var resultingFirstChild = null;
        var previousNewFiber = null;

        var oldFiber = currentFirstChild;
        var lastPlacedIndex = 0;
        var newIdx = 0;
        var nextOldFiber = null;

        var step = newChildren.next();
        for (;

        oldFiber !== null && !step.done;
        newIdx++, step = newChildren.next())
        {
          if (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = null;
          } else {
            nextOldFiber = oldFiber.sibling;
          }
          var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          step.value,
          expirationTime);

          if (newFiber === null) {




            if (!oldFiber) {
              oldFiber = nextOldFiber;
            }
            break;
          }
          if (shouldTrackSideEffects) {
            if (oldFiber && newFiber.alternate === null) {


              deleteChild(returnFiber, oldFiber);
            }
          }
          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
          if (previousNewFiber === null) {

            resultingFirstChild = newFiber;
          } else {




            previousNewFiber.sibling = newFiber;
          }
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }

        if (step.done) {

          deleteRemainingChildren(returnFiber, oldFiber);
          return resultingFirstChild;
        }

        if (oldFiber === null) {


          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
            if (_newFiber3 === null) {
              continue;
            }
            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {

              resultingFirstChild = _newFiber3;
            } else {
              previousNewFiber.sibling = _newFiber3;
            }
            previousNewFiber = _newFiber3;
          }
          return resultingFirstChild;
        }


        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);


        for (; !step.done; newIdx++, step = newChildren.next()) {
          var _newFiber4 = updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          step.value,
          expirationTime);

          if (_newFiber4 !== null) {
            if (shouldTrackSideEffects) {
              if (_newFiber4.alternate !== null) {




                existingChildren.delete(
                _newFiber4.key === null ? newIdx : _newFiber4.key);

              }
            }
            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = _newFiber4;
            } else {
              previousNewFiber.sibling = _newFiber4;
            }
            previousNewFiber = _newFiber4;
          }
        }

        if (shouldTrackSideEffects) {


          existingChildren.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        }

        return resultingFirstChild;
      }

      function reconcileSingleTextNode(
      returnFiber,
      currentFirstChild,
      textContent,
      expirationTime)
      {


        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {


          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
          var existing = useFiber(currentFirstChild, textContent, expirationTime);
          existing.return = returnFiber;
          return existing;
        }


        deleteRemainingChildren(returnFiber, currentFirstChild);
        var created = createFiberFromText(
        textContent,
        returnFiber.mode,
        expirationTime);

        created.return = returnFiber;
        return created;
      }

      function reconcileSingleElement(
      returnFiber,
      currentFirstChild,
      element,
      expirationTime)
      {
        var key = element.key;
        var child = currentFirstChild;
        while (child !== null) {


          if (child.key === key) {
            if (
            child.tag === Fragment ?
            element.type === REACT_FRAGMENT_TYPE :
            child.type === element.type)
            {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(
              child,
              element.type === REACT_FRAGMENT_TYPE ?
              element.props.children :
              element.props,
              expirationTime);

              existing.ref = coerceRef(returnFiber, child, element);
              existing.return = returnFiber;
              {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
              break;
            }
          } else {
            deleteChild(returnFiber, child);
          }
          child = child.sibling;
        }

        if (element.type === REACT_FRAGMENT_TYPE) {
          var created = createFiberFromFragment(
          element.props.children,
          returnFiber.mode,
          expirationTime,
          element.key);

          created.return = returnFiber;
          return created;
        } else {
          var _created4 = createFiberFromElement(
          element,
          returnFiber.mode,
          expirationTime);

          _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
          _created4.return = returnFiber;
          return _created4;
        }
      }

      function reconcileSinglePortal(
      returnFiber,
      currentFirstChild,
      portal,
      expirationTime)
      {
        var key = portal.key;
        var child = currentFirstChild;
        while (child !== null) {


          if (child.key === key) {
            if (
            child.tag === HostPortal &&
            child.stateNode.containerInfo === portal.containerInfo &&
            child.stateNode.implementation === portal.implementation)
            {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(child, portal.children || [], expirationTime);
              existing.return = returnFiber;
              return existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
              break;
            }
          } else {
            deleteChild(returnFiber, child);
          }
          child = child.sibling;
        }

        var created = createFiberFromPortal(
        portal,
        returnFiber.mode,
        expirationTime);

        created.return = returnFiber;
        return created;
      }




      function reconcileChildFibers(
      returnFiber,
      currentFirstChild,
      newChild,
      expirationTime)
      {








        var isUnkeyedTopLevelFragment =
        typeof newChild === "object" &&
        newChild !== null &&
        newChild.type === REACT_FRAGMENT_TYPE &&
        newChild.key === null;
        if (isUnkeyedTopLevelFragment) {
          newChild = newChild.props.children;
        }


        var isObject = typeof newChild === "object" && newChild !== null;

        if (isObject) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return placeSingleChild(
              reconcileSingleElement(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime));


            case REACT_PORTAL_TYPE:
              return placeSingleChild(
              reconcileSinglePortal(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime));}



        }

        if (typeof newChild === "string" || typeof newChild === "number") {
          return placeSingleChild(
          reconcileSingleTextNode(
          returnFiber,
          currentFirstChild,
          "" + newChild,
          expirationTime));


        }

        if (isArray$1(newChild)) {
          return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          expirationTime);

        }

        if (getIteratorFn(newChild)) {
          return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          expirationTime);

        }

        if (isObject) {
          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === "function") {
            warnOnFunctionType();
          }
        }
        if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {



          switch (returnFiber.tag) {
            case ClassComponent:
            case ClassComponentLazy:{
                {
                  var instance = returnFiber.stateNode;
                  if (instance.render._isMockFunction) {

                    break;
                  }
                }
              }



            case FunctionalComponent:{
                var Component = returnFiber.type;
                invariant(
                false,
                "%s(...): Nothing was returned from render. This usually means a " +
                "return statement is missing. Or, to render nothing, " +
                "return null.",
                Component.displayName || Component.name || "Component");

              }}

        }


        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }

      return reconcileChildFibers;
    }

    var reconcileChildFibers = ChildReconciler(true);
    var mountChildFibers = ChildReconciler(false);

    function cloneChildFibers(current$$1, workInProgress) {
      invariant(
      current$$1 === null || workInProgress.child === current$$1.child,
      "Resuming work not yet implemented.");


      if (workInProgress.child === null) {
        return;
      }

      var currentChild = workInProgress.child;
      var newChild = createWorkInProgress(
      currentChild,
      currentChild.pendingProps,
      currentChild.expirationTime);

      workInProgress.child = newChild;

      newChild.return = workInProgress;
      while (currentChild.sibling !== null) {
        currentChild = currentChild.sibling;
        newChild = newChild.sibling = createWorkInProgress(
        currentChild,
        currentChild.pendingProps,
        currentChild.expirationTime);

        newChild.return = workInProgress;
      }
      newChild.sibling = null;
    }



    var hydrationParentFiber = null;
    var nextHydratableInstance = null;
    var isHydrating = false;

    function enterHydrationState(fiber) {
      if (!supportsHydration) {
        return false;
      }

      var parentInstance = fiber.stateNode.containerInfo;
      nextHydratableInstance = getFirstHydratableChild(parentInstance);
      hydrationParentFiber = fiber;
      isHydrating = true;
      return true;
    }

    function deleteHydratableInstance(returnFiber, instance) {
      {
        switch (returnFiber.tag) {
          case HostRoot:
            didNotHydrateContainerInstance(
            returnFiber.stateNode.containerInfo,
            instance);

            break;
          case HostComponent:
            didNotHydrateInstance(
            returnFiber.type,
            returnFiber.memoizedProps,
            returnFiber.stateNode,
            instance);

            break;}

      }

      var childToDelete = createFiberFromHostInstanceForDeletion();
      childToDelete.stateNode = instance;
      childToDelete.return = returnFiber;
      childToDelete.effectTag = Deletion;






      if (returnFiber.lastEffect !== null) {
        returnFiber.lastEffect.nextEffect = childToDelete;
        returnFiber.lastEffect = childToDelete;
      } else {
        returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
      }
    }

    function insertNonHydratedInstance(returnFiber, fiber) {
      fiber.effectTag |= Placement;
      {
        switch (returnFiber.tag) {
          case HostRoot:{
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case HostComponent:
                  var type = fiber.type;
                  var props = fiber.pendingProps;
                  didNotFindHydratableContainerInstance(parentContainer, type, props);
                  break;
                case HostText:
                  var text = fiber.pendingProps;
                  didNotFindHydratableContainerTextInstance(parentContainer, text);
                  break;}

              break;
            }
          case HostComponent:{
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case HostComponent:
                  var _type = fiber.type;
                  var _props = fiber.pendingProps;
                  didNotFindHydratableInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  _type,
                  _props);

                  break;
                case HostText:
                  var _text = fiber.pendingProps;
                  didNotFindHydratableTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  _text);

                  break;}

              break;
            }
          default:
            return;}

      }
    }

    function tryHydrate(fiber, nextInstance) {
      switch (fiber.tag) {
        case HostComponent:{
            var type = fiber.type;
            var props = fiber.pendingProps;
            var instance = canHydrateInstance(nextInstance, type, props);
            if (instance !== null) {
              fiber.stateNode = instance;
              return true;
            }
            return false;
          }
        case HostText:{
            var text = fiber.pendingProps;
            var textInstance = canHydrateTextInstance(nextInstance, text);
            if (textInstance !== null) {
              fiber.stateNode = textInstance;
              return true;
            }
            return false;
          }
        default:
          return false;}

    }

    function tryToClaimNextHydratableInstance(fiber) {
      if (!isHydrating) {
        return;
      }
      var nextInstance = nextHydratableInstance;
      if (!nextInstance) {

        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      var firstAttemptedInstance = nextInstance;
      if (!tryHydrate(fiber, nextInstance)) {



        nextInstance = getNextHydratableSibling(firstAttemptedInstance);
        if (!nextInstance || !tryHydrate(fiber, nextInstance)) {

          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }




        deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
      }
      hydrationParentFiber = fiber;
      nextHydratableInstance = getFirstHydratableChild(nextInstance);
    }

    function prepareToHydrateHostInstance(
    fiber,
    rootContainerInstance,
    hostContext)
    {
      if (!supportsHydration) {
        invariant(
        false,
        "Expected prepareToHydrateHostInstance() to never be called. " +
        "This error is likely caused by a bug in React. Please file an issue.");

      }

      var instance = fiber.stateNode;
      var updatePayload = hydrateInstance(
      instance,
      fiber.type,
      fiber.memoizedProps,
      rootContainerInstance,
      hostContext,
      fiber);


      fiber.updateQueue = updatePayload;


      if (updatePayload !== null) {
        return true;
      }
      return false;
    }

    function prepareToHydrateHostTextInstance(fiber) {
      if (!supportsHydration) {
        invariant(
        false,
        "Expected prepareToHydrateHostTextInstance() to never be called. " +
        "This error is likely caused by a bug in React. Please file an issue.");

      }

      var textInstance = fiber.stateNode;
      var textContent = fiber.memoizedProps;
      var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
      {
        if (shouldUpdate) {


          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null) {
            switch (returnFiber.tag) {
              case HostRoot:{
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  didNotMatchHydratedContainerTextInstance(
                  parentContainer,
                  textInstance,
                  textContent);

                  break;
                }
              case HostComponent:{
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  didNotMatchHydratedTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  textInstance,
                  textContent);

                  break;
                }}

          }
        }
      }
      return shouldUpdate;
    }

    function popToNextHostParent(fiber) {
      var parent = fiber.return;
      while (
      parent !== null &&
      parent.tag !== HostComponent &&
      parent.tag !== HostRoot)
      {
        parent = parent.return;
      }
      hydrationParentFiber = parent;
    }

    function popHydrationState(fiber) {
      if (!supportsHydration) {
        return false;
      }
      if (fiber !== hydrationParentFiber) {


        return false;
      }
      if (!isHydrating) {



        popToNextHostParent(fiber);
        isHydrating = true;
        return false;
      }

      var type = fiber.type;






      if (
      fiber.tag !== HostComponent ||
      type !== "head" &&
      type !== "body" &&
      !shouldSetTextContent(type, fiber.memoizedProps))
      {
        var nextInstance = nextHydratableInstance;
        while (nextInstance) {
          deleteHydratableInstance(fiber, nextInstance);
          nextInstance = getNextHydratableSibling(nextInstance);
        }
      }

      popToNextHostParent(fiber);
      nextHydratableInstance = hydrationParentFiber ?
      getNextHydratableSibling(fiber.stateNode) :
      null;
      return true;
    }

    function resetHydrationState() {
      if (!supportsHydration) {
        return;
      }

      hydrationParentFiber = null;
      nextHydratableInstance = null;
      isHydrating = false;
    }

    function readLazyComponentType(thenable) {
      var status = thenable._reactStatus;
      switch (status) {
        case Resolved:
          var Component = thenable._reactResult;
          return Component;
        case Rejected:
          throw thenable._reactResult;
        case Pending:
          throw thenable;
        default:{
            thenable._reactStatus = Pending;
            thenable.then(
            function (resolvedValue) {
              if (thenable._reactStatus === Pending) {
                thenable._reactStatus = Resolved;
                if (typeof resolvedValue === "object" && resolvedValue !== null) {



                  var defaultExport = resolvedValue.default;
                  resolvedValue =
                  defaultExport !== undefined && defaultExport !== null ?
                  defaultExport :
                  resolvedValue;
                } else {
                  resolvedValue = resolvedValue;
                }
                thenable._reactResult = resolvedValue;
              }
            },
            function (error) {
              if (thenable._reactStatus === Pending) {
                thenable._reactStatus = Rejected;
                thenable._reactResult = error;
              }
            });

            throw thenable;
          }}

    }

    var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;

    var didWarnAboutBadClass = void 0;
    var didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;
    var didWarnAboutStatelessRefs = void 0;

    {
      didWarnAboutBadClass = {};
      didWarnAboutGetDerivedStateOnFunctionalComponent = {};
      didWarnAboutStatelessRefs = {};
    }

    function reconcileChildren(
    current$$1,
    workInProgress,
    nextChildren,
    renderExpirationTime)
    {
      if (current$$1 === null) {




        workInProgress.child = mountChildFibers(
        workInProgress,
        null,
        nextChildren,
        renderExpirationTime);

      } else {






        workInProgress.child = reconcileChildFibers(
        workInProgress,
        current$$1.child,
        nextChildren,
        renderExpirationTime);

      }
    }

    function updateForwardRef(
    current$$1,
    workInProgress,
    type,
    nextProps,
    renderExpirationTime)
    {
      var render = type.render;
      var ref = workInProgress.ref;
      if (hasContextChanged()) {


      } else if (workInProgress.memoizedProps === nextProps) {
        var currentRef = current$$1 !== null ? current$$1.ref : null;
        if (ref === currentRef) {
          return bailoutOnAlreadyFinishedWork(
          current$$1,
          workInProgress,
          renderExpirationTime);

        }
      }

      var nextChildren = void 0;
      {
        ReactCurrentOwner$3.current = workInProgress;
        setCurrentPhase("render");
        nextChildren = render(nextProps, ref);
        setCurrentPhase(null);
      }

      reconcileChildren(
      current$$1,
      workInProgress,
      nextChildren,
      renderExpirationTime);

      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updateFragment(current$$1, workInProgress, renderExpirationTime) {
      var nextChildren = workInProgress.pendingProps;
      reconcileChildren(
      current$$1,
      workInProgress,
      nextChildren,
      renderExpirationTime);

      memoizeProps(workInProgress, nextChildren);
      return workInProgress.child;
    }

    function updateMode(current$$1, workInProgress, renderExpirationTime) {
      var nextChildren = workInProgress.pendingProps.children;
      reconcileChildren(
      current$$1,
      workInProgress,
      nextChildren,
      renderExpirationTime);

      memoizeProps(workInProgress, nextChildren);
      return workInProgress.child;
    }

    function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
      if (enableProfilerTimer) {
        workInProgress.effectTag |= Update;
      }
      var nextProps = workInProgress.pendingProps;
      var nextChildren = nextProps.children;
      reconcileChildren(
      current$$1,
      workInProgress,
      nextChildren,
      renderExpirationTime);

      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function markRef(current$$1, workInProgress) {
      var ref = workInProgress.ref;
      if (
      current$$1 === null && ref !== null ||
      current$$1 !== null && current$$1.ref !== ref)
      {

        workInProgress.effectTag |= Ref;
      }
    }

    function updateFunctionalComponent(
    current$$1,
    workInProgress,
    Component,
    nextProps,
    renderExpirationTime)
    {
      var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
      var context = getMaskedContext(workInProgress, unmaskedContext);

      var nextChildren = void 0;
      prepareToReadContext(workInProgress, renderExpirationTime);
      {
        ReactCurrentOwner$3.current = workInProgress;
        setCurrentPhase("render");
        nextChildren = Component(nextProps, context);
        setCurrentPhase(null);
      }


      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(
      current$$1,
      workInProgress,
      nextChildren,
      renderExpirationTime);

      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updateClassComponent(
    current$$1,
    workInProgress,
    Component,
    nextProps,
    renderExpirationTime)
    {



      var hasContext = void 0;
      if (isContextProvider(Component)) {
        hasContext = true;
        pushContextProvider(workInProgress);
      } else {
        hasContext = false;
      }
      prepareToReadContext(workInProgress, renderExpirationTime);

      var shouldUpdate = void 0;
      if (current$$1 === null) {
        if (workInProgress.stateNode === null) {

          constructClassInstance(
          workInProgress,
          Component,
          nextProps,
          renderExpirationTime);

          mountClassInstance(
          workInProgress,
          Component,
          nextProps,
          renderExpirationTime);

          shouldUpdate = true;
        } else {

          shouldUpdate = resumeMountClassInstance(
          workInProgress,
          Component,
          nextProps,
          renderExpirationTime);

        }
      } else {
        shouldUpdate = updateClassInstance(
        current$$1,
        workInProgress,
        Component,
        nextProps,
        renderExpirationTime);

      }
      return finishClassComponent(
      current$$1,
      workInProgress,
      Component,
      shouldUpdate,
      hasContext,
      renderExpirationTime);

    }

    function finishClassComponent(
    current$$1,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime)
    {

      markRef(current$$1, workInProgress);

      var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;

      if (!shouldUpdate && !didCaptureError) {

        if (hasContext) {
          invalidateContextProvider(workInProgress, Component, false);
        }

        return bailoutOnAlreadyFinishedWork(
        current$$1,
        workInProgress,
        renderExpirationTime);

      }

      var instance = workInProgress.stateNode;


      ReactCurrentOwner$3.current = workInProgress;
      var nextChildren = void 0;
      if (
      didCaptureError && (
      !enableGetDerivedStateFromCatch ||
      typeof Component.getDerivedStateFromCatch !== "function"))
      {





        nextChildren = null;

        if (enableProfilerTimer) {
          stopProfilerTimerIfRunning(workInProgress);
        }
      } else {
        {
          setCurrentPhase("render");
          nextChildren = instance.render();
          if (
          debugRenderPhaseSideEffects ||
          debugRenderPhaseSideEffectsForStrictMode &&
          workInProgress.mode & StrictMode)
          {
            instance.render();
          }
          setCurrentPhase(null);
        }
      }


      workInProgress.effectTag |= PerformedWork;
      if (current$$1 !== null && didCaptureError) {


        reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);
        workInProgress.child = null;



      }
      reconcileChildren(
      current$$1,
      workInProgress,
      nextChildren,
      renderExpirationTime);



      memoizeState(workInProgress, instance.state);
      memoizeProps(workInProgress, instance.props);


      if (hasContext) {
        invalidateContextProvider(workInProgress, Component, true);
      }

      return workInProgress.child;
    }

    function pushHostRootContext(workInProgress) {
      var root = workInProgress.stateNode;
      if (root.pendingContext) {
        pushTopLevelContextObject(
        workInProgress,
        root.pendingContext,
        root.pendingContext !== root.context);

      } else if (root.context) {

        pushTopLevelContextObject(workInProgress, root.context, false);
      }
      pushHostContainer(workInProgress, root.containerInfo);
    }

    function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {
      pushHostRootContext(workInProgress);
      var updateQueue = workInProgress.updateQueue;
      invariant(
      updateQueue !== null,
      "If the root does not have an updateQueue, we should have already " +
      "bailed out. This error is likely caused by a bug in React. Please " +
      "file an issue.");

      var nextProps = workInProgress.pendingProps;
      var prevState = workInProgress.memoizedState;
      var prevChildren = prevState !== null ? prevState.element : null;
      processUpdateQueue(
      workInProgress,
      updateQueue,
      nextProps,
      null,
      renderExpirationTime);

      var nextState = workInProgress.memoizedState;


      var nextChildren = nextState.element;
      if (nextChildren === prevChildren) {


        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(
        current$$1,
        workInProgress,
        renderExpirationTime);

      }
      var root = workInProgress.stateNode;
      if (
      (current$$1 === null || current$$1.child === null) &&
      root.hydrate &&
      enterHydrationState(workInProgress))
      {









        workInProgress.effectTag |= Placement;




        workInProgress.child = mountChildFibers(
        workInProgress,
        null,
        nextChildren,
        renderExpirationTime);

      } else {


        reconcileChildren(
        current$$1,
        workInProgress,
        nextChildren,
        renderExpirationTime);

        resetHydrationState();
      }
      return workInProgress.child;
    }

    function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
      pushHostContext(workInProgress);

      if (current$$1 === null) {
        tryToClaimNextHydratableInstance(workInProgress);
      }

      var type = workInProgress.type;
      var nextProps = workInProgress.pendingProps;
      var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;

      var nextChildren = nextProps.children;
      var isDirectTextChild = shouldSetTextContent(type, nextProps);

      if (isDirectTextChild) {




        nextChildren = null;
      } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {


        workInProgress.effectTag |= ContentReset;
      }

      markRef(current$$1, workInProgress);


      if (
      renderExpirationTime !== Never &&
      workInProgress.mode & AsyncMode &&
      shouldDeprioritizeSubtree(type, nextProps))
      {

        workInProgress.expirationTime = Never;
        workInProgress.memoizedProps = nextProps;
        return null;
      }

      reconcileChildren(
      current$$1,
      workInProgress,
      nextChildren,
      renderExpirationTime);

      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updateHostText(current$$1, workInProgress) {
      if (current$$1 === null) {
        tryToClaimNextHydratableInstance(workInProgress);
      }
      var nextProps = workInProgress.pendingProps;
      memoizeProps(workInProgress, nextProps);


      return null;
    }

    function resolveDefaultProps(Component, baseProps) {
      if (Component && Component.defaultProps) {

        var props = _extends({}, baseProps);
        var defaultProps = Component.defaultProps;
        for (var propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
        return props;
      }
      return baseProps;
    }

    function mountIndeterminateComponent(
    current$$1,
    workInProgress,
    Component,
    renderExpirationTime)
    {
      invariant(
      current$$1 === null,
      "An indeterminate component should never have mounted. This error is " +
      "likely caused by a bug in React. Please file an issue.");


      var props = workInProgress.pendingProps;
      if (
      typeof Component === "object" &&
      Component !== null &&
      typeof Component.then === "function")
      {
        Component = readLazyComponentType(Component);
        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(
        workInProgress,
        Component);

        var resolvedProps = resolveDefaultProps(Component, props);
        switch (resolvedTag) {
          case FunctionalComponentLazy:{
              return updateFunctionalComponent(
              current$$1,
              workInProgress,
              Component,
              resolvedProps,
              renderExpirationTime);

            }
          case ClassComponentLazy:{
              return updateClassComponent(
              current$$1,
              workInProgress,
              Component,
              resolvedProps,
              renderExpirationTime);

            }
          case ForwardRefLazy:{
              return updateForwardRef(
              current$$1,
              workInProgress,
              Component,
              resolvedProps,
              renderExpirationTime);

            }
          default:{


              invariant(
              false,
              "Element type is invalid. Received a promise that resolves to: %s. " +
              "Promise elements must resolve to a class or function.",
              Component);

            }}

      }

      var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
      var context = getMaskedContext(workInProgress, unmaskedContext);

      prepareToReadContext(workInProgress, renderExpirationTime);

      var value = void 0;

      {
        if (
        Component.prototype &&
        typeof Component.prototype.render === "function")
        {
          var componentName = getComponentName(Component) || "Unknown";

          if (!didWarnAboutBadClass[componentName]) {
            warningWithoutStack$1(
            false,
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. " +
            "This is likely to cause errors. Change %s to extend React.Component instead.",
            componentName,
            componentName);

            didWarnAboutBadClass[componentName] = true;
          }
        }

        if (workInProgress.mode & StrictMode) {
          ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
        }

        ReactCurrentOwner$3.current = workInProgress;
        value = Component(props, context);
      }

      workInProgress.effectTag |= PerformedWork;

      if (
      typeof value === "object" &&
      value !== null &&
      typeof value.render === "function" &&
      value.$$typeof === undefined)
      {

        workInProgress.tag = ClassComponent;




        var hasContext = false;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        workInProgress.memoizedState =
        value.state !== null && value.state !== undefined ? value.state : null;

        var getDerivedStateFromProps = Component.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(
          workInProgress,
          Component,
          getDerivedStateFromProps,
          props);

        }

        adoptClassInstance(workInProgress, value);
        mountClassInstance(workInProgress, Component, props, renderExpirationTime);
        return finishClassComponent(
        current$$1,
        workInProgress,
        Component,
        true,
        hasContext,
        renderExpirationTime);

      } else {

        workInProgress.tag = FunctionalComponent;
        {
          if (Component) {
            !!Component.childContextTypes ?
            warningWithoutStack$1(
            false,
            "%s(...): childContextTypes cannot be defined on a functional component.",
            Component.displayName || Component.name || "Component") :

            void 0;
          }
          if (workInProgress.ref !== null) {
            var info = "";
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              info += "\n\nCheck the render method of `" + ownerName + "`.";
            }

            var warningKey = ownerName || workInProgress._debugID || "";
            var debugSource = workInProgress._debugSource;
            if (debugSource) {
              warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
            }
            if (!didWarnAboutStatelessRefs[warningKey]) {
              didWarnAboutStatelessRefs[warningKey] = true;
              warning$1(
              false,
              "Stateless function components cannot be given refs. " +
              "Attempts to access this ref will fail.%s",
              info);

            }
          }

          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName = getComponentName(Component) || "Unknown";

            if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {
              warningWithoutStack$1(
              false,
              "%s: Stateless functional components do not support getDerivedStateFromProps.",
              _componentName);

              didWarnAboutGetDerivedStateOnFunctionalComponent[
              _componentName] =
              true;
            }
          }
        }
        reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);
        memoizeProps(workInProgress, props);
        return workInProgress.child;
      }
    }

    function updatePlaceholderComponent(
    current$$1,
    workInProgress,
    renderExpirationTime)
    {
      if (enableSuspense) {
        var nextProps = workInProgress.pendingProps;



        var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;

        var nextDidTimeout = void 0;
        if (current$$1 !== null && workInProgress.updateQueue !== null) {


          workInProgress.updateQueue = null;
          nextDidTimeout = true;


          reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);
          current$$1.child = null;



        } else {
          nextDidTimeout = !alreadyCaptured;
        }

        if ((workInProgress.mode & StrictMode) !== NoEffect) {
          if (nextDidTimeout) {


            workInProgress.effectTag |= Update;
          } else {


            workInProgress.stateNode = null;
          }
        }



        var children = nextProps.children;
        var nextChildren = void 0;
        if (typeof children === "function") {
          nextChildren = children(nextDidTimeout);
        } else {
          nextChildren = nextDidTimeout ? nextProps.fallback : children;
        }

        workInProgress.memoizedProps = nextProps;
        workInProgress.memoizedState = nextDidTimeout;
        reconcileChildren(
        current$$1,
        workInProgress,
        nextChildren,
        renderExpirationTime);

        return workInProgress.child;
      } else {
        return null;
      }
    }

    function updatePortalComponent(
    current$$1,
    workInProgress,
    renderExpirationTime)
    {
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      var nextChildren = workInProgress.pendingProps;
      if (current$$1 === null) {





        workInProgress.child = reconcileChildFibers(
        workInProgress,
        null,
        nextChildren,
        renderExpirationTime);

        memoizeProps(workInProgress, nextChildren);
      } else {
        reconcileChildren(
        current$$1,
        workInProgress,
        nextChildren,
        renderExpirationTime);

        memoizeProps(workInProgress, nextChildren);
      }
      return workInProgress.child;
    }

    function updateContextProvider(
    current$$1,
    workInProgress,
    renderExpirationTime)
    {
      var providerType = workInProgress.type;
      var context = providerType._context;

      var newProps = workInProgress.pendingProps;
      var oldProps = workInProgress.memoizedProps;

      var newValue = newProps.value;
      workInProgress.memoizedProps = newProps;

      {
        var providerPropTypes = workInProgress.type.propTypes;

        if (providerPropTypes) {
          checkPropTypes(
          providerPropTypes,
          newProps,
          "prop",
          "Context.Provider",
          getCurrentFiberStackInDev);

        }
      }

      pushProvider(workInProgress, newValue);

      if (oldProps !== null) {
        var oldValue = oldProps.value;
        var changedBits = calculateChangedBits(context, newValue, oldValue);
        if (changedBits === 0) {

          if (oldProps.children === newProps.children && !hasContextChanged()) {
            return bailoutOnAlreadyFinishedWork(
            current$$1,
            workInProgress,
            renderExpirationTime);

          }
        } else {


          propagateContextChange(
          workInProgress,
          context,
          changedBits,
          renderExpirationTime);

        }
      }

      var newChildren = newProps.children;
      reconcileChildren(
      current$$1,
      workInProgress,
      newChildren,
      renderExpirationTime);

      return workInProgress.child;
    }

    function updateContextConsumer(
    current$$1,
    workInProgress,
    renderExpirationTime)
    {
      var context = workInProgress.type;
      var newProps = workInProgress.pendingProps;
      var render = newProps.children;

      {
        !(typeof render === "function") ?
        warningWithoutStack$1(
        false,
        "A context consumer was rendered with multiple children, or a child " +
        "that isn't a function. A context consumer expects a single child " +
        "that is a function. If you did pass a function, make sure there " +
        "is no trailing or leading whitespace around it.") :

        void 0;
      }

      prepareToReadContext(workInProgress, renderExpirationTime);
      var newValue = readContext(context, newProps.unstable_observedBits);
      var newChildren = void 0;
      {
        ReactCurrentOwner$3.current = workInProgress;
        setCurrentPhase("render");
        newChildren = render(newValue);
        setCurrentPhase(null);
      }


      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(
      current$$1,
      workInProgress,
      newChildren,
      renderExpirationTime);

      workInProgress.memoizedProps = newProps;
      return workInProgress.child;
    }




















    function bailoutOnAlreadyFinishedWork(
    current$$1,
    workInProgress,
    renderExpirationTime)
    {
      cancelWorkTimer(workInProgress);

      if (current$$1 !== null) {

        workInProgress.firstContextDependency = current$$1.firstContextDependency;
      }

      if (enableProfilerTimer) {

        stopProfilerTimerIfRunning(workInProgress);
      }


      var childExpirationTime = workInProgress.childExpirationTime;
      if (
      childExpirationTime === NoWork ||
      childExpirationTime > renderExpirationTime)
      {



        return null;
      } else {


        cloneChildFibers(current$$1, workInProgress);
        return workInProgress.child;
      }
    }


    function memoizeProps(workInProgress, nextProps) {
      workInProgress.memoizedProps = nextProps;
    }

    function memoizeState(workInProgress, nextState) {
      workInProgress.memoizedState = nextState;


    }

    function beginWork(current$$1, workInProgress, renderExpirationTime) {
      var updateExpirationTime = workInProgress.expirationTime;
      if (
      !hasContextChanged() && (
      updateExpirationTime === NoWork ||
      updateExpirationTime > renderExpirationTime))
      {



        switch (workInProgress.tag) {
          case HostRoot:
            pushHostRootContext(workInProgress);
            resetHydrationState();
            break;
          case HostComponent:
            pushHostContext(workInProgress);
            break;
          case ClassComponent:{
              var Component = workInProgress.type;
              if (isContextProvider(Component)) {
                pushContextProvider(workInProgress);
              }
              break;
            }
          case ClassComponentLazy:{
              var thenable = workInProgress.type;
              var _Component = getResultFromResolvedThenable(thenable);
              if (isContextProvider(_Component)) {
                pushContextProvider(workInProgress);
              }
              break;
            }
          case HostPortal:
            pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo);

            break;
          case ContextProvider:{
              var newValue = workInProgress.memoizedProps.value;
              pushProvider(workInProgress, newValue);
              break;
            }
          case Profiler:
            if (enableProfilerTimer) {
              workInProgress.effectTag |= Update;
            }
            break;}

        return bailoutOnAlreadyFinishedWork(
        current$$1,
        workInProgress,
        renderExpirationTime);

      }


      workInProgress.expirationTime = NoWork;

      switch (workInProgress.tag) {
        case IndeterminateComponent:{
            var _Component3 = workInProgress.type;
            return mountIndeterminateComponent(
            current$$1,
            workInProgress,
            _Component3,
            renderExpirationTime);

          }
        case FunctionalComponent:{
            var _Component4 = workInProgress.type;
            var _unresolvedProps = workInProgress.pendingProps;
            return updateFunctionalComponent(
            current$$1,
            workInProgress,
            _Component4,
            _unresolvedProps,
            renderExpirationTime);

          }
        case FunctionalComponentLazy:{
            var _thenable2 = workInProgress.type;
            var _Component5 = getResultFromResolvedThenable(_thenable2);
            var _unresolvedProps2 = workInProgress.pendingProps;
            var _child = updateFunctionalComponent(
            current$$1,
            workInProgress,
            _Component5,
            resolveDefaultProps(_Component5, _unresolvedProps2),
            renderExpirationTime);

            workInProgress.memoizedProps = _unresolvedProps2;
            return _child;
          }
        case ClassComponent:{
            var _Component6 = workInProgress.type;
            var _unresolvedProps3 = workInProgress.pendingProps;
            return updateClassComponent(
            current$$1,
            workInProgress,
            _Component6,
            _unresolvedProps3,
            renderExpirationTime);

          }
        case ClassComponentLazy:{
            var _thenable3 = workInProgress.type;
            var _Component7 = getResultFromResolvedThenable(_thenable3);
            var _unresolvedProps4 = workInProgress.pendingProps;
            var _child2 = updateClassComponent(
            current$$1,
            workInProgress,
            _Component7,
            resolveDefaultProps(_Component7, _unresolvedProps4),
            renderExpirationTime);

            workInProgress.memoizedProps = _unresolvedProps4;
            return _child2;
          }
        case HostRoot:
          return updateHostRoot(current$$1, workInProgress, renderExpirationTime);
        case HostComponent:
          return updateHostComponent(
          current$$1,
          workInProgress,
          renderExpirationTime);

        case HostText:
          return updateHostText(current$$1, workInProgress);
        case PlaceholderComponent:
          return updatePlaceholderComponent(
          current$$1,
          workInProgress,
          renderExpirationTime);

        case HostPortal:
          return updatePortalComponent(
          current$$1,
          workInProgress,
          renderExpirationTime);

        case ForwardRef:{
            var type = workInProgress.type;
            return updateForwardRef(
            current$$1,
            workInProgress,
            type,
            workInProgress.pendingProps,
            renderExpirationTime);

          }
        case ForwardRefLazy:
          var _thenable = workInProgress.type;
          var _Component2 = getResultFromResolvedThenable(_thenable);
          var unresolvedProps = workInProgress.pendingProps;
          var child = updateForwardRef(
          current$$1,
          workInProgress,
          _Component2,
          resolveDefaultProps(_Component2, unresolvedProps),
          renderExpirationTime);

          workInProgress.memoizedProps = unresolvedProps;
          return child;
        case Fragment:
          return updateFragment(current$$1, workInProgress, renderExpirationTime);
        case Mode:
          return updateMode(current$$1, workInProgress, renderExpirationTime);
        case Profiler:
          return updateProfiler(current$$1, workInProgress, renderExpirationTime);
        case ContextProvider:
          return updateContextProvider(
          current$$1,
          workInProgress,
          renderExpirationTime);

        case ContextConsumer:
          return updateContextConsumer(
          current$$1,
          workInProgress,
          renderExpirationTime);

        default:
          invariant(
          false,
          "Unknown unit of work tag. This error is likely caused by a bug in " +
          "React. Please file an issue.");}


    }

    function markUpdate(workInProgress) {


      workInProgress.effectTag |= Update;
    }

    function markRef$1(workInProgress) {
      workInProgress.effectTag |= Ref;
    }

    function appendAllChildren(parent, workInProgress) {


      var node = workInProgress.child;
      while (node !== null) {
        if (node.tag === HostComponent || node.tag === HostText) {
          appendInitialChild(parent, node.stateNode);
        } else if (node.tag === HostPortal) {



        } else if (node.child !== null) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === workInProgress) {
          return;
        }
        while (node.sibling === null) {
          if (node.return === null || node.return === workInProgress) {
            return;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    var updateHostContainer = void 0;
    var updateHostComponent$1 = void 0;
    var updateHostText$1 = void 0;
    if (supportsMutation) {


      updateHostContainer = function updateHostContainer(workInProgress) {

      };
      updateHostComponent$1 = function updateHostComponent$1(
      current,
      workInProgress,
      type,
      newProps,
      rootContainerInstance)
      {


        var oldProps = current.memoizedProps;
        if (oldProps === newProps) {


          return;
        }





        var instance = workInProgress.stateNode;
        var currentHostContext = getHostContext();



        var updatePayload = prepareUpdate(
        instance,
        type,
        oldProps,
        newProps,
        rootContainerInstance,
        currentHostContext);


        workInProgress.updateQueue = updatePayload;


        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {

        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else if (supportsPersistence) {



      var appendAllChildrenToContainer = function appendAllChildrenToContainer(
      containerChildSet,
      workInProgress)
      {


        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {



          } else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === workInProgress) {
              return;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      };
      updateHostContainer = function updateHostContainer(workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {

        } else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);

          appendAllChildrenToContainer(newChildSet, workInProgress);
          portalOrRoot.pendingChildren = newChildSet;

          markUpdate(workInProgress);
          finalizeContainerChildren(container, newChildSet);
        }
      };
      updateHostComponent$1 = function updateHostComponent$1(
      current,
      workInProgress,
      type,
      newProps,
      rootContainerInstance)
      {
        var currentInstance = current.stateNode;
        var oldProps = current.memoizedProps;


        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged && oldProps === newProps) {


          workInProgress.stateNode = currentInstance;
          return;
        }
        var recyclableInstance = workInProgress.stateNode;
        var currentHostContext = getHostContext();
        var updatePayload = null;
        if (oldProps !== newProps) {
          updatePayload = prepareUpdate(
          recyclableInstance,
          type,
          oldProps,
          newProps,
          rootContainerInstance,
          currentHostContext);

        }
        if (childrenUnchanged && updatePayload === null) {


          workInProgress.stateNode = currentInstance;
          return;
        }
        var newInstance = cloneInstance(
        currentInstance,
        updatePayload,
        type,
        oldProps,
        newProps,
        workInProgress,
        childrenUnchanged,
        recyclableInstance);

        if (
        finalizeInitialChildren(
        newInstance,
        type,
        newProps,
        rootContainerInstance,
        currentHostContext))

        {
          markUpdate(workInProgress);
        }
        workInProgress.stateNode = newInstance;
        if (childrenUnchanged) {



          markUpdate(workInProgress);
        } else {

          appendAllChildren(newInstance, workInProgress);
        }
      };
      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
        if (oldText !== newText) {

          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(
          newText,
          rootContainerInstance,
          currentHostContext,
          workInProgress);



          markUpdate(workInProgress);
        }
      };
    } else {

      updateHostContainer = function updateHostContainer(workInProgress) {

      };
      updateHostComponent$1 = function updateHostComponent$1(
      current,
      workInProgress,
      type,
      newProps,
      rootContainerInstance)
      {

      };
      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {

      };
    }

    function completeWork(current, workInProgress, renderExpirationTime) {
      var newProps = workInProgress.pendingProps;

      switch (workInProgress.tag) {
        case FunctionalComponent:
        case FunctionalComponentLazy:
          break;
        case ClassComponent:{
            var Component = workInProgress.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress);
            }
            break;
          }
        case ClassComponentLazy:{
            var _Component = getResultFromResolvedThenable(workInProgress.type);
            if (isContextProvider(_Component)) {
              popContext(workInProgress);
            }
            break;
          }
        case HostRoot:{
            popHostContainer(workInProgress);
            popTopLevelContextObject(workInProgress);
            var fiberRoot = workInProgress.stateNode;
            if (fiberRoot.pendingContext) {
              fiberRoot.context = fiberRoot.pendingContext;
              fiberRoot.pendingContext = null;
            }
            if (current === null || current.child === null) {


              popHydrationState(workInProgress);


              workInProgress.effectTag &= ~Placement;
            }
            updateHostContainer(workInProgress);
            break;
          }
        case HostComponent:{
            popHostContext(workInProgress);
            var rootContainerInstance = getRootHostContainer();
            var type = workInProgress.type;
            if (current !== null && workInProgress.stateNode != null) {
              updateHostComponent$1(
              current,
              workInProgress,
              type,
              newProps,
              rootContainerInstance);


              if (current.ref !== workInProgress.ref) {
                markRef$1(workInProgress);
              }
            } else {
              if (!newProps) {
                invariant(
                workInProgress.stateNode !== null,
                "We must have new props for new mounts. This error is likely " +
                "caused by a bug in React. Please file an issue.");


                break;
              }

              var currentHostContext = getHostContext();




              var wasHydrated = popHydrationState(workInProgress);
              if (wasHydrated) {


                if (
                prepareToHydrateHostInstance(
                workInProgress,
                rootContainerInstance,
                currentHostContext))

                {


                  markUpdate(workInProgress);
                }
              } else {
                var instance = createInstance(
                type,
                newProps,
                rootContainerInstance,
                currentHostContext,
                workInProgress);


                appendAllChildren(instance, workInProgress);




                if (
                finalizeInitialChildren(
                instance,
                type,
                newProps,
                rootContainerInstance,
                currentHostContext))

                {
                  markUpdate(workInProgress);
                }
                workInProgress.stateNode = instance;
              }

              if (workInProgress.ref !== null) {

                markRef$1(workInProgress);
              }
            }
            break;
          }
        case HostText:{
            var newText = newProps;
            if (current && workInProgress.stateNode != null) {
              var oldText = current.memoizedProps;


              updateHostText$1(current, workInProgress, oldText, newText);
            } else {
              if (typeof newText !== "string") {
                invariant(
                workInProgress.stateNode !== null,
                "We must have new props for new mounts. This error is likely " +
                "caused by a bug in React. Please file an issue.");


              }
              var _rootContainerInstance = getRootHostContainer();
              var _currentHostContext = getHostContext();
              var _wasHydrated = popHydrationState(workInProgress);
              if (_wasHydrated) {
                if (prepareToHydrateHostTextInstance(workInProgress)) {
                  markUpdate(workInProgress);
                }
              } else {
                workInProgress.stateNode = createTextInstance(
                newText,
                _rootContainerInstance,
                _currentHostContext,
                workInProgress);

              }
            }
            break;
          }
        case ForwardRef:
        case ForwardRefLazy:
          break;
        case PlaceholderComponent:
          break;
        case Fragment:
          break;
        case Mode:
          break;
        case Profiler:
          break;
        case HostPortal:
          popHostContainer(workInProgress);
          updateHostContainer(workInProgress);
          break;
        case ContextProvider:

          popProvider(workInProgress);
          break;
        case ContextConsumer:
          break;

        case IndeterminateComponent:
          invariant(
          false,
          "An indeterminate component should have become determinate before " +
          "completing. This error is likely caused by a bug in React. Please " +
          "file an issue.");


        default:
          invariant(
          false,
          "Unknown unit of work tag. This error is likely caused by a bug in " +
          "React. Please file an issue.");}



      return null;
    }






    function showErrorDialog(capturedError) {
      var componentStack = capturedError.componentStack,
      error = capturedError.error;

      var errorToHandle = void 0;


      if (error instanceof Error) {
        var message = error.message,
        name = error.name;

        var summary = message ? name + ": " + message : name;

        errorToHandle = error;

        try {
          errorToHandle.message =
          summary + "\n\nThis error is located at:" + componentStack;
        } catch (e) {}
      } else if (typeof error === "string") {
        errorToHandle = new Error(
        error + "\n\nThis error is located at:" + componentStack);

      } else {
        errorToHandle = new Error("Unspecified error at:" + componentStack);
      }

      ExceptionsManager.handleException(errorToHandle, false);





      return false;
    }

    function logCapturedError(capturedError) {
      var logError = showErrorDialog(capturedError);



      if (logError === false) {
        return;
      }

      var error = capturedError.error;
      {
        var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;





        if (error != null && error._suppressLogging) {
          if (errorBoundaryFound && willRetry) {



            return;
          }




          console.error(error);


        }

        var componentNameMessage = componentName ?
        "The above error occurred in the <" + componentName + "> component:" :
        "The above error occurred in one of your React components:";

        var errorBoundaryMessage = void 0;

        if (errorBoundaryFound && errorBoundaryName) {
          if (willRetry) {
            errorBoundaryMessage =
            "React will try to recreate this component tree from scratch " + (
            "using the error boundary you provided, " + errorBoundaryName + ".");
          } else {
            errorBoundaryMessage =
            "This error was initially handled by the error boundary " +
            errorBoundaryName +
            ".\n" +
            "Recreating the tree from scratch failed so React will unmount the tree.";
          }
        } else {
          errorBoundaryMessage =
          "Consider adding an error boundary to your tree to customize error handling behavior.\n" +
          "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
        }
        var combinedMessage =
        "" +
        componentNameMessage +
        componentStack +
        "\n\n" + (
        "" + errorBoundaryMessage);





        console.error(combinedMessage);
      }
    }

    var emptyObject$1 = {};

    var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    {
      didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    }

    function logError(boundary, errorInfo) {
      var source = errorInfo.source;
      var stack = errorInfo.stack;
      if (stack === null && source !== null) {
        stack = getStackByFiberInDevAndProd(source);
      }

      var capturedError = {
        componentName: source !== null ? getComponentName(source.type) : null,
        componentStack: stack !== null ? stack : "",
        error: errorInfo.value,
        errorBoundary: null,
        errorBoundaryName: null,
        errorBoundaryFound: false,
        willRetry: false };


      if (boundary !== null && boundary.tag === ClassComponent) {
        capturedError.errorBoundary = boundary.stateNode;
        capturedError.errorBoundaryName = getComponentName(boundary.type);
        capturedError.errorBoundaryFound = true;
        capturedError.willRetry = true;
      }

      try {
        logCapturedError(capturedError);
      } catch (e) {




        setTimeout(function () {
          throw e;
        });
      }
    }

    var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current$$1, instance) {
      startPhaseTimer(current$$1, "componentWillUnmount");
      instance.props = current$$1.memoizedProps;
      instance.state = current$$1.memoizedState;
      instance.componentWillUnmount();
      stopPhaseTimer();
    };


    function safelyCallComponentWillUnmount(current$$1, instance) {
      {
        invokeGuardedCallback(
        null,
        callComponentWillUnmountWithTimer,
        null,
        current$$1,
        instance);

        if (hasCaughtError()) {
          var unmountError = clearCaughtError();
          captureCommitPhaseError(current$$1, unmountError);
        }
      }
    }

    function safelyDetachRef(current$$1) {
      var ref = current$$1.ref;
      if (ref !== null) {
        if (typeof ref === "function") {
          {
            invokeGuardedCallback(null, ref, null, null);
            if (hasCaughtError()) {
              var refError = clearCaughtError();
              captureCommitPhaseError(current$$1, refError);
            }
          }
        } else {
          ref.current = null;
        }
      }
    }

    function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
      switch (finishedWork.tag) {
        case ClassComponent:
        case ClassComponentLazy:{
            if (finishedWork.effectTag & Snapshot) {
              if (current$$1 !== null) {
                var prevProps = current$$1.memoizedProps;
                var prevState = current$$1.memoizedState;
                startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
                var instance = finishedWork.stateNode;
                instance.props = finishedWork.memoizedProps;
                instance.state = finishedWork.memoizedState;
                var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
                {
                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                  if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                    didWarnSet.add(finishedWork.type);
                    warningWithoutStack$1(
                    false,
                    "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) " +
                    "must be returned. You have returned undefined.",
                    getComponentName(finishedWork.type));

                  }
                }
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                stopPhaseTimer();
              }
            }
            return;
          }
        case HostRoot:
        case HostComponent:
        case HostText:
        case HostPortal:

          return;
        default:{
            invariant(
            false,
            "This unit of work tag should not have side-effects. This error is " +
            "likely caused by a bug in React. Please file an issue.");

          }}

    }

    function commitLifeCycles(
    finishedRoot,
    current$$1,
    finishedWork,
    committedExpirationTime)
    {
      switch (finishedWork.tag) {
        case ClassComponent:
        case ClassComponentLazy:{
            var instance = finishedWork.stateNode;
            if (finishedWork.effectTag & Update) {
              if (current$$1 === null) {
                startPhaseTimer(finishedWork, "componentDidMount");
                instance.props = finishedWork.memoizedProps;
                instance.state = finishedWork.memoizedState;
                instance.componentDidMount();
                stopPhaseTimer();
              } else {
                var prevProps = current$$1.memoizedProps;
                var prevState = current$$1.memoizedState;
                startPhaseTimer(finishedWork, "componentDidUpdate");
                instance.props = finishedWork.memoizedProps;
                instance.state = finishedWork.memoizedState;
                instance.componentDidUpdate(
                prevProps,
                prevState,
                instance.__reactInternalSnapshotBeforeUpdate);

                stopPhaseTimer();
              }
            }
            var updateQueue = finishedWork.updateQueue;
            if (updateQueue !== null) {
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              commitUpdateQueue(
              finishedWork,
              updateQueue,
              instance,
              committedExpirationTime);

            }
            return;
          }
        case HostRoot:{
            var _updateQueue = finishedWork.updateQueue;
            if (_updateQueue !== null) {
              var _instance = null;
              if (finishedWork.child !== null) {
                switch (finishedWork.child.tag) {
                  case HostComponent:
                    _instance = getPublicInstance(finishedWork.child.stateNode);
                    break;
                  case ClassComponent:
                  case ClassComponentLazy:
                    _instance = finishedWork.child.stateNode;
                    break;}

              }
              commitUpdateQueue(
              finishedWork,
              _updateQueue,
              _instance,
              committedExpirationTime);

            }
            return;
          }
        case HostComponent:{
            var _instance2 = finishedWork.stateNode;





            if (current$$1 === null && finishedWork.effectTag & Update) {
              var type = finishedWork.type;
              var props = finishedWork.memoizedProps;
            }

            return;
          }
        case HostText:{

            return;
          }
        case HostPortal:{

            return;
          }
        case Profiler:{
            if (enableProfilerTimer) {
              var onRender = finishedWork.memoizedProps.onRender;

              if (enableSchedulerTracking) {
                onRender(
                finishedWork.memoizedProps.id,
                current$$1 === null ? "mount" : "update",
                finishedWork.actualDuration,
                finishedWork.treeBaseDuration,
                finishedWork.actualStartTime,
                getCommitTime(),
                finishedRoot.memoizedInteractions);

              } else {
                onRender(
                finishedWork.memoizedProps.id,
                current$$1 === null ? "mount" : "update",
                finishedWork.actualDuration,
                finishedWork.treeBaseDuration,
                finishedWork.actualStartTime,
                getCommitTime());

              }
            }
            return;
          }
        case PlaceholderComponent:{
            if (enableSuspense) {
              if ((finishedWork.mode & StrictMode) === NoEffect) {





                finishedWork.updateQueue = emptyObject$1;
                scheduleWork(finishedWork, Sync);
              } else {


                var currentTime = requestCurrentTime();
                finishedWork.stateNode = { timedOutAt: currentTime };
              }
            }
            return;
          }
        default:{
            invariant(
            false,
            "This unit of work tag should not have side-effects. This error is " +
            "likely caused by a bug in React. Please file an issue.");

          }}

    }

    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (ref !== null) {
        var instance = finishedWork.stateNode;
        var instanceToUse = void 0;
        switch (finishedWork.tag) {
          case HostComponent:
            instanceToUse = getPublicInstance(instance);
            break;
          default:
            instanceToUse = instance;}

        if (typeof ref === "function") {
          ref(instanceToUse);
        } else {
          {
            if (!ref.hasOwnProperty("current")) {
              warningWithoutStack$1(
              false,
              "Unexpected ref object provided for %s. " +
              "Use either a ref-setter function or React.createRef().%s",
              getComponentName(finishedWork.type),
              getStackByFiberInDevAndProd(finishedWork));

            }
          }

          ref.current = instanceToUse;
        }
      }
    }

    function commitDetachRef(current$$1) {
      var currentRef = current$$1.ref;
      if (currentRef !== null) {
        if (typeof currentRef === "function") {
          currentRef(null);
        } else {
          currentRef.current = null;
        }
      }
    }




    function commitUnmount(current$$1) {
      onCommitUnmount(current$$1);

      switch (current$$1.tag) {
        case ClassComponent:
        case ClassComponentLazy:{
            safelyDetachRef(current$$1);
            var instance = current$$1.stateNode;
            if (typeof instance.componentWillUnmount === "function") {
              safelyCallComponentWillUnmount(current$$1, instance);
            }
            return;
          }
        case HostComponent:{
            safelyDetachRef(current$$1);
            return;
          }
        case HostPortal:{



            if (supportsMutation) {
              unmountHostComponents(current$$1);
            } else if (supportsPersistence) {
              emptyPortalContainer(current$$1);
            }
            return;
          }}

    }

    function commitNestedUnmounts(root) {




      var node = root;
      while (true) {
        commitUnmount(node);


        if (
        node.child !== null && (


        !supportsMutation || node.tag !== HostPortal))
        {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === root) {
          return;
        }
        while (node.sibling === null) {
          if (node.return === null || node.return === root) {
            return;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    function detachFiber(current$$1) {





      current$$1.return = null;
      current$$1.child = null;
      if (current$$1.alternate) {
        current$$1.alternate.child = null;
        current$$1.alternate.return = null;
      }
    }

    function emptyPortalContainer(current$$1) {
      if (!supportsPersistence) {
        return;
      }

      var portal = current$$1.stateNode;
      var containerInfo = portal.containerInfo;

      var emptyChildSet = createContainerChildSet(containerInfo);
      replaceContainerChildren(containerInfo, emptyChildSet);
    }

    function commitContainer(finishedWork) {
      if (!supportsPersistence) {
        return;
      }

      switch (finishedWork.tag) {
        case ClassComponent:
        case ClassComponentLazy:{
            return;
          }
        case HostComponent:{
            return;
          }
        case HostText:{
            return;
          }
        case HostRoot:
        case HostPortal:{
            var portalOrRoot = finishedWork.stateNode;
            var containerInfo = portalOrRoot.containerInfo,
            _pendingChildren = portalOrRoot.pendingChildren;

            replaceContainerChildren(containerInfo, _pendingChildren);
            return;
          }
        default:{
            invariant(
            false,
            "This unit of work tag should not have side-effects. This error is " +
            "likely caused by a bug in React. Please file an issue.");

          }}

    }

    function getHostParentFiber(fiber) {
      var parent = fiber.return;
      while (parent !== null) {
        if (isHostParent(parent)) {
          return parent;
        }
        parent = parent.return;
      }
      invariant(
      false,
      "Expected to find a host parent. This error is likely caused by a bug " +
      "in React. Please file an issue.");

    }

    function isHostParent(fiber) {
      return (
        fiber.tag === HostComponent ||
        fiber.tag === HostRoot ||
        fiber.tag === HostPortal);

    }

    function getHostSibling(fiber) {



      var node = fiber;
      siblings: while (true) {

        while (node.sibling === null) {
          if (node.return === null || isHostParent(node.return)) {


            return null;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
        while (node.tag !== HostComponent && node.tag !== HostText) {


          if (node.effectTag & Placement) {

            continue siblings;
          }


          if (node.child === null || node.tag === HostPortal) {
            continue siblings;
          } else {
            node.child.return = node;
            node = node.child;
          }
        }

        if (!(node.effectTag & Placement)) {

          return node.stateNode;
        }
      }
    }

    function commitPlacement(finishedWork) {
      if (!supportsMutation) {
        return;
      }


      var parentFiber = getHostParentFiber(finishedWork);


      var parent = void 0;
      var isContainer = void 0;

      switch (parentFiber.tag) {
        case HostComponent:
          parent = parentFiber.stateNode;
          isContainer = false;
          break;
        case HostRoot:
          parent = parentFiber.stateNode.containerInfo;
          isContainer = true;
          break;
        case HostPortal:
          parent = parentFiber.stateNode.containerInfo;
          isContainer = true;
          break;
        default:
          invariant(
          false,
          "Invalid host parent fiber. This error is likely caused by a bug " +
          "in React. Please file an issue.");}


      if (parentFiber.effectTag & ContentReset) {

        parentFiber.effectTag &= ~ContentReset;
      }

      var before = getHostSibling(finishedWork);


      var node = finishedWork;
      while (true) {
        if (node.tag === HostComponent || node.tag === HostText) {
          if (before) {
            if (isContainer) {
              insertInContainerBefore(parent, node.stateNode, before);
            } else {
              insertBefore(parent, node.stateNode, before);
            }
          } else {
            if (isContainer) {
              appendChildToContainer(parent, node.stateNode);
            } else {
              appendChild(parent, node.stateNode);
            }
          }
        } else if (node.tag === HostPortal) {



        } else if (node.child !== null) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === finishedWork) {
          return;
        }
        while (node.sibling === null) {
          if (node.return === null || node.return === finishedWork) {
            return;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    function unmountHostComponents(current$$1) {

      var node = current$$1;



      var currentParentIsValid = false;


      var currentParent = void 0;
      var currentParentIsContainer = void 0;

      while (true) {
        if (!currentParentIsValid) {
          var parent = node.return;
          findParent: while (true) {
            invariant(
            parent !== null,
            "Expected to find a host parent. This error is likely caused by " +
            "a bug in React. Please file an issue.");

            switch (parent.tag) {
              case HostComponent:
                currentParent = parent.stateNode;
                currentParentIsContainer = false;
                break findParent;
              case HostRoot:
                currentParent = parent.stateNode.containerInfo;
                currentParentIsContainer = true;
                break findParent;
              case HostPortal:
                currentParent = parent.stateNode.containerInfo;
                currentParentIsContainer = true;
                break findParent;}

            parent = parent.return;
          }
          currentParentIsValid = true;
        }

        if (node.tag === HostComponent || node.tag === HostText) {
          commitNestedUnmounts(node);


          if (currentParentIsContainer) {
            removeChildFromContainer(currentParent, node.stateNode);
          } else {
            removeChild(currentParent, node.stateNode);
          }

        } else if (node.tag === HostPortal) {


          currentParent = node.stateNode.containerInfo;
          currentParentIsContainer = true;

          if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
        } else {
          commitUnmount(node);

          if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
        }
        if (node === current$$1) {
          return;
        }
        while (node.sibling === null) {
          if (node.return === null || node.return === current$$1) {
            return;
          }
          node = node.return;
          if (node.tag === HostPortal) {


            currentParentIsValid = false;
          }
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    function commitDeletion(current$$1) {
      if (supportsMutation) {


        unmountHostComponents(current$$1);
      } else {

        commitNestedUnmounts(current$$1);
      }
      detachFiber(current$$1);
    }

    function commitWork(current$$1, finishedWork) {
      if (!supportsMutation) {
        commitContainer(finishedWork);
        return;
      }

      switch (finishedWork.tag) {
        case ClassComponent:
        case ClassComponentLazy:{
            return;
          }
        case HostComponent:{
            var instance = finishedWork.stateNode;
            if (instance != null) {

              var newProps = finishedWork.memoizedProps;



              var oldProps =
              current$$1 !== null ? current$$1.memoizedProps : newProps;
              var type = finishedWork.type;

              var updatePayload = finishedWork.updateQueue;
              finishedWork.updateQueue = null;
              if (updatePayload !== null) {
                commitUpdate(
                instance,
                updatePayload,
                type,
                oldProps,
                newProps,
                finishedWork);

              }
            }
            return;
          }
        case HostText:{
            invariant(
            finishedWork.stateNode !== null,
            "This should have a text node initialized. This error is likely " +
            "caused by a bug in React. Please file an issue.");

            var textInstance = finishedWork.stateNode;
            var newText = finishedWork.memoizedProps;



            var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;
            commitTextUpdate(textInstance, oldText, newText);
            return;
          }
        case HostRoot:{
            return;
          }
        case Profiler:{
            return;
          }
        case PlaceholderComponent:{
            return;
          }
        default:{
            invariant(
            false,
            "This unit of work tag should not have side-effects. This error is " +
            "likely caused by a bug in React. Please file an issue.");

          }}

    }

    function commitResetTextContent(current$$1) {
      if (!supportsMutation) {
        return;
      }
      resetTextContent(current$$1.stateNode);
    }

    function NoopComponent() {
      return null;
    }

    function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
      var update = createUpdate(expirationTime);

      update.tag = CaptureUpdate;


      update.payload = { element: null };
      var error = errorInfo.value;
      update.callback = function () {
        onUncaughtError(error);
        logError(fiber, errorInfo);
      };
      return update;
    }

    function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
      var update = createUpdate(expirationTime);
      update.tag = CaptureUpdate;
      var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;
      if (
      enableGetDerivedStateFromCatch &&
      typeof getDerivedStateFromCatch === "function")
      {
        var error = errorInfo.value;
        update.payload = function () {
          return getDerivedStateFromCatch(error);
        };
      }

      var inst = fiber.stateNode;
      if (inst !== null && typeof inst.componentDidCatch === "function") {
        update.callback = function callback() {
          if (
          !enableGetDerivedStateFromCatch ||
          getDerivedStateFromCatch !== "function")
          {





            markLegacyErrorBoundaryAsFailed(this);
          }
          var error = errorInfo.value;
          var stack = errorInfo.stack;
          logError(fiber, errorInfo);
          this.componentDidCatch(error, {
            componentStack: stack !== null ? stack : "" });

        };
      }
      return update;
    }

    function throwException(
    root,
    returnFiber,
    sourceFiber,
    value,
    renderExpirationTime)
    {

      sourceFiber.effectTag |= Incomplete;

      sourceFiber.firstEffect = sourceFiber.lastEffect = null;

      if (
      enableSuspense &&
      value !== null &&
      typeof value === "object" &&
      typeof value.then === "function")
      {

        var thenable = value;






        var _workInProgress = returnFiber;
        var earliestTimeoutMs = -1;
        var startTimeMs = -1;
        do {
          if (_workInProgress.tag === PlaceholderComponent) {
            var current = _workInProgress.alternate;
            if (
            current !== null &&
            current.memoizedState === true &&
            current.stateNode !== null)
            {





              var timedOutAt = current.stateNode.timedOutAt;
              startTimeMs = expirationTimeToMs(timedOutAt);


              break;
            }
            var timeoutPropMs = _workInProgress.pendingProps.delayMs;
            if (typeof timeoutPropMs === "number") {
              if (timeoutPropMs <= 0) {
                earliestTimeoutMs = 0;
              } else if (
              earliestTimeoutMs === -1 ||
              timeoutPropMs < earliestTimeoutMs)
              {
                earliestTimeoutMs = timeoutPropMs;
              }
            }
          }
          _workInProgress = _workInProgress.return;
        } while (_workInProgress !== null);


        _workInProgress = returnFiber;
        do {
          if (_workInProgress.tag === PlaceholderComponent) {
            var didTimeout = _workInProgress.memoizedState;
            if (!didTimeout) {




              var pingTime =
              (_workInProgress.mode & AsyncMode) === NoEffect ?
              Sync :
              renderExpirationTime;


              var onResolveOrReject = retrySuspendedRoot.bind(
              null,
              root,
              _workInProgress,
              pingTime);

              thenable.then(onResolveOrReject, onResolveOrReject);









              if ((_workInProgress.mode & StrictMode) === NoEffect) {
                _workInProgress.effectTag |= Update;


                var nextChildren = null;
                reconcileChildren(
                sourceFiber.alternate,
                sourceFiber,
                nextChildren,
                renderExpirationTime);

                sourceFiber.effectTag &= ~Incomplete;
                if (sourceFiber.tag === IndeterminateComponent) {


                  sourceFiber.tag = FunctionalComponent;
                }

                if (
                sourceFiber.tag === ClassComponent ||
                sourceFiber.tag === ClassComponentLazy)
                {



                  sourceFiber.effectTag &= ~LifecycleEffectMask;
                  if (sourceFiber.alternate === null) {





                    sourceFiber.tag = FunctionalComponent;
                    sourceFiber.type = NoopComponent;
                  }
                }


                return;
              }




              var absoluteTimeoutMs = void 0;
              if (earliestTimeoutMs === -1) {



                absoluteTimeoutMs = maxSigned31BitInt;
              } else {
                if (startTimeMs === -1) {









                  var earliestExpirationTime = findEarliestOutstandingPriorityLevel(
                  root,
                  renderExpirationTime);

                  var earliestExpirationTimeMs = expirationTimeToMs(
                  earliestExpirationTime);

                  startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
                }
                absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
              }





              renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);

              _workInProgress.effectTag |= ShouldCapture;
              _workInProgress.expirationTime = renderExpirationTime;
              return;
            }


          }
          _workInProgress = _workInProgress.return;
        } while (_workInProgress !== null);

        value = new Error(
        "An update was suspended, but no placeholder UI was provided.");

      }




      renderDidError();
      value = createCapturedValue(value, sourceFiber);
      var workInProgress = returnFiber;
      do {
        switch (workInProgress.tag) {
          case HostRoot:{
              var _errorInfo = value;
              workInProgress.effectTag |= ShouldCapture;
              workInProgress.expirationTime = renderExpirationTime;
              var update = createRootErrorUpdate(
              workInProgress,
              _errorInfo,
              renderExpirationTime);

              enqueueCapturedUpdate(workInProgress, update);
              return;
            }
          case ClassComponent:
          case ClassComponentLazy:

            var errorInfo = value;
            var ctor = workInProgress.type;
            var instance = workInProgress.stateNode;
            if (
            (workInProgress.effectTag & DidCapture) === NoEffect && (
            typeof ctor.getDerivedStateFromCatch === "function" &&
            enableGetDerivedStateFromCatch ||
            instance !== null &&
            typeof instance.componentDidCatch === "function" &&
            !isAlreadyFailedLegacyErrorBoundary(instance)))
            {
              workInProgress.effectTag |= ShouldCapture;
              workInProgress.expirationTime = renderExpirationTime;

              var _update = createClassErrorUpdate(
              workInProgress,
              errorInfo,
              renderExpirationTime);

              enqueueCapturedUpdate(workInProgress, _update);
              return;
            }
            break;
          default:
            break;}

        workInProgress = workInProgress.return;
      } while (workInProgress !== null);
    }

    function unwindWork(workInProgress, renderExpirationTime) {
      switch (workInProgress.tag) {
        case ClassComponent:{
            var Component = workInProgress.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress);
            }
            var effectTag = workInProgress.effectTag;
            if (effectTag & ShouldCapture) {
              workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;
              return workInProgress;
            }
            return null;
          }
        case ClassComponentLazy:{
            var _Component = workInProgress.type._reactResult;
            if (isContextProvider(_Component)) {
              popContext(workInProgress);
            }
            var _effectTag = workInProgress.effectTag;
            if (_effectTag & ShouldCapture) {
              workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;
              return workInProgress;
            }
            return null;
          }
        case HostRoot:{
            popHostContainer(workInProgress);
            popTopLevelContextObject(workInProgress);
            var _effectTag2 = workInProgress.effectTag;
            invariant(
            (_effectTag2 & DidCapture) === NoEffect,
            "The root failed to unmount after an error. This is likely a bug in " +
            "React. Please file an issue.");

            workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
            return workInProgress;
          }
        case HostComponent:{
            popHostContext(workInProgress);
            return null;
          }
        case PlaceholderComponent:{
            var _effectTag3 = workInProgress.effectTag;
            if (_effectTag3 & ShouldCapture) {
              workInProgress.effectTag = _effectTag3 & ~ShouldCapture | DidCapture;
              return workInProgress;
            }
            return null;
          }
        case HostPortal:
          popHostContainer(workInProgress);
          return null;
        case ContextProvider:
          popProvider(workInProgress);
          return null;
        default:
          return null;}

    }

    function unwindInterruptedWork(interruptedWork) {
      switch (interruptedWork.tag) {
        case ClassComponent:{
            var childContextTypes = interruptedWork.type.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== undefined) {
              popContext(interruptedWork);
            }
            break;
          }
        case ClassComponentLazy:{
            var _childContextTypes =
            interruptedWork.type._reactResult.childContextTypes;
            if (_childContextTypes !== null && _childContextTypes !== undefined) {
              popContext(interruptedWork);
            }
            break;
          }
        case HostRoot:{
            popHostContainer(interruptedWork);
            popTopLevelContextObject(interruptedWork);
            break;
          }
        case HostComponent:{
            popHostContext(interruptedWork);
            break;
          }
        case HostPortal:
          popHostContainer(interruptedWork);
          break;
        case ContextProvider:
          popProvider(interruptedWork);
          break;
        default:
          break;}

    }

    var Dispatcher = {
      readContext: readContext };


    var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;

    var didWarnAboutStateTransition = void 0;
    var didWarnSetStateChildContext = void 0;
    var warnAboutUpdateOnUnmounted = void 0;
    var warnAboutInvalidUpdates = void 0;

    if (enableSchedulerTracking) {


      invariant(
      tracking.__interactionsRef != null &&
      tracking.__interactionsRef.current != null,
      "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) " +
      "without also replacing the `schedule/tracking` module with `schedule/tracking-profiling`. " +
      "Your bundler might have a setting for aliasing both modules. " +
      "Learn more at http://fb.me/react-profiling");

    }

    {
      didWarnAboutStateTransition = false;
      didWarnSetStateChildContext = false;
      var didWarnStateUpdateForUnmountedComponent = {};

      warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber) {


        var componentName = getComponentName(fiber.type) || "ReactClass";
        if (didWarnStateUpdateForUnmountedComponent[componentName]) {
          return;
        }
        warningWithoutStack$1(
        false,
        "Can't call setState (or forceUpdate) on an unmounted component. This " +
        "is a no-op, but it indicates a memory leak in your application. To " +
        "fix, cancel all subscriptions and asynchronous tasks in the " +
        "componentWillUnmount method.%s",
        getStackByFiberInDevAndProd(fiber));

        didWarnStateUpdateForUnmountedComponent[componentName] = true;
      };

      warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
        switch (phase) {
          case "getChildContext":
            if (didWarnSetStateChildContext) {
              return;
            }
            warningWithoutStack$1(
            false,
            "setState(...): Cannot call setState() inside getChildContext()");

            didWarnSetStateChildContext = true;
            break;
          case "render":
            if (didWarnAboutStateTransition) {
              return;
            }
            warningWithoutStack$1(
            false,
            "Cannot update during an existing state transition (such as within " +
            "`render`). Render methods should be a pure function of props and state.");

            didWarnAboutStateTransition = true;
            break;}

      };
    }




    var expirationContext = NoWork;

    var isWorking = false;


    var nextUnitOfWork = null;
    var nextRoot = null;

    var nextRenderExpirationTime = NoWork;
    var nextLatestAbsoluteTimeoutMs = -1;
    var nextRenderDidError = false;


    var nextEffect = null;

    var isCommitting$1 = false;

    var legacyErrorBoundariesThatAlreadyFailed = null;


    var interruptedBy = null;



    var suspenseDidTimeout = false;

    var stashedWorkInProgressProperties = void 0;
    var replayUnitOfWork = void 0;
    var isReplayingFailedUnitOfWork = void 0;
    var originalReplayError = void 0;
    var rethrowOriginalError = void 0;
    if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
      stashedWorkInProgressProperties = null;
      isReplayingFailedUnitOfWork = false;
      originalReplayError = null;
      replayUnitOfWork = function replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy) {
        if (
        thrownValue !== null &&
        typeof thrownValue === "object" &&
        typeof thrownValue.then === "function")
        {



          return;
        }


        if (stashedWorkInProgressProperties === null) {

          warningWithoutStack$1(
          false,
          "Could not replay rendering after an error. This is likely a bug in React. " +
          "Please file an issue.");

          return;
        }
        assignFiberPropertiesInDEV(
        failedUnitOfWork,
        stashedWorkInProgressProperties);


        switch (failedUnitOfWork.tag) {
          case HostRoot:
            popHostContainer(failedUnitOfWork);
            popTopLevelContextObject(failedUnitOfWork);
            break;
          case HostComponent:
            popHostContext(failedUnitOfWork);
            break;
          case ClassComponent:{
              var Component = failedUnitOfWork.type;
              if (isContextProvider(Component)) {
                popContext(failedUnitOfWork);
              }
              break;
            }
          case ClassComponentLazy:{
              var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);
              if (isContextProvider(_Component)) {
                popContext(failedUnitOfWork);
              }
              break;
            }
          case HostPortal:
            popHostContainer(failedUnitOfWork);
            break;
          case ContextProvider:
            popProvider(failedUnitOfWork);
            break;}


        isReplayingFailedUnitOfWork = true;
        originalReplayError = thrownValue;
        invokeGuardedCallback(null, workLoop, null, isYieldy);
        isReplayingFailedUnitOfWork = false;
        originalReplayError = null;
        if (hasCaughtError()) {
          var replayError = clearCaughtError();
          if (replayError != null && thrownValue != null) {
            try {


              if (replayError._suppressLogging) {

                thrownValue._suppressLogging = true;
              }
            } catch (inner) {

            }
          }
        } else {


          nextUnitOfWork = failedUnitOfWork;
        }
      };
      rethrowOriginalError = function rethrowOriginalError() {
        throw originalReplayError;
      };
    }

    function resetStack() {
      if (nextUnitOfWork !== null) {
        var interruptedWork = nextUnitOfWork.return;
        while (interruptedWork !== null) {
          unwindInterruptedWork(interruptedWork);
          interruptedWork = interruptedWork.return;
        }
      }

      {
        ReactStrictModeWarnings.discardPendingWarnings();
        checkThatStackIsEmpty();
      }

      nextRoot = null;
      nextRenderExpirationTime = NoWork;
      nextLatestAbsoluteTimeoutMs = -1;
      nextRenderDidError = false;
      nextUnitOfWork = null;
    }

    function commitAllHostEffects() {
      while (nextEffect !== null) {
        {
          setCurrentFiber(nextEffect);
        }
        recordEffect();

        var effectTag = nextEffect.effectTag;

        if (effectTag & ContentReset) {
          commitResetTextContent(nextEffect);
        }

        if (effectTag & Ref) {
          var current$$1 = nextEffect.alternate;
          if (current$$1 !== null) {
            commitDetachRef(current$$1);
          }
        }





        var primaryEffectTag = effectTag & (Placement | Update | Deletion);
        switch (primaryEffectTag) {
          case Placement:{
              commitPlacement(nextEffect);





              nextEffect.effectTag &= ~Placement;
              break;
            }
          case PlacementAndUpdate:{

              commitPlacement(nextEffect);


              nextEffect.effectTag &= ~Placement;


              var _current = nextEffect.alternate;
              commitWork(_current, nextEffect);
              break;
            }
          case Update:{
              var _current2 = nextEffect.alternate;
              commitWork(_current2, nextEffect);
              break;
            }
          case Deletion:{
              commitDeletion(nextEffect);
              break;
            }}

        nextEffect = nextEffect.nextEffect;
      }

      {
        resetCurrentFiber();
      }
    }

    function commitBeforeMutationLifecycles() {
      while (nextEffect !== null) {
        {
          setCurrentFiber(nextEffect);
        }

        var effectTag = nextEffect.effectTag;
        if (effectTag & Snapshot) {
          recordEffect();
          var current$$1 = nextEffect.alternate;
          commitBeforeMutationLifeCycles(current$$1, nextEffect);
        }



        nextEffect = nextEffect.nextEffect;
      }

      {
        resetCurrentFiber();
      }
    }

    function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
      {
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();

        if (warnAboutDeprecatedLifecycles) {
          ReactStrictModeWarnings.flushPendingDeprecationWarnings();
        }

        if (warnAboutLegacyContextAPI) {
          ReactStrictModeWarnings.flushLegacyContextWarning();
        }
      }
      while (nextEffect !== null) {
        var effectTag = nextEffect.effectTag;

        if (effectTag & (Update | Callback)) {
          recordEffect();
          var current$$1 = nextEffect.alternate;
          commitLifeCycles(
          finishedRoot,
          current$$1,
          nextEffect,
          committedExpirationTime);

        }

        if (effectTag & Ref) {
          recordEffect();
          commitAttachRef(nextEffect);
        }

        var next = nextEffect.nextEffect;




        nextEffect.nextEffect = null;


        nextEffect = next;
      }
    }

    function isAlreadyFailedLegacyErrorBoundary(instance) {
      return (
        legacyErrorBoundariesThatAlreadyFailed !== null &&
        legacyErrorBoundariesThatAlreadyFailed.has(instance));

    }

    function markLegacyErrorBoundaryAsFailed(instance) {
      if (legacyErrorBoundariesThatAlreadyFailed === null) {
        legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
      } else {
        legacyErrorBoundariesThatAlreadyFailed.add(instance);
      }
    }

    function commitRoot(root, finishedWork) {
      isWorking = true;
      isCommitting$1 = true;
      startCommitTimer();

      invariant(
      root.current !== finishedWork,
      "Cannot commit the same tree as before. This is probably a bug " +
      "related to the return field. This error is likely caused by a bug " +
      "in React. Please file an issue.");

      var committedExpirationTime = root.pendingCommitExpirationTime;
      invariant(
      committedExpirationTime !== NoWork,
      "Cannot commit an incomplete root. This error is likely caused by a " +
      "bug in React. Please file an issue.");

      root.pendingCommitExpirationTime = NoWork;




      var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
      var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
      var earliestRemainingTimeBeforeCommit =
      updateExpirationTimeBeforeCommit === NoWork ||
      childExpirationTimeBeforeCommit !== NoWork &&
      childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit ?
      childExpirationTimeBeforeCommit :
      updateExpirationTimeBeforeCommit;
      markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);

      var prevInteractions = null;
      var committedInteractions = enableSchedulerTracking ? [] : null;
      if (enableSchedulerTracking) {


        prevInteractions = tracking.__interactionsRef.current;
        tracking.__interactionsRef.current = root.memoizedInteractions;









        root.pendingInteractionMap.forEach(function (
        scheduledInteractions,
        scheduledExpirationTime)
        {
          if (scheduledExpirationTime <= committedExpirationTime) {
            committedInteractions.push.apply(
            committedInteractions,
            Array.from(scheduledInteractions));

            root.pendingInteractionMap.delete(scheduledExpirationTime);
          }
        });
      }


      ReactCurrentOwner$2.current = null;

      var firstEffect = void 0;
      if (finishedWork.effectTag > PerformedWork) {




        if (finishedWork.lastEffect !== null) {
          finishedWork.lastEffect.nextEffect = finishedWork;
          firstEffect = finishedWork.firstEffect;
        } else {
          firstEffect = finishedWork;
        }
      } else {

        firstEffect = finishedWork.firstEffect;
      }

      prepareForCommit(root.containerInfo);


      nextEffect = firstEffect;
      startCommitSnapshotEffectsTimer();
      while (nextEffect !== null) {
        var didError = false;
        var error = void 0;
        {
          invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);
          if (hasCaughtError()) {
            didError = true;
            error = clearCaughtError();
          }
        }
        if (didError) {
          invariant(
          nextEffect !== null,
          "Should have next effect. This error is likely caused by a bug " +
          "in React. Please file an issue.");

          captureCommitPhaseError(nextEffect, error);

          if (nextEffect !== null) {
            nextEffect = nextEffect.nextEffect;
          }
        }
      }
      stopCommitSnapshotEffectsTimer();

      if (enableProfilerTimer) {


        recordCommitTime();
      }




      nextEffect = firstEffect;
      startCommitHostEffectsTimer();
      while (nextEffect !== null) {
        var _didError = false;
        var _error = void 0;
        {
          invokeGuardedCallback(null, commitAllHostEffects, null);
          if (hasCaughtError()) {
            _didError = true;
            _error = clearCaughtError();
          }
        }
        if (_didError) {
          invariant(
          nextEffect !== null,
          "Should have next effect. This error is likely caused by a bug " +
          "in React. Please file an issue.");

          captureCommitPhaseError(nextEffect, _error);

          if (nextEffect !== null) {
            nextEffect = nextEffect.nextEffect;
          }
        }
      }
      stopCommitHostEffectsTimer();

      resetAfterCommit(root.containerInfo);





      root.current = finishedWork;





      nextEffect = firstEffect;
      startCommitLifeCyclesTimer();
      while (nextEffect !== null) {
        var _didError2 = false;
        var _error2 = void 0;
        {
          invokeGuardedCallback(
          null,
          commitAllLifeCycles,
          null,
          root,
          committedExpirationTime);

          if (hasCaughtError()) {
            _didError2 = true;
            _error2 = clearCaughtError();
          }
        }
        if (_didError2) {
          invariant(
          nextEffect !== null,
          "Should have next effect. This error is likely caused by a bug " +
          "in React. Please file an issue.");

          captureCommitPhaseError(nextEffect, _error2);
          if (nextEffect !== null) {
            nextEffect = nextEffect.nextEffect;
          }
        }
      }

      isCommitting$1 = false;
      isWorking = false;
      stopCommitLifeCyclesTimer();
      stopCommitTimer();
      onCommitRoot(finishedWork.stateNode);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
      }

      var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
      var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
      var earliestRemainingTimeAfterCommit =
      updateExpirationTimeAfterCommit === NoWork ||
      childExpirationTimeAfterCommit !== NoWork &&
      childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit ?
      childExpirationTimeAfterCommit :
      updateExpirationTimeAfterCommit;
      if (earliestRemainingTimeAfterCommit === NoWork) {


        legacyErrorBoundariesThatAlreadyFailed = null;
      }
      onCommit(root, earliestRemainingTimeAfterCommit);

      if (enableSchedulerTracking) {
        tracking.__interactionsRef.current = prevInteractions;

        var subscriber = void 0;

        try {
          subscriber = tracking.__subscriberRef.current;
          if (subscriber !== null && root.memoizedInteractions.size > 0) {
            var threadID = computeThreadID(
            committedExpirationTime,
            root.interactionThreadID);

            subscriber.onWorkStopped(root.memoizedInteractions, threadID);
          }
        } catch (error) {


          if (!hasUnhandledError) {
            hasUnhandledError = true;
            unhandledError = error;
          }
        } finally {


          if (!suspenseDidTimeout) {



            committedInteractions.forEach(function (interaction) {
              interaction.__count--;
              if (subscriber !== null && interaction.__count === 0) {
                try {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                } catch (error) {


                  if (!hasUnhandledError) {
                    hasUnhandledError = true;
                    unhandledError = error;
                  }
                }
              }
            });
          }
        }
      }
    }

    function resetChildExpirationTime(workInProgress, renderTime) {
      if (renderTime !== Never && workInProgress.childExpirationTime === Never) {


        return;
      }

      var newChildExpirationTime = NoWork;


      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {


        var actualDuration = workInProgress.actualDuration;
        var treeBaseDuration = workInProgress.selfBaseDuration;








        var shouldBubbleActualDurations =
        workInProgress.alternate === null ||
        workInProgress.child !== workInProgress.alternate.child;

        var child = workInProgress.child;
        while (child !== null) {
          var childUpdateExpirationTime = child.expirationTime;
          var childChildExpirationTime = child.childExpirationTime;
          if (
          newChildExpirationTime === NoWork ||
          childUpdateExpirationTime !== NoWork &&
          childUpdateExpirationTime < newChildExpirationTime)
          {
            newChildExpirationTime = childUpdateExpirationTime;
          }
          if (
          newChildExpirationTime === NoWork ||
          childChildExpirationTime !== NoWork &&
          childChildExpirationTime < newChildExpirationTime)
          {
            newChildExpirationTime = childChildExpirationTime;
          }
          if (shouldBubbleActualDurations) {
            actualDuration += child.actualDuration;
          }
          treeBaseDuration += child.treeBaseDuration;
          child = child.sibling;
        }
        workInProgress.actualDuration = actualDuration;
        workInProgress.treeBaseDuration = treeBaseDuration;
      } else {
        var _child = workInProgress.child;
        while (_child !== null) {
          var _childUpdateExpirationTime = _child.expirationTime;
          var _childChildExpirationTime = _child.childExpirationTime;
          if (
          newChildExpirationTime === NoWork ||
          _childUpdateExpirationTime !== NoWork &&
          _childUpdateExpirationTime < newChildExpirationTime)
          {
            newChildExpirationTime = _childUpdateExpirationTime;
          }
          if (
          newChildExpirationTime === NoWork ||
          _childChildExpirationTime !== NoWork &&
          _childChildExpirationTime < newChildExpirationTime)
          {
            newChildExpirationTime = _childChildExpirationTime;
          }
          _child = _child.sibling;
        }
      }

      workInProgress.childExpirationTime = newChildExpirationTime;
    }

    function completeUnitOfWork(workInProgress) {



      while (true) {




        var current$$1 = workInProgress.alternate;
        {
          setCurrentFiber(workInProgress);
        }

        var returnFiber = workInProgress.return;
        var siblingFiber = workInProgress.sibling;

        if ((workInProgress.effectTag & Incomplete) === NoEffect) {

          if (enableProfilerTimer) {
            if (workInProgress.mode & ProfileMode) {
              startProfilerTimer(workInProgress);
            }

            nextUnitOfWork = completeWork(
            current$$1,
            workInProgress,
            nextRenderExpirationTime);


            if (workInProgress.mode & ProfileMode) {

              stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
            }
          } else {
            nextUnitOfWork = completeWork(
            current$$1,
            workInProgress,
            nextRenderExpirationTime);

          }
          var next = nextUnitOfWork;
          stopWorkTimer(workInProgress);
          resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
          {
            resetCurrentFiber();
          }

          if (next !== null) {
            stopWorkTimer(workInProgress);
            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }


            return next;
          }

          if (
          returnFiber !== null &&

          (returnFiber.effectTag & Incomplete) === NoEffect)
          {



            if (returnFiber.firstEffect === null) {
              returnFiber.firstEffect = workInProgress.firstEffect;
            }
            if (workInProgress.lastEffect !== null) {
              if (returnFiber.lastEffect !== null) {
                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
              }
              returnFiber.lastEffect = workInProgress.lastEffect;
            }







            var effectTag = workInProgress.effectTag;


            if (effectTag > PerformedWork) {
              if (returnFiber.lastEffect !== null) {
                returnFiber.lastEffect.nextEffect = workInProgress;
              } else {
                returnFiber.firstEffect = workInProgress;
              }
              returnFiber.lastEffect = workInProgress;
            }
          }

          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
          }

          if (siblingFiber !== null) {

            return siblingFiber;
          } else if (returnFiber !== null) {

            workInProgress = returnFiber;
            continue;
          } else {

            return null;
          }
        } else {
          if (workInProgress.mode & ProfileMode) {

            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
          }




          var _next = unwindWork(workInProgress, nextRenderExpirationTime);

          if (workInProgress.effectTag & DidCapture) {

            stopFailedWorkTimer(workInProgress);
          } else {
            stopWorkTimer(workInProgress);
          }

          {
            resetCurrentFiber();
          }

          if (_next !== null) {
            stopWorkTimer(workInProgress);
            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (enableProfilerTimer) {

              if (_next.mode & ProfileMode) {
                var actualDuration = _next.actualDuration;
                var child = _next.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                _next.actualDuration = actualDuration;
              }
            }





            _next.effectTag &= HostEffectMask;
            return _next;
          }

          if (returnFiber !== null) {

            returnFiber.firstEffect = returnFiber.lastEffect = null;
            returnFiber.effectTag |= Incomplete;
          }

          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
          }

          if (siblingFiber !== null) {

            return siblingFiber;
          } else if (returnFiber !== null) {

            workInProgress = returnFiber;
            continue;
          } else {
            return null;
          }
        }
      }




      return null;
    }

    function performUnitOfWork(workInProgress) {




      var current$$1 = workInProgress.alternate;


      startWorkTimer(workInProgress);
      {
        setCurrentFiber(workInProgress);
      }

      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        stashedWorkInProgressProperties = assignFiberPropertiesInDEV(
        stashedWorkInProgressProperties,
        workInProgress);

      }

      var next = void 0;
      if (enableProfilerTimer) {
        if (workInProgress.mode & ProfileMode) {
          startProfilerTimer(workInProgress);
        }

        next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);

        if (workInProgress.mode & ProfileMode) {

          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
        }
      } else {
        next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
      }

      {
        resetCurrentFiber();
        if (isReplayingFailedUnitOfWork) {




          rethrowOriginalError();
        }
      }
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
      }

      if (next === null) {

        next = completeUnitOfWork(workInProgress);
      }

      ReactCurrentOwner$2.current = null;

      return next;
    }

    function workLoop(isYieldy) {
      if (!isYieldy) {

        while (nextUnitOfWork !== null) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      } else {

        while (nextUnitOfWork !== null && !shouldYield()) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }

    function renderRoot(root, isYieldy, isExpired) {
      invariant(
      !isWorking,
      "renderRoot was called recursively. This error is likely caused " +
      "by a bug in React. Please file an issue.");

      isWorking = true;
      ReactCurrentOwner$2.currentDispatcher = Dispatcher;

      var expirationTime = root.nextExpirationTimeToWorkOn;

      var prevInteractions = null;
      if (enableSchedulerTracking) {


        prevInteractions = tracking.__interactionsRef.current;
        tracking.__interactionsRef.current = root.memoizedInteractions;
      }



      if (
      expirationTime !== nextRenderExpirationTime ||
      root !== nextRoot ||
      nextUnitOfWork === null)
      {

        resetStack();
        nextRoot = root;
        nextRenderExpirationTime = expirationTime;
        nextUnitOfWork = createWorkInProgress(
        nextRoot.current,
        null,
        nextRenderExpirationTime);

        root.pendingCommitExpirationTime = NoWork;

        if (enableSchedulerTracking) {


          var interactions = new Set();
          root.pendingInteractionMap.forEach(function (
          scheduledInteractions,
          scheduledExpirationTime)
          {
            if (scheduledExpirationTime <= expirationTime) {
              scheduledInteractions.forEach(function (interaction) {
                return interactions.add(interaction);
              });
            }
          });





          root.memoizedInteractions = interactions;

          if (interactions.size > 0) {
            var subscriber = tracking.__subscriberRef.current;
            if (subscriber !== null) {
              var threadID = computeThreadID(
              expirationTime,
              root.interactionThreadID);

              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error) {



                if (!hasUnhandledError) {
                  hasUnhandledError = true;
                  unhandledError = error;
                }
              }
            }
          }
        }
      }

      var didFatal = false;

      startWorkLoopTimer(nextUnitOfWork);

      do {
        try {
          workLoop(isYieldy);
        } catch (thrownValue) {
          if (nextUnitOfWork === null) {

            didFatal = true;
            onUncaughtError(thrownValue);
          } else {
            {


              resetCurrentlyProcessingQueue();
            }

            var failedUnitOfWork = nextUnitOfWork;
            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
            }




            invariant(
            nextUnitOfWork !== null,
            "Failed to replay rendering after an error. This " +
            "is likely caused by a bug in React. Please file an issue " +
            "with a reproducing case to help us find it.");


            var sourceFiber = nextUnitOfWork;
            var returnFiber = sourceFiber.return;
            if (returnFiber === null) {






              didFatal = true;
              onUncaughtError(thrownValue);
            } else {
              throwException(
              root,
              returnFiber,
              sourceFiber,
              thrownValue,
              nextRenderExpirationTime);

              nextUnitOfWork = completeUnitOfWork(sourceFiber);
              continue;
            }
          }
        }
        break;
      } while (true);

      if (enableSchedulerTracking) {

        tracking.__interactionsRef.current = prevInteractions;
      }


      isWorking = false;
      ReactCurrentOwner$2.currentDispatcher = null;
      resetContextDependences();


      if (didFatal) {
        var _didCompleteRoot = false;
        stopWorkLoopTimer(interruptedBy, _didCompleteRoot);
        interruptedBy = null;

        {
          resetStackAfterFatalErrorInDev();
        }



        nextRoot = null;
        onFatal(root);
        return;
      }

      if (nextUnitOfWork !== null) {




        var _didCompleteRoot2 = false;
        stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);
        interruptedBy = null;
        onYield(root);
        return;
      }


      var didCompleteRoot = true;
      stopWorkLoopTimer(interruptedBy, didCompleteRoot);
      var rootWorkInProgress = root.current.alternate;
      invariant(
      rootWorkInProgress !== null,
      "Finished root should have a work-in-progress. This error is likely " +
      "caused by a bug in React. Please file an issue.");





      nextRoot = null;
      interruptedBy = null;

      if (nextRenderDidError) {

        if (hasLowerPriorityWork(root, expirationTime)) {





          markSuspendedPriorityLevel(root, expirationTime);
          var suspendedExpirationTime = expirationTime;
          var rootExpirationTime = root.expirationTime;
          onSuspend(
          root,
          rootWorkInProgress,
          suspendedExpirationTime,
          rootExpirationTime,
          -1);

          return;
        } else if (




        !root.didError &&
        !isExpired)
        {
          root.didError = true;
          var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;
          var _rootExpirationTime = root.expirationTime = Sync;
          onSuspend(
          root,
          rootWorkInProgress,
          _suspendedExpirationTime,
          _rootExpirationTime,
          -1);

          return;
        }
      }

      if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {

        var _suspendedExpirationTime2 = expirationTime;
        markSuspendedPriorityLevel(root, _suspendedExpirationTime2);




        var earliestExpirationTime = findEarliestOutstandingPriorityLevel(
        root,
        expirationTime);

        var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
        if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
          nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
        }





        var currentTimeMs = expirationTimeToMs(requestCurrentTime());
        var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
        msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;



        var _rootExpirationTime2 = root.expirationTime;
        onSuspend(
        root,
        rootWorkInProgress,
        _suspendedExpirationTime2,
        _rootExpirationTime2,
        msUntilTimeout);

        return;
      }


      onComplete(root, rootWorkInProgress, expirationTime);
    }

    function dispatch(sourceFiber, value, expirationTime) {
      invariant(
      !isWorking || isCommitting$1,
      "dispatch: Cannot dispatch during the render phase.");


      var fiber = sourceFiber.return;
      while (fiber !== null) {
        switch (fiber.tag) {
          case ClassComponent:
          case ClassComponentLazy:
            var ctor = fiber.type;
            var instance = fiber.stateNode;
            if (
            typeof ctor.getDerivedStateFromCatch === "function" ||
            typeof instance.componentDidCatch === "function" &&
            !isAlreadyFailedLegacyErrorBoundary(instance))
            {
              var errorInfo = createCapturedValue(value, sourceFiber);
              var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);
              enqueueUpdate(fiber, update);
              scheduleWork(fiber, expirationTime);
              return;
            }
            break;
          case HostRoot:{
              var _errorInfo = createCapturedValue(value, sourceFiber);
              var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);
              enqueueUpdate(fiber, _update);
              scheduleWork(fiber, expirationTime);
              return;
            }}

        fiber = fiber.return;
      }

      if (sourceFiber.tag === HostRoot) {


        var rootFiber = sourceFiber;
        var _errorInfo2 = createCapturedValue(value, rootFiber);
        var _update2 = createRootErrorUpdate(
        rootFiber,
        _errorInfo2,
        expirationTime);

        enqueueUpdate(rootFiber, _update2);
        scheduleWork(rootFiber, expirationTime);
      }
    }

    function captureCommitPhaseError(fiber, error) {
      return dispatch(fiber, error, Sync);
    }

    function computeThreadID(expirationTime, interactionThreadID) {

      return expirationTime * 1000 + interactionThreadID;
    }

    function computeExpirationForFiber(currentTime, fiber) {
      var expirationTime = void 0;
      if (expirationContext !== NoWork) {

        expirationTime = expirationContext;
      } else if (isWorking) {
        if (isCommitting$1) {


          expirationTime = Sync;
        } else {


          expirationTime = nextRenderExpirationTime;
        }
      } else {


        if (fiber.mode & AsyncMode) {
          if (isBatchingInteractiveUpdates) {

            expirationTime = computeInteractiveExpiration(currentTime);
          } else {

            expirationTime = computeAsyncExpiration(currentTime);
          }


          if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
            expirationTime += 1;
          }
        } else {

          expirationTime = Sync;
        }
      }
      if (isBatchingInteractiveUpdates) {



        if (
        lowestPriorityPendingInteractiveExpirationTime === NoWork ||
        expirationTime > lowestPriorityPendingInteractiveExpirationTime)
        {
          lowestPriorityPendingInteractiveExpirationTime = expirationTime;
        }
      }
      return expirationTime;
    }

    function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {

      if (
      absoluteTimeoutMs >= 0 &&
      nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs)
      {
        nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
      }
    }

    function renderDidError() {
      nextRenderDidError = true;
    }

    function retrySuspendedRoot(root, fiber, suspendedTime) {
      if (enableSuspense) {
        var retryTime = void 0;

        if (isPriorityLevelSuspended(root, suspendedTime)) {

          retryTime = suspendedTime;
          markPingedPriorityLevel(root, retryTime);
        } else {

          var currentTime = requestCurrentTime();
          retryTime = computeExpirationForFiber(currentTime, fiber);
          markPendingPriorityLevel(root, retryTime);
        }

        scheduleWorkToRoot(fiber, retryTime);
        var rootExpirationTime = root.expirationTime;
        if (rootExpirationTime !== NoWork) {
          if (enableSchedulerTracking) {

            var prevInteractions = tracking.__interactionsRef.current;
            tracking.__interactionsRef.current = root.memoizedInteractions;


            storeInteractionsForExpirationTime(root, rootExpirationTime, false);
            requestWork(root, rootExpirationTime);
            tracking.__interactionsRef.current = prevInteractions;
          } else {
            requestWork(root, rootExpirationTime);
          }
        }
      }
    }

    function scheduleWorkToRoot(fiber, expirationTime) {

      if (
      fiber.expirationTime === NoWork ||
      fiber.expirationTime > expirationTime)
      {
        fiber.expirationTime = expirationTime;
      }
      var alternate = fiber.alternate;
      if (
      alternate !== null && (
      alternate.expirationTime === NoWork ||
      alternate.expirationTime > expirationTime))
      {
        alternate.expirationTime = expirationTime;
      }

      var node = fiber.return;
      if (node === null && fiber.tag === HostRoot) {
        return fiber.stateNode;
      }
      while (node !== null) {
        alternate = node.alternate;
        if (
        node.childExpirationTime === NoWork ||
        node.childExpirationTime > expirationTime)
        {
          node.childExpirationTime = expirationTime;
          if (
          alternate !== null && (
          alternate.childExpirationTime === NoWork ||
          alternate.childExpirationTime > expirationTime))
          {
            alternate.childExpirationTime = expirationTime;
          }
        } else if (
        alternate !== null && (
        alternate.childExpirationTime === NoWork ||
        alternate.childExpirationTime > expirationTime))
        {
          alternate.childExpirationTime = expirationTime;
        }
        if (node.return === null && node.tag === HostRoot) {
          return node.stateNode;
        }
        node = node.return;
      }
      return null;
    }

    function storeInteractionsForExpirationTime(
    root,
    expirationTime,
    updateInteractionCounts)
    {
      if (!enableSchedulerTracking) {
        return;
      }

      var interactions = tracking.__interactionsRef.current;
      if (interactions.size > 0) {
        var pendingInteractions = root.pendingInteractionMap.get(expirationTime);
        if (pendingInteractions != null) {
          interactions.forEach(function (interaction) {
            if (updateInteractionCounts && !pendingInteractions.has(interaction)) {

              interaction.__count++;
            }

            pendingInteractions.add(interaction);
          });
        } else {
          root.pendingInteractionMap.set(expirationTime, new Set(interactions));


          if (updateInteractionCounts) {
            interactions.forEach(function (interaction) {
              interaction.__count++;
            });
          }
        }

        var subscriber = tracking.__subscriberRef.current;
        if (subscriber !== null) {
          var threadID = computeThreadID(expirationTime, root.interactionThreadID);
          subscriber.onWorkScheduled(interactions, threadID);
        }
      }
    }

    function scheduleWork(fiber, expirationTime) {
      recordScheduleUpdate();

      {
        if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {
          var instance = fiber.stateNode;
          warnAboutInvalidUpdates(instance);
        }
      }

      var root = scheduleWorkToRoot(fiber, expirationTime);
      if (root === null) {
        if (
        true && (
        fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy))
        {
          warnAboutUpdateOnUnmounted(fiber);
        }
        return;
      }

      if (enableSchedulerTracking) {
        storeInteractionsForExpirationTime(root, expirationTime, true);
      }

      if (
      !isWorking &&
      nextRenderExpirationTime !== NoWork &&
      expirationTime < nextRenderExpirationTime)
      {

        interruptedBy = fiber;
        resetStack();
      }
      markPendingPriorityLevel(root, expirationTime);
      if (


      !isWorking ||
      isCommitting$1 ||

      nextRoot !== root)
      {
        var rootExpirationTime = root.expirationTime;
        requestWork(root, rootExpirationTime);
      }
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {

        nestedUpdateCount = 0;
        invariant(
        false,
        "Maximum update depth exceeded. This can happen when a " +
        "component repeatedly calls setState inside " +
        "componentWillUpdate or componentDidUpdate. React limits " +
        "the number of nested updates to prevent infinite loops.");

      }
    }





    var firstScheduledRoot = null;
    var lastScheduledRoot = null;

    var callbackExpirationTime = NoWork;
    var callbackID = void 0;
    var isRendering = false;
    var nextFlushedRoot = null;
    var nextFlushedExpirationTime = NoWork;
    var lowestPriorityPendingInteractiveExpirationTime = NoWork;
    var deadlineDidExpire = false;
    var hasUnhandledError = false;
    var unhandledError = null;
    var deadline = null;

    var isBatchingUpdates = false;
    var isUnbatchingUpdates = false;
    var isBatchingInteractiveUpdates = false;

    var completedBatches = null;

    var originalStartTimeMs = now();
    var currentRendererTime = msToExpirationTime(originalStartTimeMs);
    var currentSchedulerTime = currentRendererTime;


    var NESTED_UPDATE_LIMIT = 50;
    var nestedUpdateCount = 0;
    var lastCommittedRootDuringThisBatch = null;

    var timeHeuristicForUnitOfWork = 1;

    function recomputeCurrentRendererTime() {
      var currentTimeMs = now() - originalStartTimeMs;
      currentRendererTime = msToExpirationTime(currentTimeMs);
    }

    function scheduleCallbackWithExpirationTime(root, expirationTime) {
      if (callbackExpirationTime !== NoWork) {

        if (expirationTime > callbackExpirationTime) {

          return;
        } else {
          if (callbackID !== null) {


            cancelDeferredCallback(callbackID);
          }
        }

      } else {
        startRequestCallbackTimer();
      }

      callbackExpirationTime = expirationTime;
      var currentMs = now() - originalStartTimeMs;
      var expirationTimeMs = expirationTimeToMs(expirationTime);
      var timeout = expirationTimeMs - currentMs;
      callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
    }





    function onFatal(root) {
      root.finishedWork = null;
    }

    function onComplete(root, finishedWork, expirationTime) {
      root.pendingCommitExpirationTime = expirationTime;
      root.finishedWork = finishedWork;
    }

    function onSuspend(
    root,
    finishedWork,
    suspendedExpirationTime,
    rootExpirationTime,
    msUntilTimeout)
    {
      root.expirationTime = rootExpirationTime;
      if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {

        root.pendingCommitExpirationTime = suspendedExpirationTime;
        root.finishedWork = finishedWork;
      } else if (msUntilTimeout > 0) {

        root.timeoutHandle = scheduleTimeout(
        onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),
        msUntilTimeout);

      }
    }

    function onYield(root) {
      root.finishedWork = null;
    }

    function onTimeout(root, finishedWork, suspendedExpirationTime) {
      if (enableSuspense) {

        root.pendingCommitExpirationTime = suspendedExpirationTime;
        root.finishedWork = finishedWork;



        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;

        if (enableSchedulerTracking) {


          suspenseDidTimeout = true;
          flushRoot(root, suspendedExpirationTime);
          suspenseDidTimeout = false;
        } else {
          flushRoot(root, suspendedExpirationTime);
        }
      }
    }

    function onCommit(root, expirationTime) {
      root.expirationTime = expirationTime;
      root.finishedWork = null;
    }

    function requestCurrentTime() {



















      if (isRendering) {

        return currentSchedulerTime;
      }

      findHighestPriorityRoot();
      if (
      nextFlushedExpirationTime === NoWork ||
      nextFlushedExpirationTime === Never)
      {


        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;
        return currentSchedulerTime;
      }





      return currentSchedulerTime;
    }



    function requestWork(root, expirationTime) {
      addRootToSchedule(root, expirationTime);
      if (isRendering) {


        return;
      }

      if (isBatchingUpdates) {

        if (isUnbatchingUpdates) {


          nextFlushedRoot = root;
          nextFlushedExpirationTime = Sync;
          performWorkOnRoot(root, Sync, true);
        }
        return;
      }


      if (expirationTime === Sync) {
        performSyncWork();
      } else {
        scheduleCallbackWithExpirationTime(root, expirationTime);
      }
    }

    function addRootToSchedule(root, expirationTime) {


      if (root.nextScheduledRoot === null) {

        root.expirationTime = expirationTime;
        if (lastScheduledRoot === null) {
          firstScheduledRoot = lastScheduledRoot = root;
          root.nextScheduledRoot = root;
        } else {
          lastScheduledRoot.nextScheduledRoot = root;
          lastScheduledRoot = root;
          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
        }
      } else {

        var remainingExpirationTime = root.expirationTime;
        if (
        remainingExpirationTime === NoWork ||
        expirationTime < remainingExpirationTime)
        {

          root.expirationTime = expirationTime;
        }
      }
    }

    function findHighestPriorityRoot() {
      var highestPriorityWork = NoWork;
      var highestPriorityRoot = null;
      if (lastScheduledRoot !== null) {
        var previousScheduledRoot = lastScheduledRoot;
        var root = firstScheduledRoot;
        while (root !== null) {
          var remainingExpirationTime = root.expirationTime;
          if (remainingExpirationTime === NoWork) {





            invariant(
            previousScheduledRoot !== null && lastScheduledRoot !== null,
            "Should have a previous and last root. This error is likely " +
            "caused by a bug in React. Please file an issue.");

            if (root === root.nextScheduledRoot) {

              root.nextScheduledRoot = null;
              firstScheduledRoot = lastScheduledRoot = null;
              break;
            } else if (root === firstScheduledRoot) {

              var next = root.nextScheduledRoot;
              firstScheduledRoot = next;
              lastScheduledRoot.nextScheduledRoot = next;
              root.nextScheduledRoot = null;
            } else if (root === lastScheduledRoot) {

              lastScheduledRoot = previousScheduledRoot;
              lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
              root.nextScheduledRoot = null;
              break;
            } else {
              previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
              root.nextScheduledRoot = null;
            }
            root = previousScheduledRoot.nextScheduledRoot;
          } else {
            if (
            highestPriorityWork === NoWork ||
            remainingExpirationTime < highestPriorityWork)
            {

              highestPriorityWork = remainingExpirationTime;
              highestPriorityRoot = root;
            }
            if (root === lastScheduledRoot) {
              break;
            }
            if (highestPriorityWork === Sync) {


              break;
            }
            previousScheduledRoot = root;
            root = root.nextScheduledRoot;
          }
        }
      }

      nextFlushedRoot = highestPriorityRoot;
      nextFlushedExpirationTime = highestPriorityWork;
    }

    function performAsyncWork(dl) {
      if (dl.didTimeout) {





        if (firstScheduledRoot !== null) {
          recomputeCurrentRendererTime();
          var root = firstScheduledRoot;
          do {
            didExpireAtExpirationTime(root, currentRendererTime);

            root = root.nextScheduledRoot;
          } while (root !== firstScheduledRoot);
        }
      }
      performWork(NoWork, dl);
    }

    function performSyncWork() {
      performWork(Sync, null);
    }

    function performWork(minExpirationTime, dl) {
      deadline = dl;



      findHighestPriorityRoot();

      if (deadline !== null) {
        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;

        if (enableUserTimingAPI) {
          var didExpire = nextFlushedExpirationTime < currentRendererTime;
          var timeout = expirationTimeToMs(nextFlushedExpirationTime);
          stopRequestCallbackTimer(didExpire, timeout);
        }

        while (
        nextFlushedRoot !== null &&
        nextFlushedExpirationTime !== NoWork && (
        minExpirationTime === NoWork ||
        minExpirationTime >= nextFlushedExpirationTime) && (
        !deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime))
        {
          performWorkOnRoot(
          nextFlushedRoot,
          nextFlushedExpirationTime,
          currentRendererTime >= nextFlushedExpirationTime);

          findHighestPriorityRoot();
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;
        }
      } else {
        while (
        nextFlushedRoot !== null &&
        nextFlushedExpirationTime !== NoWork && (
        minExpirationTime === NoWork ||
        minExpirationTime >= nextFlushedExpirationTime))
        {
          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);
          findHighestPriorityRoot();
        }
      }





      if (deadline !== null) {
        callbackExpirationTime = NoWork;
        callbackID = null;
      }

      if (nextFlushedExpirationTime !== NoWork) {
        scheduleCallbackWithExpirationTime(
        nextFlushedRoot,
        nextFlushedExpirationTime);

      }


      deadline = null;
      deadlineDidExpire = false;

      finishRendering();
    }

    function flushRoot(root, expirationTime) {
      invariant(
      !isRendering,
      "work.commit(): Cannot commit while already rendering. This likely " +
      "means you attempted to commit from inside a lifecycle method.");




      nextFlushedRoot = root;
      nextFlushedExpirationTime = expirationTime;
      performWorkOnRoot(root, expirationTime, true);

      performSyncWork();
    }

    function finishRendering() {
      nestedUpdateCount = 0;
      lastCommittedRootDuringThisBatch = null;

      if (completedBatches !== null) {
        var batches = completedBatches;
        completedBatches = null;
        for (var i = 0; i < batches.length; i++) {
          var batch = batches[i];
          try {
            batch._onComplete();
          } catch (error) {
            if (!hasUnhandledError) {
              hasUnhandledError = true;
              unhandledError = error;
            }
          }
        }
      }

      if (hasUnhandledError) {
        var error = unhandledError;
        unhandledError = null;
        hasUnhandledError = false;
        throw error;
      }
    }

    function performWorkOnRoot(root, expirationTime, isExpired) {
      invariant(
      !isRendering,
      "performWorkOnRoot was called recursively. This error is likely caused " +
      "by a bug in React. Please file an issue.");


      isRendering = true;


      if (deadline === null || isExpired) {





        var finishedWork = root.finishedWork;
        if (finishedWork !== null) {

          completeRoot(root, finishedWork, expirationTime);
        } else {
          root.finishedWork = null;


          var timeoutHandle = root.timeoutHandle;
          if (enableSuspense && timeoutHandle !== noTimeout) {
            root.timeoutHandle = noTimeout;

            cancelTimeout(timeoutHandle);
          }
          var isYieldy = false;
          renderRoot(root, isYieldy, isExpired);
          finishedWork = root.finishedWork;
          if (finishedWork !== null) {

            completeRoot(root, finishedWork, expirationTime);
          }
        }
      } else {

        var _finishedWork = root.finishedWork;
        if (_finishedWork !== null) {

          completeRoot(root, _finishedWork, expirationTime);
        } else {
          root.finishedWork = null;


          var _timeoutHandle = root.timeoutHandle;
          if (enableSuspense && _timeoutHandle !== noTimeout) {
            root.timeoutHandle = noTimeout;

            cancelTimeout(_timeoutHandle);
          }
          var _isYieldy = true;
          renderRoot(root, _isYieldy, isExpired);
          _finishedWork = root.finishedWork;
          if (_finishedWork !== null) {


            if (!shouldYield()) {

              completeRoot(root, _finishedWork, expirationTime);
            } else {


              root.finishedWork = _finishedWork;
            }
          }
        }
      }

      isRendering = false;
    }

    function completeRoot(root, finishedWork, expirationTime) {

      var firstBatch = root.firstBatch;
      if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {
        if (completedBatches === null) {
          completedBatches = [firstBatch];
        } else {
          completedBatches.push(firstBatch);
        }
        if (firstBatch._defer) {


          root.finishedWork = finishedWork;
          root.expirationTime = NoWork;
          return;
        }
      }


      root.finishedWork = null;



      if (root === lastCommittedRootDuringThisBatch) {


        nestedUpdateCount++;
      } else {

        lastCommittedRootDuringThisBatch = root;
        nestedUpdateCount = 0;
      }
      commitRoot(root, finishedWork);
    }



    function shouldYield() {
      if (deadlineDidExpire) {
        return true;
      }
      if (
      deadline === null ||
      deadline.timeRemaining() > timeHeuristicForUnitOfWork)
      {


        return false;
      }
      deadlineDidExpire = true;
      return true;
    }

    function onUncaughtError(error) {
      invariant(
      nextFlushedRoot !== null,
      "Should be working on a root. This error is likely caused by a bug in " +
      "React. Please file an issue.");



      nextFlushedRoot.expirationTime = NoWork;
      if (!hasUnhandledError) {
        hasUnhandledError = true;
        unhandledError = error;
      }
    }



    function batchedUpdates$1(fn, a) {
      var previousIsBatchingUpdates = isBatchingUpdates;
      isBatchingUpdates = true;
      try {
        return fn(a);
      } finally {
        isBatchingUpdates = previousIsBatchingUpdates;
        if (!isBatchingUpdates && !isRendering) {
          performSyncWork();
        }
      }
    }

    function interactiveUpdates$1(fn, a, b) {
      if (isBatchingInteractiveUpdates) {
        return fn(a, b);
      }




      if (
      !isBatchingUpdates &&
      !isRendering &&
      lowestPriorityPendingInteractiveExpirationTime !== NoWork)
      {

        performWork(lowestPriorityPendingInteractiveExpirationTime, null);
        lowestPriorityPendingInteractiveExpirationTime = NoWork;
      }
      var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;
      var previousIsBatchingUpdates = isBatchingUpdates;
      isBatchingInteractiveUpdates = true;
      isBatchingUpdates = true;
      try {
        return fn(a, b);
      } finally {
        isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;
        isBatchingUpdates = previousIsBatchingUpdates;
        if (!isBatchingUpdates && !isRendering) {
          performSyncWork();
        }
      }
    }

    function flushInteractiveUpdates$1() {
      if (
      !isRendering &&
      lowestPriorityPendingInteractiveExpirationTime !== NoWork)
      {

        performWork(lowestPriorityPendingInteractiveExpirationTime, null);
        lowestPriorityPendingInteractiveExpirationTime = NoWork;
      }
    }




    var didWarnAboutNestedUpdates = void 0;

    {
      didWarnAboutNestedUpdates = false;
    }

    function getContextForSubtree(parentComponent) {
      if (!parentComponent) {
        return emptyContextObject;
      }

      var fiber = get$1(parentComponent);
      var parentContext = findCurrentUnmaskedContext(fiber);

      if (fiber.tag === ClassComponent) {
        var Component = fiber.type;
        if (isContextProvider(Component)) {
          return processChildContext(fiber, Component, parentContext);
        }
      } else if (fiber.tag === ClassComponentLazy) {
        var _Component = getResultFromResolvedThenable(fiber.type);
        if (isContextProvider(_Component)) {
          return processChildContext(fiber, _Component, parentContext);
        }
      }

      return parentContext;
    }

    function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
      {
        if (phase === "render" && current !== null && !didWarnAboutNestedUpdates) {
          didWarnAboutNestedUpdates = true;
          warningWithoutStack$1(
          false,
          "Render methods should be a pure function of props and state; " +
          "triggering nested component updates from render is not allowed. " +
          "If necessary, trigger nested updates in componentDidUpdate.\n\n" +
          "Check the render method of %s.",
          getComponentName(current.type) || "Unknown");

        }
      }

      var update = createUpdate(expirationTime);


      update.payload = { element: element };

      callback = callback === undefined ? null : callback;
      if (callback !== null) {
        !(typeof callback === "function") ?
        warningWithoutStack$1(
        false,
        "render(...): Expected the last optional `callback` argument to be a " +
        "function. Instead received: %s.",
        callback) :

        void 0;
        update.callback = callback;
      }
      enqueueUpdate(current$$1, update);

      scheduleWork(current$$1, expirationTime);
      return expirationTime;
    }

    function updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback)
    {

      var current$$1 = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current$$1.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      return scheduleRootUpdate(current$$1, element, expirationTime, callback);
    }

    function findHostInstance$1(component) {
      var fiber = get$1(component);
      if (fiber === undefined) {
        if (typeof component.render === "function") {
          invariant(false, "Unable to find node on an unmounted component.");
        } else {
          invariant(
          false,
          "Argument appears to not be a ReactComponent. Keys: %s",
          Object.keys(component));

        }
      }
      var hostFiber = findCurrentHostFiber(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    }

    function createContainer(containerInfo, isAsync, hydrate) {
      return createFiberRoot(containerInfo, isAsync, hydrate);
    }

    function updateContainer(element, container, parentComponent, callback) {
      var current$$1 = container.current;
      var currentTime = requestCurrentTime();
      var expirationTime = computeExpirationForFiber(currentTime, current$$1);
      return updateContainerAtExpirationTime(
      element,
      container,
      parentComponent,
      expirationTime,
      callback);

    }

    function getPublicRootInstance(container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;}

    }

    function injectIntoDevTools(devToolsConfig) {
      var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(
      _extends({}, devToolsConfig, {
        findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        },
        findFiberByHostInstance: function findFiberByHostInstance(instance) {
          if (!_findFiberByHostInstance) {

            return null;
          }
          return _findFiberByHostInstance(instance);
        } }));


    }




    function _createPortal(
    children,
    containerInfo,

    implementation)
    {
      var key =
      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      return {

        $$typeof: REACT_PORTAL_TYPE,
        key: key == null ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation };

    }



    var ReactVersion = "16.5.0";


    var NativeMethodsMixin = function NativeMethodsMixin(findNodeHandle, findHostInstance) {















      var NativeMethodsMixin = {

















        measure: function measure(callback) {
          UIManager.measure(
          findNodeHandle(this),
          mountSafeCallback_NOT_REALLY_SAFE(this, callback));

        },
















        measureInWindow: function measureInWindow(callback) {
          UIManager.measureInWindow(
          findNodeHandle(this),
          mountSafeCallback_NOT_REALLY_SAFE(this, callback));

        },









        measureLayout: function measureLayout(
        relativeToNativeNode,
        onSuccess,
        onFail)
        {
          UIManager.measureLayout(
          findNodeHandle(this),
          relativeToNativeNode,
          mountSafeCallback_NOT_REALLY_SAFE(this, onFail),
          mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));

        },







        setNativeProps: function setNativeProps(nativeProps) {





          var maybeInstance = void 0;





          try {
            maybeInstance = findHostInstance(this);
          } catch (error) {}



          if (maybeInstance == null) {
            return;
          }

          var viewConfig = maybeInstance.viewConfig;

          {
            warnForStyleProps(nativeProps, viewConfig.validAttributes);
          }

          var updatePayload = create(nativeProps, viewConfig.validAttributes);




          if (updatePayload != null) {
            UIManager.updateView(
            maybeInstance._nativeTag,
            viewConfig.uiViewClassName,
            updatePayload);

          }
        },





        focus: function focus() {
          TextInputState.focusTextInput(findNodeHandle(this));
        },




        blur: function blur() {
          TextInputState.blurTextInput(findNodeHandle(this));
        } };


      {



        var NativeMethodsMixin_DEV = NativeMethodsMixin;
        invariant(
        !NativeMethodsMixin_DEV.componentWillMount &&
        !NativeMethodsMixin_DEV.componentWillReceiveProps &&
        !NativeMethodsMixin_DEV.UNSAFE_componentWillMount &&
        !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps,
        "Do not override existing functions.");



        NativeMethodsMixin_DEV.componentWillMount = function () {
          throwOnStylesProp(this, this.props);
        };
        NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {
          throwOnStylesProp(this, newProps);
        };
        NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function () {
          throwOnStylesProp(this, this.props);
        };
        NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function (
        newProps)
        {
          throwOnStylesProp(this, newProps);
        };




        NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;
        NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;
      }

      return NativeMethodsMixin;
    };

    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called");

      }
      return call && (typeof call === "object" || typeof call === "function") ?
      call :
      self;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
        "Super expression must either be null or a function, not " +
        typeof superClass);

      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true } });


      if (superClass)
      Object.setPrototypeOf ?
      Object.setPrototypeOf(subClass, superClass) :
      subClass.__proto__ = superClass;
    }


    var ReactNativeComponent = function ReactNativeComponent(findNodeHandle, findHostInstance) {











      var ReactNativeComponent = function (_React$Component) {
        _inherits(ReactNativeComponent, _React$Component);

        function ReactNativeComponent() {
          _classCallCheck$1(this, ReactNativeComponent);

          return _possibleConstructorReturn(
          this,
          _React$Component.apply(this, arguments));

        }









        ReactNativeComponent.prototype.blur = function blur() {
          TextInputState.blurTextInput(findNodeHandle(this));
        };





        ReactNativeComponent.prototype.focus = function focus() {
          TextInputState.focusTextInput(findNodeHandle(this));
        };

















        ReactNativeComponent.prototype.measure = function measure(callback) {
          UIManager.measure(
          findNodeHandle(this),
          mountSafeCallback_NOT_REALLY_SAFE(this, callback));

        };















        ReactNativeComponent.prototype.measureInWindow = function measureInWindow(
        callback)
        {
          UIManager.measureInWindow(
          findNodeHandle(this),
          mountSafeCallback_NOT_REALLY_SAFE(this, callback));

        };








        ReactNativeComponent.prototype.measureLayout = function measureLayout(
        relativeToNativeNode,
        onSuccess,
        onFail)
        {
          UIManager.measureLayout(
          findNodeHandle(this),
          relativeToNativeNode,
          mountSafeCallback_NOT_REALLY_SAFE(this, onFail),
          mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));

        };








        ReactNativeComponent.prototype.setNativeProps = function setNativeProps(
        nativeProps)
        {





          var maybeInstance = void 0;





          try {
            maybeInstance = findHostInstance(this);
          } catch (error) {}



          if (maybeInstance == null) {
            return;
          }

          var viewConfig =
          maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;

          var updatePayload = create(nativeProps, viewConfig.validAttributes);




          if (updatePayload != null) {
            UIManager.updateView(
            maybeInstance._nativeTag,
            viewConfig.uiViewClassName,
            updatePayload);

          }
        };

        return ReactNativeComponent;
      }(React.Component);



      return ReactNativeComponent;
    };


    var emptyObject$2 = {};
    {
      Object.freeze(emptyObject$2);
    }

    var getInspectorDataForViewTag = void 0;

    {
      var traverseOwnerTreeUp = function traverseOwnerTreeUp(hierarchy, instance) {
        if (instance) {
          hierarchy.unshift(instance);
          traverseOwnerTreeUp(hierarchy, instance._debugOwner);
        }
      };

      var getOwnerHierarchy = function getOwnerHierarchy(instance) {
        var hierarchy = [];
        traverseOwnerTreeUp(hierarchy, instance);
        return hierarchy;
      };

      var lastNonHostInstance = function lastNonHostInstance(hierarchy) {
        for (var i = hierarchy.length - 1; i > 1; i--) {
          var instance = hierarchy[i];

          if (instance.tag !== HostComponent) {
            return instance;
          }
        }
        return hierarchy[0];
      };

      var getHostProps = function getHostProps(fiber) {
        var host = findCurrentHostFiber(fiber);
        if (host) {
          return host.memoizedProps || emptyObject$2;
        }
        return emptyObject$2;
      };

      var getHostNode = function getHostNode(fiber, findNodeHandle) {
        var hostNode = void 0;


        while (fiber) {
          if (fiber.stateNode !== null && fiber.tag === HostComponent) {
            hostNode = findNodeHandle(fiber.stateNode);
          }
          if (hostNode) {
            return hostNode;
          }
          fiber = fiber.child;
        }
        return null;
      };

      var createHierarchy = function createHierarchy(fiberHierarchy) {
        return fiberHierarchy.map(function (fiber) {
          return {
            name: getComponentName(fiber.type),
            getInspectorData: function getInspectorData(findNodeHandle) {
              return {
                measure: function measure(callback) {
                  return UIManager.measure(
                  getHostNode(fiber, findNodeHandle),
                  callback);

                },
                props: getHostProps(fiber),
                source: fiber._debugSource };

            } };

        });
      };

      getInspectorDataForViewTag = function getInspectorDataForViewTag(viewTag) {
        var closestInstance = getInstanceFromTag(viewTag);


        if (!closestInstance) {
          return {
            hierarchy: [],
            props: emptyObject$2,
            selection: null,
            source: null };

        }

        var fiber = findCurrentFiberUsingSlowPath(closestInstance);
        var fiberHierarchy = getOwnerHierarchy(fiber);
        var instance = lastNonHostInstance(fiberHierarchy);
        var hierarchy = createHierarchy(fiberHierarchy);
        var props = getHostProps(instance);
        var source = instance._debugSource;
        var selection = fiberHierarchy.indexOf(instance);

        return {
          hierarchy: hierarchy,
          props: props,
          selection: selection,
          source: source };

      };
    }



    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var findHostInstance = findHostInstance$1;

    function findNodeHandle(componentOrHandle) {
      {
        var owner = ReactCurrentOwner.current;
        if (owner !== null && owner.stateNode !== null) {
          !owner.stateNode._warnedAboutRefsInRender ?
          warningWithoutStack$1(
          false,
          "%s is accessing findNodeHandle inside its render(). " +
          "render() should be a pure function of props and state. It should " +
          "never access something that requires stale data from the previous " +
          "render, such as refs. Move this logic to componentDidMount and " +
          "componentDidUpdate instead.",
          getComponentName(owner.type) || "A component") :

          void 0;

          owner.stateNode._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrHandle == null) {
        return null;
      }
      if (typeof componentOrHandle === "number") {

        return componentOrHandle;
      }
      if (componentOrHandle._nativeTag) {
        return componentOrHandle._nativeTag;
      }
      if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {
        return componentOrHandle.canonical._nativeTag;
      }
      var hostInstance = findHostInstance(componentOrHandle);
      if (hostInstance == null) {
        return hostInstance;
      }
      if (hostInstance.canonical) {

        return hostInstance.canonical._nativeTag;
      }
      return hostInstance._nativeTag;
    }

    setBatchingImplementation(
    batchedUpdates$1,
    interactiveUpdates$1,
    flushInteractiveUpdates$1);


    function computeComponentStackForErrorReporting(reactTag) {
      var fiber = getInstanceFromTag(reactTag);
      if (!fiber) {
        return "";
      }
      return getStackByFiberInDevAndProd(fiber);
    }

    var roots = new Map();

    var ReactNativeRenderer = {
      NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),

      findNodeHandle: findNodeHandle,

      render: function render(element, containerTag, callback) {
        var root = roots.get(containerTag);

        if (!root) {


          root = createContainer(containerTag, false, false);
          roots.set(containerTag, root);
        }
        updateContainer(element, root, null, callback);

        return getPublicRootInstance(root);
      },
      unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
        var root = roots.get(containerTag);
        if (root) {

          updateContainer(null, root, null, function () {
            roots.delete(containerTag);
          });
        }
      },
      unmountComponentAtNodeAndRemoveContainer: function unmountComponentAtNodeAndRemoveContainer(containerTag) {
        ReactNativeRenderer.unmountComponentAtNode(containerTag);


        UIManager.removeRootView(containerTag);
      },
      createPortal: function createPortal(children, containerTag) {
        var key =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        return _createPortal(children, containerTag, null, key);
      },

      unstable_batchedUpdates: batchedUpdates,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {

        NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance),
        computeComponentStackForErrorReporting: computeComponentStackForErrorReporting } };



    injectIntoDevTools({
      findFiberByHostInstance: getInstanceFromTag,
      getInspectorDataForViewTag: getInspectorDataForViewTag,
      bundleType: 1,
      version: ReactVersion,
      rendererPackageName: "react-native-renderer" });


    var ReactNativeRenderer$2 = Object.freeze({
      default: ReactNativeRenderer });


    var ReactNativeRenderer$3 =
    ReactNativeRenderer$2 && ReactNativeRenderer || ReactNativeRenderer$2;



    var reactNativeRenderer =
    ReactNativeRenderer$3.default || ReactNativeRenderer$3;

    module.exports = reactNativeRenderer;

  })();
}