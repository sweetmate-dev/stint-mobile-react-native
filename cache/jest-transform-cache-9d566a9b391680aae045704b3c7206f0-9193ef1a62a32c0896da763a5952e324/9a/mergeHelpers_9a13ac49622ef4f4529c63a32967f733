db891a77bba94e9ec860b5d2fdb40a59












'use strict';

var invariant = require('fbjs/lib/invariant');





var MAX_MERGE_DEPTH = 36;







var isTerminal = function isTerminal(o) {
  return typeof o !== 'object' || o instanceof Date || o === null;
};

var mergeHelpers = {
  MAX_MERGE_DEPTH: MAX_MERGE_DEPTH,

  isTerminal: isTerminal,







  normalizeMergeArg: function normalizeMergeArg(arg) {
    return arg === undefined || arg === null ? {} : arg;
  },









  checkMergeArrayArgs: function checkMergeArrayArgs(one, two) {
    invariant(
    Array.isArray(one) && Array.isArray(two),
    'Tried to merge arrays, instead got %s and %s.',
    one,
    two);

  },





  checkMergeObjectArgs: function checkMergeObjectArgs(one, two) {
    mergeHelpers.checkMergeObjectArg(one);
    mergeHelpers.checkMergeObjectArg(two);
  },




  checkMergeObjectArg: function checkMergeObjectArg(arg) {
    invariant(
    !isTerminal(arg) && !Array.isArray(arg),
    'Tried to merge an object, instead got %s.',
    arg);

  },




  checkMergeIntoObjectArg: function checkMergeIntoObjectArg(arg) {
    invariant(
    (!isTerminal(arg) || typeof arg === 'function') && !Array.isArray(arg),
    'Tried to merge into an object, instead got %s.',
    arg);

  },







  checkMergeLevel: function checkMergeLevel(level) {
    invariant(
    level < MAX_MERGE_DEPTH,
    'Maximum deep merge depth exceeded. You may be attempting to merge ' +
    'circular structures in an unsupported way.');

  },






  checkArrayStrategy: function checkArrayStrategy(strategy) {
    invariant(
    strategy === undefined || strategy in mergeHelpers.ArrayStrategies,
    'You must provide an array strategy to deep merge functions to ' +
    'instruct the deep merge how to resolve merging two arrays.');

  },








  ArrayStrategies: {
    Clobber: 'Clobber',
    Concat: 'Concat',
    IndexByIndex: 'IndexByIndex' } };



module.exports = mergeHelpers;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1lcmdlSGVscGVycy5qcyJdLCJuYW1lcyI6WyJpbnZhcmlhbnQiLCJyZXF1aXJlIiwiTUFYX01FUkdFX0RFUFRIIiwiaXNUZXJtaW5hbCIsIm8iLCJEYXRlIiwibWVyZ2VIZWxwZXJzIiwibm9ybWFsaXplTWVyZ2VBcmciLCJhcmciLCJ1bmRlZmluZWQiLCJjaGVja01lcmdlQXJyYXlBcmdzIiwib25lIiwidHdvIiwiQXJyYXkiLCJpc0FycmF5IiwiY2hlY2tNZXJnZU9iamVjdEFyZ3MiLCJjaGVja01lcmdlT2JqZWN0QXJnIiwiY2hlY2tNZXJnZUludG9PYmplY3RBcmciLCJjaGVja01lcmdlTGV2ZWwiLCJsZXZlbCIsImNoZWNrQXJyYXlTdHJhdGVneSIsInN0cmF0ZWd5IiwiQXJyYXlTdHJhdGVnaWVzIiwiQ2xvYmJlciIsIkNvbmNhdCIsIkluZGV4QnlJbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVlBOztBQUVBLElBQU1BLFlBQVlDLFFBQVEsb0JBQVIsQ0FBbEI7Ozs7OztBQU1BLElBQU1DLGtCQUFrQixFQUF4Qjs7Ozs7Ozs7QUFRQSxJQUFNQyxhQUFhLFNBQWJBLFVBQWEsQ0FBU0MsQ0FBVCxFQUFZO0FBQzdCLFNBQU8sT0FBT0EsQ0FBUCxLQUFhLFFBQWIsSUFBeUJBLGFBQWFDLElBQXRDLElBQThDRCxNQUFNLElBQTNEO0FBQ0QsQ0FGRDs7QUFJQSxJQUFNRSxlQUFlO0FBQ25CSixtQkFBaUJBLGVBREU7O0FBR25CQyxjQUFZQSxVQUhPOzs7Ozs7OztBQVduQkkscUJBQW1CLDJCQUFTQyxHQUFULEVBQWM7QUFDL0IsV0FBT0EsUUFBUUMsU0FBUixJQUFxQkQsUUFBUSxJQUE3QixHQUFvQyxFQUFwQyxHQUF5Q0EsR0FBaEQ7QUFDRCxHQWJrQjs7Ozs7Ozs7OztBQXVCbkJFLHVCQUFxQiw2QkFBU0MsR0FBVCxFQUFjQyxHQUFkLEVBQW1CO0FBQ3RDWjtBQUNFYSxVQUFNQyxPQUFOLENBQWNILEdBQWQsS0FBc0JFLE1BQU1DLE9BQU4sQ0FBY0YsR0FBZCxDQUR4QjtBQUVFLG1EQUZGO0FBR0VELE9BSEY7QUFJRUMsT0FKRjs7QUFNRCxHQTlCa0I7Ozs7OztBQW9DbkJHLHdCQUFzQiw4QkFBU0osR0FBVCxFQUFjQyxHQUFkLEVBQW1CO0FBQ3ZDTixpQkFBYVUsbUJBQWIsQ0FBaUNMLEdBQWpDO0FBQ0FMLGlCQUFhVSxtQkFBYixDQUFpQ0osR0FBakM7QUFDRCxHQXZDa0I7Ozs7O0FBNENuQkksdUJBQXFCLDZCQUFTUixHQUFULEVBQWM7QUFDakNSO0FBQ0UsS0FBQ0csV0FBV0ssR0FBWCxDQUFELElBQW9CLENBQUNLLE1BQU1DLE9BQU4sQ0FBY04sR0FBZCxDQUR2QjtBQUVFLCtDQUZGO0FBR0VBLE9BSEY7O0FBS0QsR0FsRGtCOzs7OztBQXVEbkJTLDJCQUF5QixpQ0FBU1QsR0FBVCxFQUFjO0FBQ3JDUjtBQUNFLEtBQUMsQ0FBQ0csV0FBV0ssR0FBWCxDQUFELElBQW9CLE9BQU9BLEdBQVAsS0FBZSxVQUFwQyxLQUFtRCxDQUFDSyxNQUFNQyxPQUFOLENBQWNOLEdBQWQsQ0FEdEQ7QUFFRSxvREFGRjtBQUdFQSxPQUhGOztBQUtELEdBN0RrQjs7Ozs7Ozs7QUFxRW5CVSxtQkFBaUIseUJBQVNDLEtBQVQsRUFBZ0I7QUFDL0JuQjtBQUNFbUIsWUFBUWpCLGVBRFY7QUFFRTtBQUNFLGdEQUhKOztBQUtELEdBM0VrQjs7Ozs7OztBQWtGbkJrQixzQkFBb0IsNEJBQVNDLFFBQVQsRUFBbUI7QUFDckNyQjtBQUNFcUIsaUJBQWFaLFNBQWIsSUFBMEJZLFlBQVlmLGFBQWFnQixlQURyRDtBQUVFO0FBQ0UsZ0VBSEo7O0FBS0QsR0F4RmtCOzs7Ozs7Ozs7QUFpR25CQSxtQkFBaUI7QUFDZkMsYUFBUyxTQURNO0FBRWZDLFlBQVEsUUFGTztBQUdmQyxrQkFBYyxjQUhDLEVBakdFLEVBQXJCOzs7O0FBd0dBQyxPQUFPQyxPQUFQLEdBQWlCckIsWUFBakIiLCJmaWxlIjoibWVyZ2VIZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKlxuICogcmVxdWlyZXNQb2x5ZmlsbHM6IEFycmF5LmlzQXJyYXlcbiAqXG4gKiBAZm9ybWF0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBNYXhpbXVtIG51bWJlciBvZiBsZXZlbHMgdG8gdHJhdmVyc2UuIFdpbGwgY2F0Y2ggY2lyY3VsYXIgc3RydWN0dXJlcy5cbiAqIEBjb25zdFxuICovXG5jb25zdCBNQVhfTUVSR0VfREVQVEggPSAzNjtcblxuLyoqXG4gKiBXZSB3b24ndCB3b3JyeSBhYm91dCBlZGdlIGNhc2VzIGxpa2UgbmV3IFN0cmluZygneCcpIG9yIG5ldyBCb29sZWFuKHRydWUpLlxuICogRnVuY3Rpb25zIGFuZCBEYXRlcyBhcmUgY29uc2lkZXJlZCB0ZXJtaW5hbHMsIGFuZCBhcnJheXMgYXJlIG5vdC5cbiAqIEBwYXJhbSB7Kn0gbyBUaGUgaXRlbS9vYmplY3QvdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWZmIHRoZSBhcmd1bWVudCBpcyBhIHRlcm1pbmFsLlxuICovXG5jb25zdCBpc1Rlcm1pbmFsID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gdHlwZW9mIG8gIT09ICdvYmplY3QnIHx8IG8gaW5zdGFuY2VvZiBEYXRlIHx8IG8gPT09IG51bGw7XG59O1xuXG5jb25zdCBtZXJnZUhlbHBlcnMgPSB7XG4gIE1BWF9NRVJHRV9ERVBUSDogTUFYX01FUkdFX0RFUFRILFxuXG4gIGlzVGVybWluYWw6IGlzVGVybWluYWwsXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIG51bGwvdW5kZWZpbmVkIHZhbHVlcyBpbnRvIGVtcHR5IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHs/T2JqZWN0PX0gYXJnIEFyZ3VtZW50IHRvIGJlIG5vcm1hbGl6ZWQgKG51bGxhYmxlIG9wdGlvbmFsKVxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cbiAgbm9ybWFsaXplTWVyZ2VBcmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwgPyB7fSA6IGFyZztcbiAgfSxcblxuICAvKipcbiAgICogSWYgbWVyZ2luZyBBcnJheXMsIGEgbWVyZ2Ugc3RyYXRlZ3kgKm11c3QqIGJlIHN1cHBsaWVkLiBJZiBub3QsIGl0IGlzXG4gICAqIGxpa2VseSB0aGUgY2FsbGVyJ3MgZmF1bHQuIElmIHRoaXMgZnVuY3Rpb24gaXMgZXZlciBjYWxsZWQgd2l0aCBhbnl0aGluZ1xuICAgKiBidXQgYG9uZWAgYW5kIGB0d29gIGJlaW5nIGBBcnJheWBzLCBpdCBpcyB0aGUgZmF1bHQgb2YgdGhlIG1lcmdlIHV0aWxpdGllcy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBvbmUgQXJyYXkgdG8gbWVyZ2UgaW50by5cbiAgICogQHBhcmFtIHsqfSB0d28gQXJyYXkgdG8gbWVyZ2UgZnJvbS5cbiAgICovXG4gIGNoZWNrTWVyZ2VBcnJheUFyZ3M6IGZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgQXJyYXkuaXNBcnJheShvbmUpICYmIEFycmF5LmlzQXJyYXkodHdvKSxcbiAgICAgICdUcmllZCB0byBtZXJnZSBhcnJheXMsIGluc3RlYWQgZ290ICVzIGFuZCAlcy4nLFxuICAgICAgb25lLFxuICAgICAgdHdvLFxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gb25lIE9iamVjdCB0byBtZXJnZSBpbnRvLlxuICAgKiBAcGFyYW0geyp9IHR3byBPYmplY3QgdG8gbWVyZ2UgZnJvbS5cbiAgICovXG4gIGNoZWNrTWVyZ2VPYmplY3RBcmdzOiBmdW5jdGlvbihvbmUsIHR3bykge1xuICAgIG1lcmdlSGVscGVycy5jaGVja01lcmdlT2JqZWN0QXJnKG9uZSk7XG4gICAgbWVyZ2VIZWxwZXJzLmNoZWNrTWVyZ2VPYmplY3RBcmcodHdvKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBhcmdcbiAgICovXG4gIGNoZWNrTWVyZ2VPYmplY3RBcmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIGludmFyaWFudChcbiAgICAgICFpc1Rlcm1pbmFsKGFyZykgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSxcbiAgICAgICdUcmllZCB0byBtZXJnZSBhbiBvYmplY3QsIGluc3RlYWQgZ290ICVzLicsXG4gICAgICBhcmcsXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBhcmdcbiAgICovXG4gIGNoZWNrTWVyZ2VJbnRvT2JqZWN0QXJnOiBmdW5jdGlvbihhcmcpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAoIWlzVGVybWluYWwoYXJnKSB8fCB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSAmJiAhQXJyYXkuaXNBcnJheShhcmcpLFxuICAgICAgJ1RyaWVkIHRvIG1lcmdlIGludG8gYW4gb2JqZWN0LCBpbnN0ZWFkIGdvdCAlcy4nLFxuICAgICAgYXJnLFxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGF0IGEgbWVyZ2Ugd2FzIG5vdCBnaXZlbiBhIGNpcmN1bGFyIG9iamVjdCBvciBhbiBvYmplY3QgdGhhdCBoYWRcbiAgICogdG9vIGdyZWF0IG9mIGRlcHRoLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gTGV2ZWwgb2YgcmVjdXJzaW9uIHRvIHZhbGlkYXRlIGFnYWluc3QgbWF4aW11bS5cbiAgICovXG4gIGNoZWNrTWVyZ2VMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBsZXZlbCA8IE1BWF9NRVJHRV9ERVBUSCxcbiAgICAgICdNYXhpbXVtIGRlZXAgbWVyZ2UgZGVwdGggZXhjZWVkZWQuIFlvdSBtYXkgYmUgYXR0ZW1wdGluZyB0byBtZXJnZSAnICtcbiAgICAgICAgJ2NpcmN1bGFyIHN0cnVjdHVyZXMgaW4gYW4gdW5zdXBwb3J0ZWQgd2F5LicsXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHRoYXQgdGhlIHN1cHBsaWVkIG1lcmdlIHN0cmF0ZWd5IGlzIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gQXJyYXkgbWVyZ2Ugc3RyYXRlZ3kuXG4gICAqL1xuICBjaGVja0FycmF5U3RyYXRlZ3k6IGZ1bmN0aW9uKHN0cmF0ZWd5KSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgc3RyYXRlZ3kgPT09IHVuZGVmaW5lZCB8fCBzdHJhdGVneSBpbiBtZXJnZUhlbHBlcnMuQXJyYXlTdHJhdGVnaWVzLFxuICAgICAgJ1lvdSBtdXN0IHByb3ZpZGUgYW4gYXJyYXkgc3RyYXRlZ3kgdG8gZGVlcCBtZXJnZSBmdW5jdGlvbnMgdG8gJyArXG4gICAgICAgICdpbnN0cnVjdCB0aGUgZGVlcCBtZXJnZSBob3cgdG8gcmVzb2x2ZSBtZXJnaW5nIHR3byBhcnJheXMuJyxcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgb2YgcG9zc2libGUgYmVoYXZpb3JzIG9mIG1lcmdlIGFsZ29yaXRobXMgd2hlbiBlbmNvdW50ZXJpbmcgdHdvIEFycmF5c1xuICAgKiB0aGF0IG11c3QgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxuICAgKiAtIGBjbG9iYmVyYDogVGhlIGxlZnQgYEFycmF5YCBpcyBpZ25vcmVkLlxuICAgKiAtIGBpbmRleEJ5SW5kZXhgOiBUaGUgcmVzdWx0IGlzIGFjaGlldmVkIGJ5IHJlY3Vyc2l2ZWx5IGRlZXAgbWVyZ2luZyBhdFxuICAgKiAgIGVhY2ggaW5kZXguIChub3QgeWV0IHN1cHBvcnRlZC4pXG4gICAqL1xuICBBcnJheVN0cmF0ZWdpZXM6IHtcbiAgICBDbG9iYmVyOiAnQ2xvYmJlcicsXG4gICAgQ29uY2F0OiAnQ29uY2F0JyxcbiAgICBJbmRleEJ5SW5kZXg6ICdJbmRleEJ5SW5kZXgnLFxuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZUhlbHBlcnM7XG4iXX0=