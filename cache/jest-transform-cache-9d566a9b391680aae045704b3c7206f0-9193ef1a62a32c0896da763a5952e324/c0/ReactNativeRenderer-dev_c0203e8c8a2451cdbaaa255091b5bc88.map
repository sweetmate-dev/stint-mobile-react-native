{"version":3,"sources":["ReactNativeRenderer-dev.js"],"names":["__DEV__","require","ReactNativeViewConfigRegistry","UIManager","RCTEventEmitter","React","deepFreezeAndThrowOnMutationInDev","deepDiffer","flattenStyle","TextInputState","checkPropTypes","tracking","ExceptionsManager","validateFormat","format","undefined","Error","invariant","condition","a","b","c","d","e","f","error","args","argIndex","replace","name","framesToPop","invokeGuardedCallbackImpl","func","context","funcArgs","Array","prototype","slice","call","arguments","apply","onError","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","evt","didError","windowEvent","event","callCallback","removeEventListener","evtType","hasOwnProperty","didSetError","isCrossOriginError","handleWindowError","colno","lineno","defaultPrevented","_suppressLogging","inner","addEventListener","initEvent","invokeGuardedCallbackImpl$1","hasError","caughtError","hasRethrowError","rethrowError","reporter","invokeGuardedCallback","invokeGuardedCallbackAndCatchFirstError","clearCaughtError","rethrowCaughtError","hasCaughtError","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","indexOf","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","phasedRegistrationNames","phaseName","phasedRegistrationName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","lowerCasedName","toLowerCase","injectEventPluginOrder","injectedEventPluginOrder","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","warningWithoutStack","_len","length","_key","console","_console","stringArgs","map","item","concat","message","x","warningWithoutStack$1","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","setComponentTree","getFiberCurrentPropsFromNodeImpl","getInstanceFromNodeImpl","getNodeFromInstanceImpl","validateEventDispatches","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","instancesIsArr","instancesLen","executeDispatch","simulated","listener","inst","type","currentTarget","executeDispatchesInOrder","i","isPropagationStopped","executeDispatchesInOrderStopAtTrueImpl","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","res","hasDispatches","accumulateInto","current","next","push","forEachAccumulated","arr","cb","scope","forEach","eventQueue","executeDispatchesAndRelease","isPersistent","constructor","release","executeDispatchesAndReleaseSimulated","executeDispatchesAndReleaseTopLevel","isInteractive","tag","shouldPreventMouseEvent","props","disabled","injection","getListener","stateNode","topLevelType","targetInst","nativeEvent","nativeEventTarget","events","possiblePlugin","extractedEvents","runEventsInBatch","processingEventQueue","runExtractedEventsInBatch","FunctionalComponent","FunctionalComponentLazy","ClassComponent","ClassComponentLazy","IndeterminateComponent","HostRoot","HostPortal","HostComponent","HostText","Fragment","Mode","ContextConsumer","ContextProvider","ForwardRef","ForwardRefLazy","Profiler","PlaceholderComponent","getParent","return","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","listenerAtPhase","propagationPhase","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","EVENT_POOL_SIZE","EventInterface","target","eventPhase","bubbles","cancelable","timeStamp","Date","now","isTrusted","functionThatReturnsTrue","functionThatReturnsFalse","SyntheticEvent","preventDefault","stopPropagation","isDefaultPrevented","Interface","propName","normalize","returnValue","cancelBubble","persist","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","extend","Super","E","Class","addEventPoolingTo","getVal","isFunction","configurable","set","get","get$$1","val","action","warn","result","warningCondition","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","ResponderSyntheticEvent","touchHistory","TOP_TOUCH_START","TOP_TOUCH_MOVE","TOP_TOUCH_END","TOP_TOUCH_CANCEL","TOP_SCROLL","TOP_SELECTION_CHANGE","isStartish","isMoveish","isEndish","startDependencies","moveDependencies","endDependencies","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","eventTypes$1","startShouldSetResponder","bubbled","captured","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","_getResponder","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","injectGlobalResponderHandler","customBubblingEventTypes$1","customBubblingEventTypes","customDirectEventTypes$1","customDirectEventTypes","eventTypes$2","ReactNativeBridgeEventPlugin","bubbleDispatchConfig","directDispatchConfig","ReactNativeEventPluginOrder","instanceCache","instanceProps","precacheFiberNode","hostInst","uncacheFiberNode","getInstanceFromTag","getTagFromInstance","_nativeTag","canonical","getFiberCurrentPropsFromNode$1","updateFiberProps","restoreImpl","restoreTarget","restoreQueue","restoreStateOfTarget","internalInstance","needsStateRestore","restoreStateIfNeeded","queuedTargets","_batchedUpdatesImpl","bookkeeping","_flushInteractiveUpdatesImpl","isBatching","batchedUpdates","controlledComponentsHavePendingUpdates","setBatchingImplementation","batchedUpdatesImpl","interactiveUpdatesImpl","flushInteractiveUpdatesImpl","EMPTY_NATIVE_EVENT","touchSubsequence","indices","removeTouchesAtIndices","rippedOut","temp","index","fillAt","j","cur","_receiveRootNodeIDEvent","rootNodeID","nativeEventParam","receiveEvent","receiveTouches","eventTopLevelType","changedIndices","jj","ReactNativeEventEmitter","freeze","registrationNames","ReactNativeGlobalResponderHandler","from","to","blockNativeResponder","setJSResponder","clearJSResponder","register","get$1","key","_reactInternalFiber","value","ReactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","hasSymbol","Symbol","for","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_ASYNC_MODE_TYPE","REACT_FORWARD_REF_TYPE","REACT_PLACEHOLDER_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","Pending","Resolved","Rejected","getResultFromResolvedThenable","thenable","_reactResult","refineResolvedThenable","_reactStatus","getComponentName","displayName","$$typeof","renderFn","render","functionName","then","resolvedThenable","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","DidCapture","Ref","Snapshot","LifecycleEffectMask","HostEffectMask","Incomplete","ShouldCapture","ReactCurrentOwner$1","ReactCurrentOwner","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","fiber","node","effectTag","isFiberMounted","isMounted","component","owner","ownerFiber","_warnedAboutRefsInRender","assertIsMounted","findCurrentFiberUsingSlowPath","state","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","emptyObject","removedKeys","removedKeyCount","defaultDiffer","prevProp","nextProp","restoreDeletedValuesInNestedArray","updatePayload","validAttributes","obj","propKey","attributeConfig","diff","process","nextValue","diffNestedArrayProperty","prevArray","nextArray","minLength","diffNestedProperty","clearNestedProperty","addNestedProperty","diffProperties","addProperties","clearProperties","prevProps","nextProps","shouldUpdate","_nextValue","_propKey","create","mountSafeCallback_NOT_REALLY_SAFE","callback","__isMounted","throwOnStylesProp","styles","_owner","msg","warnForStyleProps","style","_classCallCheck","Constructor","TypeError","ReactNativeFiberHostComponent","viewConfig","_children","blur","blurTextInput","focus","focusTextInput","measure","measureInWindow","measureLayout","relativeToNativeNode","onSuccess","onFail","setNativeProps","nativeProps","updateView","uiViewClassName","hasNativePerformanceNow","performance","now$1","scheduledCallback","frameDeadline","frameDeadlineObject","timeRemaining","didTimeout","setTimeoutCallback","scheduleDeferredCallback$1","options","timeoutId","setTimeout","cancelDeferredCallback$1","callbackID","clearTimeout","shim","supportsPersistence","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","replaceContainerChildren","shim$1","supportsHydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","UPDATE_SIGNAL","nextReactTag","allocateTag","recursivelyUncacheFiberNode","appendInitialChild","parentInstance","createInstance","rootContainerInstance","hostContext","internalInstanceHandle","isInAParentText","createView","createTextInstance","text","finalizeInitialChildren","nativeTags","setChildren","getRootHostContext","getChildHostContext","parentHostContext","prevIsInAParentText","getPublicInstance","prepareForCommit","containerInfo","prepareUpdate","oldProps","newProps","resetAfterCommit","isPrimaryRenderer","scheduleDeferredCallback","cancelDeferredCallback","scheduleTimeout","cancelTimeout","noTimeout","shouldDeprioritizeSubtree","shouldSetTextContent","supportsMutation","appendChild","childTag","children","splice","manageChildren","appendChildToContainer","commitTextUpdate","textInstance","oldText","newText","commitUpdate","updatePayloadTODO","insertBefore","beforeChild","beforeChildIndex","_beforeChildIndex","insertInContainerBefore","removeChild","removeChildFromContainer","resetTextContent","BEFORE_SLASH_RE","describeComponentFrame","source","ownerName","sourceInfo","fileName","test","match","pathBeforeSlash","folderName","lineNumber","ReactDebugCurrentFrame","describeFiber","_debugOwner","_debugSource","getStackByFiberInDevAndProd","workInProgress","info","getCurrentFiberOwnerNameInDevOrNull","getCurrentFiberStackInDev","resetCurrentFiber","getCurrentStack","setCurrentFiber","setCurrentPhase","lifeCyclePhase","debugRenderPhaseSideEffects","debugRenderPhaseSideEffectsForStrictMode","enableGetDerivedStateFromCatch","enableSuspense","enableUserTimingAPI","replayFailedUnitOfWorkWithInvokeGuardedCallback","warnAboutDeprecatedLifecycles","warnAboutLegacyContextAPI","enableProfilerTimer","enableSchedulerTracking","reactEmoji","warningEmoji","supportsUserTiming","mark","clearMarks","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","componentName","beginFiberMark","_debugID","has","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","expirationTime","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","didCompleteRoot","startCommitTimer","clear","stopCommitTimer","startCommitSnapshotEffectsTimer","stopCommitSnapshotEffectsTimer","count","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","valueStack","fiberStack","createCursor","defaultValue","cursor","checkThatStackIsEmpty","resetStackAfterFatalErrorInDev","warnedAboutMissingGetChildContext","emptyContextObject","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","Component","didPushOwnContextIfProvider","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","hasContextChanged","childContextTypes","popContext","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","findCurrentUnmaskedContext","_Component","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","isDevToolsPresent","__REACT_DEVTOOLS_GLOBAL_HOOK__","injectInternals","internals","hook","isDisabled","supportsFiber","rendererID","inject","root","onCommitRoot","onCommitUnmount","maxSigned31BitInt","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","expirationTimeToMs","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","LOW_PRIORITY_EXPIRATION","LOW_PRIORITY_BATCH_SIZE","computeAsyncExpiration","HIGH_PRIORITY_EXPIRATION","HIGH_PRIORITY_BATCH_SIZE","computeInteractiveExpiration","NoContext","AsyncMode","StrictMode","ProfileMode","hasBadMapPolyfill","nonExtensibleObject","preventExtensions","testMap","Map","testSet","debugCounter","FiberNode","pendingProps","mode","ref","memoizedProps","updateQueue","memoizedState","firstContextDependency","nextEffect","firstEffect","lastEffect","childExpirationTime","actualDuration","actualStartTime","selfBaseDuration","treeBaseDuration","createFiber","shouldConstruct","isReactComponent","resolveLazyComponentTag","createWorkInProgress","createHostRootFiber","isAsync","createFiberFromElement","element","fiberTag","getTag","createFiberFromFragment","createFiberFromProfiler","keys","_source","elements","id","onRender","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromPortal","portal","pendingChildren","implementation","assignFiberPropertiesInDEV","createFiberRoot","hydrate","uninitializedFiber","earliestPendingTime","latestPendingTime","earliestSuspendedTime","latestSuspendedTime","latestPingedTime","pendingCommitExpirationTime","finishedWork","timeoutHandle","pendingContext","nextExpirationTimeToWorkOn","firstBatch","nextScheduledRoot","interactionThreadID","unstable_getThreadID","memoizedInteractions","pendingInteractionMap","lowPriorityWarning","printWarning","_len2","_key2","lowPriorityWarning$1","ReactStrictModeWarnings","discardPendingWarnings","flushPendingDeprecationWarnings","flushPendingUnsafeLifecycleWarnings","recordDeprecationWarnings","recordUnsafeLifecycleWarnings","recordLegacyContextWarning","flushLegacyContextWarning","LIFECYCLE_SUGGESTIONS","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","UNSAFE_componentWillUpdate","pendingComponentWillMountWarnings","pendingComponentWillReceivePropsWarnings","pendingComponentWillUpdateWarnings","pendingUnsafeLifecycleWarnings","pendingLegacyContextWarning","didWarnAboutDeprecatedLifecycles","didWarnAboutUnsafeLifecycles","didWarnAboutLegacyContext","setToSortedString","array","sort","join","lifecycleWarningsMap","strictRoot","lifecyclesWarningMesages","lifecycle","lifecycleWarnings","componentNames","formatted","suggestion","sortedComponentNames","strictRootComponentStack","findStrictRoot","maybeStrictRoot","uniqueNames","sortedNames","_uniqueNames","_sortedNames","_uniqueNames2","_sortedNames2","componentWillMount","__suppressDeprecationWarning","componentWillReceiveProps","componentWillUpdate","warningsForRoot","unsafeLifecycles","fiberArray","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","markPendingPriorityLevel","findNextExpirationTimeToWorkOn","markCommittedPriorityLevels","earliestRemainingTime","hasLowerPriorityWork","erroredExpirationTime","isPriorityLevelSuspended","markSuspendedPriorityLevel","suspendedTime","clearPing","markPingedPriorityLevel","pingedTime","completedTime","findEarliestOutstandingPriorityLevel","renderExpirationTime","earliestExpirationTime","didExpireAtExpirationTime","completedExpirationTime","UpdateState","ReplaceState","ForceUpdate","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","resetCurrentlyProcessingQueue","createUpdateQueue","baseState","queue","firstUpdate","lastUpdate","firstCapturedUpdate","lastCapturedUpdate","firstCapturedEffect","lastCapturedEffect","cloneUpdateQueue","currentQueue","createUpdate","payload","appendUpdateToQueue","update","enqueueUpdate","queue1","queue2","enqueueCapturedUpdate","workInProgressQueue","ensureWorkInProgressQueueIsAClone","getStateFromUpdate","prevState","_payload","_payload2","partialState","processUpdateQueue","newBaseState","newFirstUpdate","newExpirationTime","resultState","updateExpirationTime","_callback","newFirstCapturedUpdate","_updateExpirationTime","_callback2","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","commitUpdateQueue","finishedQueue","commitUpdateEffects","effect","_callback3","createCapturedValue","stack","getStackAddendum","warning$1","valueCursor","rendererSigil","currentlyRenderingFiber","lastContextDependency","lastContextWithAllBitsObserved","resetContextDependences","pushProvider","providerFiber","_context","_currentValue","_currentRenderer","_currentValue2","_currentRenderer2","popProvider","currentValue","calculateChangedBits","newValue","oldValue","changedBits","_calculateChangedBits","propagateContextChange","nextFiber","dependency","observedBits","prepareToReadContext","readContext","resolvedObservedBits","contextItem","NO_CONTEXT","contextStackCursor$1","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","getRootHostContainer","rootInstance","pushHostContainer","nextRootInstance","nextRootContext","popHostContainer","getHostContext","pushHostContext","nextContext","popHostContext","commitTime","profilerStartTime","getCommitTime","recordCommitTime","startProfilerTimer","stopProfilerTimerIfRunning","stopProfilerTimerIfRunningAndRecordDelta","overrideBaseTime","elapsedTime","is","y","shallowEqual","objA","objB","keysA","keysB","fakeInternalInstance","emptyRefsObject","refs","didWarnAboutStateAssignmentForComponent","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","didWarnAboutUndefinedDerivedState","warnOnUndefinedDerivedState","warnOnInvalidCallback","didWarnAboutDirectlyAssigningPropsToState","didWarnOnInvalidCallback","callerName","enumerable","applyDerivedStateFromProps","ctor","getDerivedStateFromProps","classComponentUpdater","enqueueSetState","requestCurrentTime","computeExpirationForFiber","scheduleWork","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldState","newState","nextLegacyContext","shouldComponentUpdate","isPureReactComponent","checkClassInstance","renderPresent","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","noUnsafeComponentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","getSnapshotBeforeUpdate","componentDidUpdate","noInstanceGetDerivedStateFromProps","noInstanceGetDerivedStateFromCatch","getDerivedStateFromCatch","noStaticGetSnapshotBeforeUpdate","_state","adoptClassInstance","updater","_reactInternalInstance","constructClassInstance","isContextConsumer","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","_componentName","newApiName","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","componentDidMount","resumeMountClassInstance","oldContext","nextLegacyUnmaskedContext","hasNewLifecycles","updateClassInstance","didWarnAboutMaps","didWarnAboutGenerators","didWarnAboutStringRefInStrictMode","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","coerceRef","returnFiber","current$$1","mixedRef","stringRef","_stringRef","throwOnInvalidObjectType","newChild","addendum","toString","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","last","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","existing","updateElement","updatePortal","updateFragment","fragment","createChild","_created","_created2","_created3","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","delete","reconcileChildrenIterator","newChildrenIterable","iteratorFn","toStringTag","entries","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created4","reconcileSinglePortal","reconcileChildFibers","isUnkeyedTopLevelFragment","isObject","_isMockFunction","mountChildFibers","cloneChildFibers","currentChild","hydrationParentFiber","nextHydratableInstance","isHydrating","enterHydrationState","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","parentType","parentProps","_type","_props","_text","tryHydrate","nextInstance","tryToClaimNextHydratableInstance","firstAttemptedInstance","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popToNextHostParent","popHydrationState","resetHydrationState","readLazyComponentType","status","resolvedValue","defaultExport","default","ReactCurrentOwner$3","didWarnAboutBadClass","didWarnAboutGetDerivedStateOnFunctionalComponent","didWarnAboutStatelessRefs","reconcileChildren","nextChildren","updateForwardRef","currentRef","bailoutOnAlreadyFinishedWork","memoizeProps","updateMode","updateProfiler","markRef","updateFunctionalComponent","updateClassComponent","hasContext","finishClassComponent","didCaptureError","memoizeState","pushHostRootContext","updateHostRoot","prevChildren","nextState","updateHostComponent","isDirectTextChild","updateHostText","resolveDefaultProps","baseProps","mountIndeterminateComponent","resolvedTag","resolvedProps","warningKey","debugSource","updatePlaceholderComponent","alreadyCaptured","nextDidTimeout","fallback","updatePortalComponent","updateContextProvider","providerType","providerPropTypes","updateContextConsumer","unstable_observedBits","beginWork","_Component3","_Component4","_unresolvedProps","_thenable2","_Component5","_unresolvedProps2","_Component6","_unresolvedProps3","_thenable3","_Component7","_unresolvedProps4","_child2","_thenable","_Component2","unresolvedProps","markUpdate","markRef$1","appendAllChildren","updateHostContainer","updateHostComponent$1","updateHostText$1","currentHostContext","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","completeWork","fiberRoot","wasHydrated","_rootContainerInstance","_currentHostContext","_wasHydrated","showErrorDialog","capturedError","componentStack","errorToHandle","summary","handleException","logCapturedError","logError","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","emptyObject$1","didWarnAboutUndefinedSnapshotBeforeUpdate","boundary","errorInfo","errorBoundary","callComponentWillUnmountWithTimer","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","captureCommitPhaseError","safelyDetachRef","refError","commitBeforeMutationLifeCycles","snapshot","didWarnSet","__reactInternalSnapshotBeforeUpdate","commitLifeCycles","finishedRoot","committedExpirationTime","_updateQueue","_instance","_instance2","timedOutAt","commitAttachRef","instanceToUse","commitDetachRef","commitUnmount","unmountHostComponents","emptyPortalContainer","commitNestedUnmounts","detachFiber","emptyChildSet","commitContainer","_pendingChildren","getHostParentFiber","isHostParent","getHostSibling","siblings","commitPlacement","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","commitDeletion","commitWork","commitResetTextContent","NoopComponent","createRootErrorUpdate","onUncaughtError","createClassErrorUpdate","componentDidCatch","markLegacyErrorBoundaryAsFailed","throwException","sourceFiber","_workInProgress","earliestTimeoutMs","startTimeMs","timeoutPropMs","delayMs","pingTime","onResolveOrReject","retrySuspendedRoot","bind","absoluteTimeoutMs","earliestExpirationTimeMs","renderDidSuspend","renderDidError","_errorInfo","isAlreadyFailedLegacyErrorBoundary","_update","unwindWork","_effectTag","_effectTag2","_effectTag3","unwindInterruptedWork","interruptedWork","_childContextTypes","Dispatcher","ReactCurrentOwner$2","didWarnAboutStateTransition","didWarnSetStateChildContext","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","__interactionsRef","didWarnStateUpdateForUnmountedComponent","expirationContext","isWorking","nextRoot","nextRenderExpirationTime","nextLatestAbsoluteTimeoutMs","nextRenderDidError","isCommitting$1","legacyErrorBoundariesThatAlreadyFailed","suspenseDidTimeout","stashedWorkInProgressProperties","replayUnitOfWork","isReplayingFailedUnitOfWork","originalReplayError","rethrowOriginalError","failedUnitOfWork","thrownValue","isYieldy","workLoop","replayError","resetStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitBeforeMutationLifecycles","commitAllLifeCycles","commitRoot","updateExpirationTimeBeforeCommit","childExpirationTimeBeforeCommit","earliestRemainingTimeBeforeCommit","prevInteractions","committedInteractions","scheduledInteractions","scheduledExpirationTime","_didError","_error","_didError2","_error2","onCommitWork","updateExpirationTimeAfterCommit","childExpirationTimeAfterCommit","earliestRemainingTimeAfterCommit","onCommit","subscriber","__subscriberRef","size","threadID","computeThreadID","onWorkStopped","hasUnhandledError","unhandledError","interaction","__count","onInteractionScheduledWorkCompleted","resetChildExpirationTime","renderTime","newChildExpirationTime","shouldBubbleActualDurations","childUpdateExpirationTime","childChildExpirationTime","_childUpdateExpirationTime","_childChildExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","_next","performUnitOfWork","onBeginWork","shouldYield","renderRoot","isExpired","currentDispatcher","interactions","onWorkStarted","didFatal","_didCompleteRoot","onFatal","_didCompleteRoot2","onYield","rootWorkInProgress","suspendedExpirationTime","rootExpirationTime","onSuspend","_suspendedExpirationTime","_rootExpirationTime","_suspendedExpirationTime2","currentTimeMs","msUntilTimeout","_rootExpirationTime2","onComplete","dispatch","rootFiber","_errorInfo2","_update2","isBatchingInteractiveUpdates","lowestPriorityPendingInteractiveExpirationTime","retryTime","scheduleWorkToRoot","storeInteractionsForExpirationTime","requestWork","updateInteractionCounts","pendingInteractions","onWorkScheduled","nestedUpdateCount","NESTED_UPDATE_LIMIT","firstScheduledRoot","lastScheduledRoot","callbackExpirationTime","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","deadline","isBatchingUpdates","isUnbatchingUpdates","completedBatches","originalStartTimeMs","currentRendererTime","currentSchedulerTime","lastCommittedRootDuringThisBatch","timeHeuristicForUnitOfWork","recomputeCurrentRendererTime","scheduleCallbackWithExpirationTime","currentMs","expirationTimeMs","timeout","performAsyncWork","onTimeout","flushRoot","findHighestPriorityRoot","addRootToSchedule","performWorkOnRoot","performSyncWork","remainingExpirationTime","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","dl","performWork","minExpirationTime","finishRendering","batches","batch","_onComplete","completeRoot","_finishedWork","_timeoutHandle","_isYieldy","_expirationTime","_defer","batchedUpdates$1","previousIsBatchingUpdates","interactiveUpdates$1","previousIsBatchingInteractiveUpdates","flushInteractiveUpdates$1","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","scheduleRootUpdate","updateContainerAtExpirationTime","onMountContainer","onUnmountContainer","onUpdateContainer","findHostInstance$1","hostFiber","createContainer","updateContainer","getPublicRootInstance","containerFiber","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","findHostInstanceByFiber","createPortal","ReactVersion","NativeMethodsMixin","findNodeHandle","findHostInstance","maybeInstance","NativeMethodsMixin_DEV","_classCallCheck$1","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","writable","setPrototypeOf","__proto__","ReactNativeComponent","_React$Component","emptyObject$2","getInspectorDataForViewTag","traverseOwnerTreeUp","hierarchy","unshift","getOwnerHierarchy","lastNonHostInstance","getHostProps","host","getHostNode","hostNode","createHierarchy","fiberHierarchy","getInspectorData","viewTag","closestInstance","selection","componentOrHandle","hostInstance","computeComponentStackForErrorReporting","reactTag","roots","ReactNativeRenderer","NativeComponent","containerTag","unmountComponentAtNode","unmountComponentAtNodeAndRemoveContainer","removeRootView","unstable_batchedUpdates","bundleType","version","rendererPackageName","ReactNativeRenderer$2","ReactNativeRenderer$3","reactNativeRenderer","module","exports"],"mappings":"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","file":"ReactNativeRenderer-dev.js","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n * @providesModule ReactNativeRenderer-dev\n * @preventMunge\n * @generated\n */\n\n'use strict';\n\nif (__DEV__) {\n  (function() {\n\"use strict\";\n\nrequire(\"InitializeCore\");\nvar ReactNativeViewConfigRegistry = require(\"ReactNativeViewConfigRegistry\");\nvar UIManager = require(\"UIManager\");\nvar RCTEventEmitter = require(\"RCTEventEmitter\");\nvar React = require(\"react\");\nvar deepFreezeAndThrowOnMutationInDev = require(\"deepFreezeAndThrowOnMutationInDev\");\nvar deepDiffer = require(\"deepDiffer\");\nvar flattenStyle = require(\"flattenStyle\");\nvar TextInputState = require(\"TextInputState\");\nvar checkPropTypes = require(\"prop-types/checkPropTypes\");\nvar tracking = require(\"schedule/tracking\");\nvar ExceptionsManager = require(\"ExceptionsManager\");\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function() {};\n\n{\n  validateFormat = function(format) {\n    if (format === undefined) {\n      throw new Error(\"invariant requires an error message argument\");\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error = void 0;\n    if (format === undefined) {\n      error = new Error(\n        \"Minified exception occurred; use the non-minified dev environment \" +\n          \"for the full error message and additional helpful warnings.\"\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        })\n      );\n      error.name = \"Invariant Violation\";\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nvar invokeGuardedCallbackImpl = function(\n  name,\n  func,\n  context,\n  a,\n  b,\n  c,\n  d,\n  e,\n  f\n) {\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.dispatchEvent === \"function\" &&\n    typeof document !== \"undefined\" &&\n    typeof document.createEvent === \"function\"\n  ) {\n    var fakeNode = document.createElement(\"react\");\n\n    var invokeGuardedCallbackDev = function(\n      name,\n      func,\n      context,\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    ) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      invariant(\n        typeof document !== \"undefined\",\n        \"The `document` global was defined when React was initialized, but is not \" +\n          \"defined anymore. This can happen in a test environment if a component \" +\n          \"schedules an update from an asynchronous callback, but the test has already \" +\n          \"finished running. To solve this, you can either unmount the component at \" +\n          \"the end of your test (and ensure that any asynchronous operations get \" +\n          \"canceled in `componentWillUnmount`), or you can change the test itself \" +\n          \"to be asynchronous.\"\n      );\n      var evt = document.createEvent(\"Event\");\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n      var windowEvent = window.event;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n\n        // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n        if (\n          typeof window.event !== \"undefined\" &&\n          window.hasOwnProperty(\"event\")\n        ) {\n          window.event = windowEvent;\n        }\n\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === \"object\") {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {\n              // Ignore.\n            }\n          }\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n\n      // Attach our event handlers\n      window.addEventListener(\"error\", handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error(\n            \"An error was thrown inside one of your components, but React \" +\n              \"doesn't know what it was. This is likely due to browser \" +\n              'flakiness. React does its best to preserve the \"Pause on ' +\n              'exceptions\" behavior of the DevTools, which requires some ' +\n              \"DEV-mode only tricks. It's possible that these don't work in \" +\n              \"your browser. Try triggering the error in production mode, \" +\n              \"or switching to a modern browser. If you suspect that this is \" +\n              \"actually an issue with React, please file an issue.\"\n          );\n        } else if (isCrossOriginError) {\n          error = new Error(\n            \"A cross-origin error was thrown. React doesn't have access to \" +\n              \"the actual error object in development. \" +\n              \"See https://fb.me/react-crossorigin-error for more information.\"\n          );\n        }\n        this.onError(error);\n      }\n\n      // Remove our event listeners\n      window.removeEventListener(\"error\", handleWindowError);\n    };\n\n    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n\n// Used by Fiber to simulate a try-catch.\nvar hasError = false;\nvar caughtError = null;\n\n// Used by event system to capture/rethrow the first error.\nvar hasRethrowError = false;\nvar rethrowError = null;\n\nvar reporter = {\n  onError: function(error) {\n    hasError = true;\n    caughtError = error;\n  }\n};\n\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nfunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n}\n\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nfunction invokeGuardedCallbackAndCatchFirstError(\n  name,\n  func,\n  context,\n  a,\n  b,\n  c,\n  d,\n  e,\n  f\n) {\n  invokeGuardedCallback.apply(this, arguments);\n  if (hasError) {\n    var error = clearCaughtError();\n    if (!hasRethrowError) {\n      hasRethrowError = true;\n      rethrowError = error;\n    }\n  }\n}\n\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\nfunction rethrowCaughtError() {\n  if (hasRethrowError) {\n    var error = rethrowError;\n    hasRethrowError = false;\n    rethrowError = null;\n    throw error;\n  }\n}\n\nfunction hasCaughtError() {\n  return hasError;\n}\n\nfunction clearCaughtError() {\n  if (hasError) {\n    var error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    invariant(\n      false,\n      \"clearCaughtError was called but no error was captured. This error \" +\n        \"is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n}\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    invariant(\n      pluginIndex > -1,\n      \"EventPluginRegistry: Cannot inject event plugins that do not exist in \" +\n        \"the plugin ordering, `%s`.\",\n      pluginName\n    );\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    invariant(\n      pluginModule.extractEvents,\n      \"EventPluginRegistry: Event plugins must implement an `extractEvents` \" +\n        \"method, but `%s` does not.\",\n      pluginName\n    );\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          pluginModule,\n          eventName\n        ),\n        \"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\",\n        eventName,\n        pluginName\n      );\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  invariant(\n    !eventNameDispatchConfigs.hasOwnProperty(eventName),\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"event name, `%s`.\",\n    eventName\n  );\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          pluginModule,\n          eventName\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      pluginModule,\n      eventName\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  invariant(\n    !registrationNameModules[registrationName],\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"registration name, `%s`.\",\n    registrationName\n  );\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] =\n    pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  invariant(\n    !eventPluginOrder,\n    \"EventPluginRegistry: Cannot inject event plugin ordering more than \" +\n      \"once. You are likely trying to load more than one copy of React.\"\n  );\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (\n      !namesToPlugins.hasOwnProperty(pluginName) ||\n      namesToPlugins[pluginName] !== pluginModule\n    ) {\n      invariant(\n        !namesToPlugins[pluginName],\n        \"EventPluginRegistry: Cannot inject two different event plugins \" +\n          \"using the same name, `%s`.\",\n        pluginName\n      );\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warningWithoutStack = function() {};\n\n{\n  warningWithoutStack = function(condition, format) {\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 2 ? _len - 2 : 0),\n        _key = 2;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error(\n        \"`warningWithoutStack(condition, format, ...args)` requires a warning \" +\n          \"message argument\"\n      );\n    }\n    if (condition) {\n      return;\n    }\n    if (typeof console !== \"undefined\") {\n      var _console;\n\n      var stringArgs = args.map(function(item) {\n        return \"\" + item;\n      });\n      (_console = console).error.apply(\n        _console,\n        [\"Warning: \" + format].concat(stringArgs)\n      );\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var message =\n        \"Warning: \" +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nfunction setComponentTree(\n  getFiberCurrentPropsFromNodeImpl,\n  getInstanceFromNodeImpl,\n  getNodeFromInstanceImpl\n) {\n  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode = getInstanceFromNodeImpl;\n  getNodeFromInstance = getNodeFromInstanceImpl;\n  {\n    !(getNodeFromInstance && getInstanceFromNode)\n      ? warningWithoutStack$1(\n          false,\n          \"EventPluginUtils.setComponentTree(...): Injected \" +\n            \"module is missing getNodeFromInstance or getInstanceFromNode.\"\n        )\n      : void 0;\n  }\n}\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr\n      ? dispatchListeners.length\n      : dispatchListeners\n        ? 1\n        : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr\n      ? dispatchInstances.length\n      : dispatchInstances\n        ? 1\n        : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen)\n      ? warningWithoutStack$1(false, \"EventPluginUtils: Invalid `event`.\")\n      : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || \"unknown-event\";\n  event.currentTarget = getNodeFromInstance(inst);\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(\n        event,\n        simulated,\n        dispatchListeners[i],\n        dispatchInstances[i]\n      );\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  invariant(\n    !Array.isArray(dispatchListener),\n    \"executeDirectDispatch(...): Invalid `event`.\"\n  );\n  event.currentTarget = dispatchListener\n    ? getNodeFromInstance(dispatchInstance)\n    : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  invariant(\n    next != null,\n    \"accumulateInto(...): Accumulated items must not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function(event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function(e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function(e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return (\n    tag === \"button\" ||\n    tag === \"input\" ||\n    tag === \"select\" ||\n    tag === \"textarea\"\n  );\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case \"onClick\":\n    case \"onClickCapture\":\n    case \"onDoubleClick\":\n    case \"onDoubleClickCapture\":\n    case \"onMouseDown\":\n    case \"onMouseDownCapture\":\n    case \"onMouseMove\":\n    case \"onMouseMoveCapture\":\n    case \"onMouseUp\":\n    case \"onMouseUpCapture\":\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  invariant(\n    !listener || typeof listener === \"function\",\n    \"Expected `%s` listener to be a function, instead got a value of `%s` type.\",\n    registrationName,\n    typeof listener\n  );\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseSimulated\n    );\n  } else {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseTopLevel\n    );\n  }\n  invariant(\n    !eventQueue,\n    \"processEventQueue(): Additional events were enqueued while processing \" +\n      \"an event queue. Support for this has not yet been implemented.\"\n  );\n  // This would be a good time to rethrow if any of the event handlers threw.\n  rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = extractEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  runEventsInBatch(events, false);\n}\n\nvar FunctionalComponent = 0;\nvar FunctionalComponentLazy = 1;\nvar ClassComponent = 2;\nvar ClassComponentLazy = 3;\nvar IndeterminateComponent = 4; // Before we know whether it is functional or class\nvar HostRoot = 5; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 6; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 7;\nvar HostText = 8;\nvar Fragment = 9;\nvar Mode = 10;\nvar ContextConsumer = 11;\nvar ContextProvider = 12;\nvar ForwardRef = 13;\nvar ForwardRefLazy = 14;\nvar Profiler = 15;\nvar PlaceholderComponent = 16;\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0; ) {\n    fn(path[i], \"captured\", arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], \"bubbled\", arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst\n      ? warningWithoutStack$1(false, \"Dispatching inst must not be null\")\n      : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\n\nvar EVENT_POOL_SIZE = 10;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: function() {\n    return null;\n  },\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function(event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\nfunction functionThatReturnsTrue() {\n  return true;\n}\n\nfunction functionThatReturnsFalse() {\n  return false;\n}\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(\n  dispatchConfig,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n    delete this.isDefaultPrevented;\n    delete this.isPropagationStopped;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === \"target\") {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented =\n    nativeEvent.defaultPrevented != null\n      ? nativeEvent.defaultPrevented\n      : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = functionThatReturnsFalse;\n  }\n  this.isPropagationStopped = functionThatReturnsFalse;\n  return this;\n}\n\nObject.assign(SyntheticEvent.prototype, {\n  preventDefault: function() {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== \"unknown\") {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  },\n\n  stopPropagation: function() {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== \"unknown\") {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = functionThatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function() {\n    this.isPersistent = functionThatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: functionThatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function() {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(\n          this,\n          propName,\n          getPooledWarningPropertyDefinition(propName, Interface[propName])\n        );\n      }\n    }\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n    {\n      Object.defineProperty(\n        this,\n        \"nativeEvent\",\n        getPooledWarningPropertyDefinition(\"nativeEvent\", null)\n      );\n      Object.defineProperty(\n        this,\n        \"isDefaultPrevented\",\n        getPooledWarningPropertyDefinition(\n          \"isDefaultPrevented\",\n          functionThatReturnsFalse\n        )\n      );\n      Object.defineProperty(\n        this,\n        \"isPropagationStopped\",\n        getPooledWarningPropertyDefinition(\n          \"isPropagationStopped\",\n          functionThatReturnsFalse\n        )\n      );\n      Object.defineProperty(\n        this,\n        \"preventDefault\",\n        getPooledWarningPropertyDefinition(\"preventDefault\", function() {})\n      );\n      Object.defineProperty(\n        this,\n        \"stopPropagation\",\n        getPooledWarningPropertyDefinition(\"stopPropagation\", function() {})\n      );\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function(Interface) {\n  var Super = this;\n\n  var E = function() {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  Object.assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = Object.assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === \"function\";\n  return {\n    configurable: true,\n    set: set,\n    get: get$$1\n  };\n\n  function set(val) {\n    var action = isFunction ? \"setting the method\" : \"setting the property\";\n    warn(action, \"This is effectively a no-op\");\n    return val;\n  }\n\n  function get$$1() {\n    var action = isFunction ? \"accessing the method\" : \"accessing the property\";\n    var result = isFunction\n      ? \"This is a no-op function\"\n      : \"This is set to null\";\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition\n      ? warningWithoutStack$1(\n          false,\n          \"This synthetic event is reused for performance reasons. If you're seeing this, \" +\n            \"you're %s `%s` on a released/nullified synthetic event. %s. \" +\n            \"If you must keep the original synthetic event around, use event.persist(). \" +\n            \"See https://fb.me/react-event-pooling for more information.\",\n          action,\n          propName,\n          result\n        )\n      : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(\n      instance,\n      dispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeInst\n    );\n    return instance;\n  }\n  return new EventConstructor(\n    dispatchConfig,\n    targetInst,\n    nativeEvent,\n    nativeInst\n  );\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  invariant(\n    event instanceof EventConstructor,\n    \"Trying to release an event instance into a pool of a different type.\"\n  );\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\nvar ResponderSyntheticEvent = SyntheticEvent.extend({\n  touchHistory: function(nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n});\n\nvar TOP_TOUCH_START = \"topTouchStart\";\nvar TOP_TOUCH_MOVE = \"topTouchMove\";\nvar TOP_TOUCH_END = \"topTouchEnd\";\nvar TOP_TOUCH_CANCEL = \"topTouchCancel\";\nvar TOP_SCROLL = \"topScroll\";\nvar TOP_SELECTION_CHANGE = \"topSelectionChange\";\n\nfunction isStartish(topLevelType) {\n  return topLevelType === TOP_TOUCH_START;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === TOP_TOUCH_MOVE;\n}\n\nfunction isEndish(topLevelType) {\n  return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;\n}\n\nvar startDependencies = [TOP_TOUCH_START];\nvar moveDependencies = [TOP_TOUCH_MOVE];\nvar endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  invariant(identifier != null, \"Touch object is missing identifier.\");\n  {\n    !(identifier <= MAX_TOUCH_BANK)\n      ? warningWithoutStack$1(\n          false,\n          \"Touch identifier %s is greater than maximum supported %s which causes \" +\n            \"performance issues backfilling array locations for all of the indices.\",\n          identifier,\n          MAX_TOUCH_BANK\n        )\n      : void 0;\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch move without a touch start.\\n\" + \"Touch Move: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch end without a touch start.\\n\" + \"Touch End: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += \" (original size: \" + touchBank.length + \")\";\n  }\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch =\n          nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          !(activeRecord != null && activeRecord.touchActive)\n            ? warningWithoutStack$1(false, \"Cannot find single active touch.\")\n            : void 0;\n        }\n      }\n    }\n  },\n\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\nfunction accumulate(current, next) {\n  invariant(\n    next != null,\n    \"accumulate(...): Accumulated items must be not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\nvar changeResponder = function(nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(\n      oldResponderInst,\n      nextResponderInst,\n      blockHostResponder\n    );\n  }\n};\n\nvar eventTypes$1 = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onStartShouldSetResponder\",\n      captured: \"onStartShouldSetResponderCapture\"\n    },\n    dependencies: startDependencies\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onScrollShouldSetResponder\",\n      captured: \"onScrollShouldSetResponderCapture\"\n    },\n    dependencies: [TOP_SCROLL]\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onSelectionChangeShouldSetResponder\",\n      captured: \"onSelectionChangeShouldSetResponderCapture\"\n    },\n    dependencies: [TOP_SELECTION_CHANGE]\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onMoveShouldSetResponder\",\n      captured: \"onMoveShouldSetResponderCapture\"\n    },\n    dependencies: moveDependencies\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: {\n    registrationName: \"onResponderStart\",\n    dependencies: startDependencies\n  },\n  responderMove: {\n    registrationName: \"onResponderMove\",\n    dependencies: moveDependencies\n  },\n  responderEnd: {\n    registrationName: \"onResponderEnd\",\n    dependencies: endDependencies\n  },\n  responderRelease: {\n    registrationName: \"onResponderRelease\",\n    dependencies: endDependencies\n  },\n  responderTerminationRequest: {\n    registrationName: \"onResponderTerminationRequest\",\n    dependencies: []\n  },\n  responderGrant: {\n    registrationName: \"onResponderGrant\",\n    dependencies: []\n  },\n  responderReject: {\n    registrationName: \"onResponderReject\",\n    dependencies: []\n  },\n  responderTerminate: {\n    registrationName: \"onResponderTerminate\",\n    dependencies: []\n  }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var shouldSetEventType = isStartish(topLevelType)\n    ? eventTypes$1.startShouldSetResponder\n    : isMoveish(topLevelType)\n      ? eventTypes$1.moveShouldSetResponder\n      : topLevelType === TOP_SELECTION_CHANGE\n        ? eventTypes$1.selectionChangeShouldSetResponder\n        : eventTypes$1.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst\n    ? targetInst\n    : getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(\n    shouldSetEventType,\n    bubbleShouldSetFrom,\n    nativeEvent,\n    nativeEventTarget\n  );\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted = void 0;\n  var grantEvent = ResponderSyntheticEvent.getPooled(\n    eventTypes$1.responderGrant,\n    wantsResponderInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(\n      eventTypes$1.responderTerminationRequest,\n      responderInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    terminationRequestEvent.touchHistory =\n      ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch =\n      !hasDispatches(terminationRequestEvent) ||\n      executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes$1.responderTerminate,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes$1.responderReject,\n        wantsResponderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return (\n    topLevelInst &&\n    // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    ((topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll) ||\n      (trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE) ||\n      isStartish(topLevelType) ||\n      isMoveish(topLevelType))\n  );\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode(target);\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function() {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes$1,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error(\n          \"Ended a touch event which was not counted in `trackedTouchCount`.\"\n        );\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)\n      ? setResponderAndExtractTransfer(\n          topLevelType,\n          targetInst,\n          nativeEvent,\n          nativeEventTarget\n        )\n      : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart\n      ? eventTypes$1.responderStart\n      : isResponderTouchMove\n        ? eventTypes$1.responderMove\n        : isResponderTouchEnd\n          ? eventTypes$1.responderEnd\n          : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(\n        incrementalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate =\n      responderInst && topLevelType === TOP_TOUCH_CANCEL;\n    var isResponderRelease =\n      responderInst &&\n      !isResponderTerminate &&\n      isEndish(topLevelType) &&\n      noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate\n      ? eventTypes$1.responderTerminate\n      : isResponderRelease\n        ? eventTypes$1.responderRelease\n        : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(\n        finalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function(GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    }\n  }\n};\n\nvar customBubblingEventTypes$1 =\n  ReactNativeViewConfigRegistry.customBubblingEventTypes;\nvar customDirectEventTypes$1 =\n  ReactNativeViewConfigRegistry.customDirectEventTypes;\nvar eventTypes$2 = ReactNativeViewConfigRegistry.eventTypes;\n\nvar ReactNativeBridgeEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (targetInst == null) {\n      // Probably a node belonging to another renderer's tree.\n      return null;\n    }\n    var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType];\n    var directDispatchConfig = customDirectEventTypes$1[topLevelType];\n    invariant(\n      bubbleDispatchConfig || directDispatchConfig,\n      'Unsupported top level event type \"%s\" dispatched',\n      topLevelType\n    );\n    var event = SyntheticEvent.getPooled(\n      bubbleDispatchConfig || directDispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    if (bubbleDispatchConfig) {\n      accumulateTwoPhaseDispatches(event);\n    } else if (directDispatchConfig) {\n      accumulateDirectDispatches(event);\n    } else {\n      return null;\n    }\n    return event;\n  }\n};\n\nvar ReactNativeEventPluginOrder = [\n  \"ResponderEventPlugin\",\n  \"ReactNativeBridgeEventPlugin\"\n];\n\n/**\n * Make sure essential globals are available and are patched correctly. Please don't remove this\n * line. Bundles created by react-packager `require` it before executing any application code. This\n * ensures it exists in the dependency graph and can be `require`d.\n * TODO: require this in packager, not in React #10932517\n */\n// Module provided by RN:\n/**\n * Inject module for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(ReactNativeEventPluginOrder);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  ResponderEventPlugin: ResponderEventPlugin,\n  ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin\n});\n\nvar instanceCache = {};\nvar instanceProps = {};\n\nfunction precacheFiberNode(hostInst, tag) {\n  instanceCache[tag] = hostInst;\n}\n\nfunction uncacheFiberNode(tag) {\n  delete instanceCache[tag];\n  delete instanceProps[tag];\n}\n\nfunction getInstanceFromTag(tag) {\n  return instanceCache[tag] || null;\n}\n\nfunction getTagFromInstance(inst) {\n  var tag = inst.stateNode._nativeTag;\n  if (tag === undefined) {\n    tag = inst.stateNode.canonical._nativeTag;\n  }\n  invariant(tag, \"All native instances should have a tag.\");\n  return tag;\n}\n\nfunction getFiberCurrentPropsFromNode$1(stateNode) {\n  return instanceProps[stateNode._nativeTag] || null;\n}\n\nfunction updateFiberProps(tag, props) {\n  instanceProps[tag] = props;\n}\n\n// Use to restore controlled state after a change event has fired.\n\nvar restoreImpl = null;\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  invariant(\n    typeof restoreImpl === \"function\",\n    \"setRestoreImplementation() needs to be called to handle a target for controlled \" +\n      \"events. This error is likely caused by a bug in React. Please file an issue.\"\n  );\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  restoreImpl(internalInstance.stateNode, internalInstance.type, props);\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdatesImpl = function(fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _flushInteractiveUpdatesImpl = function() {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdatesImpl(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdatesImpl();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nfunction setBatchingImplementation(\n  batchedUpdatesImpl,\n  interactiveUpdatesImpl,\n  flushInteractiveUpdatesImpl\n) {\n  _batchedUpdatesImpl = batchedUpdatesImpl;\n  _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;\n}\n\n/**\n * Version of `ReactBrowserEventEmitter` that works on the receiving side of a\n * serialized worker boundary.\n */\n\n// Shared default empty native event - conserve memory.\nvar EMPTY_NATIVE_EVENT = {};\n\n/**\n * Selects a subsequence of `Touch`es, without destroying `touches`.\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices by which to pull subsequence.\n * @return {Array<Touch>} Subsequence of touch objects.\n */\nvar touchSubsequence = function(touches, indices) {\n  var ret = [];\n  for (var i = 0; i < indices.length; i++) {\n    ret.push(touches[indices[i]]);\n  }\n  return ret;\n};\n\n/**\n * TODO: Pool all of this.\n *\n * Destroys `touches` by removing touch objects at indices `indices`. This is\n * to maintain compatibility with W3C touch \"end\" events, where the active\n * touches don't include the set that has just been \"ended\".\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices to remove from `touches`.\n * @return {Array<Touch>} Subsequence of removed touch objects.\n */\nvar removeTouchesAtIndices = function(touches, indices) {\n  var rippedOut = [];\n  // use an unsafe downcast to alias to nullable elements,\n  // so we can delete and then compact.\n  var temp = touches;\n  for (var i = 0; i < indices.length; i++) {\n    var index = indices[i];\n    rippedOut.push(touches[index]);\n    temp[index] = null;\n  }\n  var fillAt = 0;\n  for (var j = 0; j < temp.length; j++) {\n    var cur = temp[j];\n    if (cur !== null) {\n      temp[fillAt++] = cur;\n    }\n  }\n  temp.length = fillAt;\n  return rippedOut;\n};\n\n/**\n * Internal version of `receiveEvent` in terms of normalized (non-tag)\n * `rootNodeID`.\n *\n * @see receiveEvent.\n *\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {?object} nativeEventParam Object passed from native.\n */\nfunction _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {\n  var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;\n  var inst = getInstanceFromTag(rootNodeID);\n  batchedUpdates(function() {\n    runExtractedEventsInBatch(\n      topLevelType,\n      inst,\n      nativeEvent,\n      nativeEvent.target\n    );\n  });\n  // React Native doesn't use ReactControlledComponent but if it did, here's\n  // where it would do it.\n}\n\n/**\n * Publicly exposed method on module for native objc to invoke when a top\n * level event is extracted.\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {object} nativeEventParam Object passed from native.\n */\nfunction receiveEvent(rootNodeID, topLevelType, nativeEventParam) {\n  _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);\n}\n\n/**\n * Simple multi-wrapper around `receiveEvent` that is intended to receive an\n * efficient representation of `Touch` objects, and other information that\n * can be used to construct W3C compliant `Event` and `Touch` lists.\n *\n * This may create dispatch behavior that differs than web touch handling. We\n * loop through each of the changed touches and receive it as a single event.\n * So two `touchStart`/`touchMove`s that occur simultaneously are received as\n * two separate touch event dispatches - when they arguably should be one.\n *\n * This implementation reuses the `Touch` objects themselves as the `Event`s\n * since we dispatch an event for each touch (though that might not be spec\n * compliant). The main purpose of reusing them is to save allocations.\n *\n * TODO: Dispatch multiple changed touches in one event. The bubble path\n * could be the first common ancestor of all the `changedTouches`.\n *\n * One difference between this behavior and W3C spec: cancelled touches will\n * not appear in `.touches`, or in any future `.touches`, though they may\n * still be \"actively touching the surface\".\n *\n * Web desktop polyfills only need to construct a fake touch event with\n * identifier 0, also abandoning traditional click handlers.\n */\nfunction receiveTouches(eventTopLevelType, touches, changedIndices) {\n  var changedTouches =\n    eventTopLevelType === \"topTouchEnd\" ||\n    eventTopLevelType === \"topTouchCancel\"\n      ? removeTouchesAtIndices(touches, changedIndices)\n      : touchSubsequence(touches, changedIndices);\n\n  for (var jj = 0; jj < changedTouches.length; jj++) {\n    var touch = changedTouches[jj];\n    // Touch objects can fulfill the role of `DOM` `Event` objects if we set\n    // the `changedTouches`/`touches`. This saves allocations.\n    touch.changedTouches = changedTouches;\n    touch.touches = touches;\n    var nativeEvent = touch;\n    var rootNodeID = null;\n    var target = nativeEvent.target;\n    if (target !== null && target !== undefined) {\n      if (target < 1) {\n        {\n          warningWithoutStack$1(\n            false,\n            \"A view is reporting that a touch occurred on tag zero.\"\n          );\n        }\n      } else {\n        rootNodeID = target;\n      }\n    }\n    // $FlowFixMe Shouldn't we *not* call it if rootNodeID is null?\n    _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);\n  }\n}\n\nvar ReactNativeEventEmitter = Object.freeze({\n  getListener: getListener,\n  registrationNames: registrationNameModules,\n  _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,\n  receiveEvent: receiveEvent,\n  receiveTouches: receiveTouches\n});\n\n// Module provided by RN:\nvar ReactNativeGlobalResponderHandler = {\n  onChange: function(from, to, blockNativeResponder) {\n    if (to !== null) {\n      var tag = to.stateNode._nativeTag;\n      UIManager.setJSResponder(tag, blockNativeResponder);\n    } else {\n      UIManager.clearJSResponder();\n    }\n  }\n};\n\n// Module provided by RN:\n/**\n * Register the event emitter with the native bridge\n */\nRCTEventEmitter.register(ReactNativeEventEmitter);\n\nsetComponentTree(\n  getFiberCurrentPropsFromNode$1,\n  getInstanceFromTag,\n  getTagFromInstance\n);\n\nResponderEventPlugin.injection.injectGlobalResponderHandler(\n  ReactNativeGlobalResponderHandler\n);\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\nfunction get$1(key) {\n  return key._reactInternalFiber;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactSharedInternals =\n  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol.for(\"react.strict_mode\")\n  : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol.for(\"react.forward_ref\")\n  : 0xead0;\nvar REACT_PLACEHOLDER_TYPE = hasSymbol\n  ? Symbol.for(\"react.placeholder\")\n  : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n    return null;\n  }\n  var maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === \"function\") {\n    return maybeIterator;\n  }\n  return null;\n}\n\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction getResultFromResolvedThenable(thenable) {\n  return thenable._reactResult;\n}\n\nfunction refineResolvedThenable(thenable) {\n  return thenable._reactStatus === Resolved ? thenable._reactResult : null;\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  {\n    if (typeof type.tag === \"number\") {\n      warningWithoutStack$1(\n        false,\n        \"Received an unexpected object in getComponentName(). \" +\n          \"This is likely a bug in React. Please file an issue.\"\n      );\n    }\n  }\n  if (typeof type === \"function\") {\n    return type.displayName || type.name || null;\n  }\n  if (typeof type === \"string\") {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return \"AsyncMode\";\n    case REACT_FRAGMENT_TYPE:\n      return \"Fragment\";\n    case REACT_PORTAL_TYPE:\n      return \"Portal\";\n    case REACT_PROFILER_TYPE:\n      return \"Profiler\";\n    case REACT_STRICT_MODE_TYPE:\n      return \"StrictMode\";\n    case REACT_PLACEHOLDER_TYPE:\n      return \"Placeholder\";\n  }\n  if (typeof type === \"object\") {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return \"Context.Consumer\";\n      case REACT_PROVIDER_TYPE:\n        return \"Context.Provider\";\n      case REACT_FORWARD_REF_TYPE:\n        var renderFn = type.render;\n        var functionName = renderFn.displayName || renderFn.name || \"\";\n        return functionName !== \"\"\n          ? \"ForwardRef(\" + functionName + \")\"\n          : \"ForwardRef\";\n    }\n    if (typeof type.then === \"function\") {\n      var thenable = type;\n      var resolvedThenable = refineResolvedThenable(thenable);\n      if (resolvedThenable) {\n        return getComponentName(resolvedThenable);\n      }\n    }\n  }\n  return null;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */ 0;\nvar PerformedWork = /*         */ 1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */ 2;\nvar Update = /*                */ 4;\nvar PlacementAndUpdate = /*    */ 6;\nvar Deletion = /*              */ 8;\nvar ContentReset = /*          */ 16;\nvar Callback = /*              */ 32;\nvar DidCapture = /*            */ 64;\nvar Ref = /*                   */ 128;\nvar Snapshot = /*              */ 256;\n\n// Update & Callback & Ref & Snapshot\nvar LifecycleEffectMask = /*   */ 420;\n\n// Union of all host effects\nvar HostEffectMask = /*        */ 511;\n\nvar Incomplete = /*            */ 512;\nvar ShouldCapture = /*         */ 1024;\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node.return) {\n      node = node.return;\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner$1.current;\n    if (\n      owner !== null &&\n      (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)\n    ) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender\n        ? warningWithoutStack$1(\n            false,\n            \"%s is accessing isMounted inside its render() function. \" +\n              \"render() should be a pure function of props and state. It should \" +\n              \"never access something that requires stale data from the previous \" +\n              \"render, such as refs. Move this logic to componentDidMount and \" +\n              \"componentDidUpdate instead.\",\n            getComponentName(ownerFiber.type) || \"A component\"\n          )\n        : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get$1(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    isFiberMountedImpl(fiber) === MOUNTED,\n    \"Unable to find node on an unmounted component.\"\n  );\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    invariant(\n      state !== UNMOUNTED,\n      \"Unable to find node on an unmounted component.\"\n    );\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a.return;\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        invariant(\n          didFindChild,\n          \"Child was not found in either parent set. This indicates a bug \" +\n            \"in React related to the return pointer. Please file an issue.\"\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    \"Unable to find node on an unmounted component.\"\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\n// Modules provided by RN:\nvar emptyObject = {};\n\n/**\n * Create a payload that contains all the updates between two sets of props.\n *\n * These helpers are all encapsulated into a single module, because they use\n * mutation as a performance optimization which leads to subtle shared\n * dependencies between the code paths. To avoid this mutable state leaking\n * across modules, I've kept them isolated to this module.\n */\n\n// Tracks removed keys\nvar removedKeys = null;\nvar removedKeyCount = 0;\n\nfunction defaultDiffer(prevProp, nextProp) {\n  if (typeof nextProp !== \"object\" || nextProp === null) {\n    // Scalars have already been checked for equality\n    return true;\n  } else {\n    // For objects and arrays, the default diffing algorithm is a deep compare\n    return deepDiffer(prevProp, nextProp);\n  }\n}\n\nfunction restoreDeletedValuesInNestedArray(\n  updatePayload,\n  node,\n  validAttributes\n) {\n  if (Array.isArray(node)) {\n    var i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(\n        updatePayload,\n        node[i],\n        validAttributes\n      );\n    }\n  } else if (node && removedKeyCount > 0) {\n    var obj = node;\n    for (var propKey in removedKeys) {\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      var nextProp = obj[propKey];\n      if (nextProp === undefined) {\n        continue;\n      }\n\n      var attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue; // not a valid native prop\n      }\n\n      if (typeof nextProp === \"function\") {\n        nextProp = true;\n      }\n      if (typeof nextProp === \"undefined\") {\n        nextProp = null;\n      }\n\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\n\nfunction diffNestedArrayProperty(\n  updatePayload,\n  prevArray,\n  nextArray,\n  validAttributes\n) {\n  var minLength =\n    prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n  var i = void 0;\n  for (i = 0; i < minLength; i++) {\n    // Diff any items in the array in the forward direction. Repeated keys\n    // will be overwritten by later values.\n    updatePayload = diffNestedProperty(\n      updatePayload,\n      prevArray[i],\n      nextArray[i],\n      validAttributes\n    );\n  }\n  for (; i < prevArray.length; i++) {\n    // Clear out all remaining properties.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevArray[i],\n      validAttributes\n    );\n  }\n  for (; i < nextArray.length; i++) {\n    // Add all remaining properties.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextArray[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\nfunction diffNestedProperty(\n  updatePayload,\n  prevProp,\n  nextProp,\n  validAttributes\n) {\n  if (!updatePayload && prevProp === nextProp) {\n    // If no properties have been added, then we can bail out quickly on object\n    // equality.\n    return updatePayload;\n  }\n\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    // Both are leaves, we can diff the leaves.\n    return diffProperties(updatePayload, prevProp, nextProp, validAttributes);\n  }\n\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    // Both are arrays, we can diff the arrays.\n    return diffNestedArrayProperty(\n      updatePayload,\n      prevProp,\n      nextProp,\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp)) {\n    return diffProperties(\n      updatePayload,\n      // $FlowFixMe - We know that this is always an object when the input is.\n      flattenStyle(prevProp),\n      // $FlowFixMe - We know that this isn't an array because of above flow.\n      nextProp,\n      validAttributes\n    );\n  }\n\n  return diffProperties(\n    updatePayload,\n    prevProp,\n    // $FlowFixMe - We know that this is always an object when the input is.\n    flattenStyle(nextProp),\n    validAttributes\n  );\n}\n\n/**\n * addNestedProperty takes a single set of props and valid attribute\n * attribute configurations. It processes each prop and adds it to the\n * updatePayload.\n */\nfunction addNestedProperty(updatePayload, nextProp, validAttributes) {\n  if (!nextProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(nextProp)) {\n    // Add each property of the leaf.\n    return addProperties(updatePayload, nextProp, validAttributes);\n  }\n\n  for (var i = 0; i < nextProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextProp[i],\n      validAttributes\n    );\n  }\n\n  return updatePayload;\n}\n\n/**\n * clearNestedProperty takes a single set of props and valid attributes. It\n * adds a null sentinel to the updatePayload, for each prop key.\n */\nfunction clearNestedProperty(updatePayload, prevProp, validAttributes) {\n  if (!prevProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp)) {\n    // Add each property of the leaf.\n    return clearProperties(updatePayload, prevProp, validAttributes);\n  }\n\n  for (var i = 0; i < prevProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevProp[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\n/**\n * diffProperties takes two sets of props and a set of valid attributes\n * and write to updatePayload the values that changed or were deleted.\n * If no updatePayload is provided, a new one is created and returned if\n * anything changed.\n */\nfunction diffProperties(updatePayload, prevProps, nextProps, validAttributes) {\n  var attributeConfig = void 0;\n  var nextProp = void 0;\n  var prevProp = void 0;\n\n  for (var propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n\n    // functions are converted to booleans as markers that the associated\n    // events should be sent from native.\n    if (typeof nextProp === \"function\") {\n      nextProp = true;\n      // If nextProp is not a function, then don't bother changing prevProp\n      // since nextProp will win and go into the updatePayload regardless.\n      if (typeof prevProp === \"function\") {\n        prevProp = true;\n      }\n    }\n\n    // An explicit value of undefined is treated as a null because it overrides\n    // any other preceding value.\n    if (typeof nextProp === \"undefined\") {\n      nextProp = null;\n      if (typeof prevProp === \"undefined\") {\n        prevProp = null;\n      }\n    }\n\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // Something else already triggered an update to this key because another\n      // value diffed. Since we're now later in the nested arrays our value is\n      // more important so we need to calculate it and override the existing\n      // value. It doesn't matter if nothing changed, we'll set it anyway.\n\n      // Pattern match on: attributeConfig\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n\n    if (prevProp === nextProp) {\n      continue; // nothing changed\n    }\n\n    // Pattern match on: attributeConfig\n    if (typeof attributeConfig !== \"object\") {\n      // case: !Object is the default case\n      if (defaultDiffer(prevProp, nextProp)) {\n        // a normal leaf has changed\n        (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n      }\n    } else if (\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration\n      var shouldUpdate =\n        prevProp === undefined ||\n        (typeof attributeConfig.diff === \"function\"\n          ? attributeConfig.diff(prevProp, nextProp)\n          : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        var _nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        (updatePayload || (updatePayload = {}))[propKey] = _nextValue;\n      }\n    } else {\n      // default: fallthrough case when nested properties are defined\n      removedKeys = null;\n      removedKeyCount = 0;\n      // We think that attributeConfig is not CustomAttributeConfiguration at\n      // this point so we assume it must be AttributeConfiguration.\n      updatePayload = diffNestedProperty(\n        updatePayload,\n        prevProp,\n        nextProp,\n        attributeConfig\n      );\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(\n          updatePayload,\n          nextProp,\n          attributeConfig\n        );\n        removedKeys = null;\n      }\n    }\n  }\n\n  // Also iterate through all the previous props to catch any that have been\n  // removed and make sure native gets the signal so it can reset them to the\n  // default.\n  for (var _propKey in prevProps) {\n    if (nextProps[_propKey] !== undefined) {\n      continue; // we've already covered this key in the previous pass\n    }\n    attributeConfig = validAttributes[_propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    if (updatePayload && updatePayload[_propKey] !== undefined) {\n      // This was already updated to a diff result earlier.\n      continue;\n    }\n\n    prevProp = prevProps[_propKey];\n    if (prevProp === undefined) {\n      continue; // was already empty anyway\n    }\n    // Pattern match on: attributeConfig\n    if (\n      typeof attributeConfig !== \"object\" ||\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration | !Object\n      // Flag the leaf property for removal by sending a sentinel.\n      (updatePayload || (updatePayload = {}))[_propKey] = null;\n      if (!removedKeys) {\n        removedKeys = {};\n      }\n      if (!removedKeys[_propKey]) {\n        removedKeys[_propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      // default:\n      // This is a nested attribute configuration where all the properties\n      // were removed so we need to go through and clear out all of them.\n      updatePayload = clearNestedProperty(\n        updatePayload,\n        prevProp,\n        attributeConfig\n      );\n    }\n  }\n  return updatePayload;\n}\n\n/**\n * addProperties adds all the valid props to the payload after being processed.\n */\nfunction addProperties(updatePayload, props, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(updatePayload, emptyObject, props, validAttributes);\n}\n\n/**\n * clearProperties clears all the previous props by adding a null sentinel\n * to the payload for each valid key.\n */\nfunction clearProperties(updatePayload, prevProps, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);\n}\n\nfunction create(props, validAttributes) {\n  return addProperties(\n    null, // updatePayload\n    props,\n    validAttributes\n  );\n}\n\nfunction diff(prevProps, nextProps, validAttributes) {\n  return diffProperties(\n    null, // updatePayload\n    prevProps,\n    nextProps,\n    validAttributes\n  );\n}\n\n/**\n * In the future, we should cleanup callbacks by cancelling them instead of\n * using this.\n */\nfunction mountSafeCallback_NOT_REALLY_SAFE(context, callback) {\n  return function() {\n    if (!callback) {\n      return undefined;\n    }\n    // This protects against createClass() components.\n    // We don't know if there is code depending on it.\n    // We intentionally don't use isMounted() because even accessing\n    // isMounted property on a React ES6 class will trigger a warning.\n    if (typeof context.__isMounted === \"boolean\") {\n      if (!context.__isMounted) {\n        return undefined;\n      }\n    }\n\n    // FIXME: there used to be other branches that protected\n    // against unmounted host components. But RN host components don't\n    // define isMounted() anymore, so those checks didn't do anything.\n\n    // They caused false positive warning noise so we removed them:\n    // https://github.com/facebook/react-native/issues/18868#issuecomment-413579095\n\n    // However, this means that the callback is NOT guaranteed to be safe\n    // for host components. The solution we should implement is to make\n    // UIManager.measure() and similar calls truly cancelable. Then we\n    // can change our own code calling them to cancel when something unmounts.\n\n    return callback.apply(context, arguments);\n  };\n}\n\nfunction throwOnStylesProp(component, props) {\n  if (props.styles !== undefined) {\n    var owner = component._owner || null;\n    var name = component.constructor.displayName;\n    var msg =\n      \"`styles` is not a supported property of `\" +\n      name +\n      \"`, did \" +\n      \"you mean `style` (singular)?\";\n    if (owner && owner.constructor && owner.constructor.displayName) {\n      msg +=\n        \"\\n\\nCheck the `\" +\n        owner.constructor.displayName +\n        \"` parent \" +\n        \" component.\";\n    }\n    throw new Error(msg);\n  }\n}\n\nfunction warnForStyleProps(props, validAttributes) {\n  for (var key in validAttributes.style) {\n    if (!(validAttributes[key] || props[key] === undefined)) {\n      console.error(\n        \"You are setting the style `{ \" +\n          key +\n          \": ... }` as a prop. You \" +\n          \"should nest it in a style object. \" +\n          \"E.g. `{ style: { \" +\n          key +\n          \": ... } }`\"\n      );\n    }\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// Modules provided by RN:\n/**\n * This component defines the same methods as NativeMethodsMixin but without the\n * findNodeHandle wrapper. This wrapper is unnecessary for HostComponent views\n * and would also result in a circular require.js dependency (since\n * ReactNativeFiber depends on this component and NativeMethodsMixin depends on\n * ReactNativeFiber).\n */\n\nvar ReactNativeFiberHostComponent = (function() {\n  function ReactNativeFiberHostComponent(tag, viewConfig) {\n    _classCallCheck(this, ReactNativeFiberHostComponent);\n\n    this._nativeTag = tag;\n    this._children = [];\n    this.viewConfig = viewConfig;\n  }\n\n  ReactNativeFiberHostComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(\n      this._nativeTag,\n      mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      this._nativeTag,\n      mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      this._nativeTag,\n      relativeToNativeNode,\n      mountSafeCallback_NOT_REALLY_SAFE(this, onFail),\n      mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    {\n      warnForStyleProps(nativeProps, this.viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, this.viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        this._nativeTag,\n        this.viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeFiberHostComponent;\n})();\n\nvar hasNativePerformanceNow =\n  typeof performance === \"object\" && typeof performance.now === \"function\";\n\nvar now$1 = hasNativePerformanceNow\n  ? function() {\n      return performance.now();\n    }\n  : function() {\n      return Date.now();\n    };\n\nvar scheduledCallback = null;\nvar frameDeadline = 0;\n\nvar frameDeadlineObject = {\n  timeRemaining: function() {\n    return frameDeadline - now$1();\n  },\n  didTimeout: false\n};\n\nfunction setTimeoutCallback() {\n  // TODO (bvaughn) Hard-coded 5ms unblocks initial async testing.\n  // React API probably changing to boolean rather than time remaining.\n  // Longer-term plan is to rewrite this using shared memory,\n  // And just return the value of the bit as the boolean.\n  frameDeadline = now$1() + 5;\n\n  var callback = scheduledCallback;\n  scheduledCallback = null;\n  if (callback !== null) {\n    callback(frameDeadlineObject);\n  }\n}\n\n// RN has a poor polyfill for requestIdleCallback so we aren't using it.\n// This implementation is only intended for short-term use anyway.\n// We also don't implement cancel functionality b'c Fiber doesn't currently need it.\nfunction scheduleDeferredCallback$1(callback, options) {\n  // We assume only one callback is scheduled at a time b'c that's how Fiber works.\n  scheduledCallback = callback;\n  var timeoutId = setTimeout(setTimeoutCallback, 1);\n  return timeoutId; // Timeouts are always numbers on RN\n}\n\nfunction cancelDeferredCallback$1(callbackID) {\n  scheduledCallback = null;\n  clearTimeout(callbackID); // Timeouts are always numbers on RN\n}\n\n// Renderers that don't support persistence\n// can re-export everything from this module.\n\nfunction shim() {\n  invariant(\n    false,\n    \"The current renderer does not support persistence. \" +\n      \"This error is likely caused by a bug in React. \" +\n      \"Please file an issue.\"\n  );\n}\n\n// Persistence (when unsupported)\nvar supportsPersistence = false;\nvar cloneInstance = shim;\nvar createContainerChildSet = shim;\nvar appendChildToContainerChildSet = shim;\nvar finalizeContainerChildren = shim;\nvar replaceContainerChildren = shim;\n\n// Renderers that don't support hydration\n// can re-export everything from this module.\n\nfunction shim$1() {\n  invariant(\n    false,\n    \"The current renderer does not support hyration. \" +\n      \"This error is likely caused by a bug in React. \" +\n      \"Please file an issue.\"\n  );\n}\n\n// Hydration (when unsupported)\nvar supportsHydration = false;\nvar canHydrateInstance = shim$1;\nvar canHydrateTextInstance = shim$1;\nvar getNextHydratableSibling = shim$1;\nvar getFirstHydratableChild = shim$1;\nvar hydrateInstance = shim$1;\nvar hydrateTextInstance = shim$1;\nvar didNotMatchHydratedContainerTextInstance = shim$1;\nvar didNotMatchHydratedTextInstance = shim$1;\nvar didNotHydrateContainerInstance = shim$1;\nvar didNotHydrateInstance = shim$1;\nvar didNotFindHydratableContainerInstance = shim$1;\nvar didNotFindHydratableContainerTextInstance = shim$1;\nvar didNotFindHydratableInstance = shim$1;\nvar didNotFindHydratableTextInstance = shim$1;\n\n// Modules provided by RN:\n// Unused\n\nvar UPDATE_SIGNAL = {};\n{\n  Object.freeze(UPDATE_SIGNAL);\n}\n\n// Counter for uniquely identifying views.\n// % 10 === 1 means it is a rootTag.\n// % 2 === 0 means it is a Fabric tag.\nvar nextReactTag = 3;\nfunction allocateTag() {\n  var tag = nextReactTag;\n  if (tag % 10 === 1) {\n    tag += 2;\n  }\n  nextReactTag = tag + 2;\n  return tag;\n}\n\nfunction recursivelyUncacheFiberNode(node) {\n  if (typeof node === \"number\") {\n    // Leaf node (eg text)\n    uncacheFiberNode(node);\n  } else {\n    uncacheFiberNode(node._nativeTag);\n\n    node._children.forEach(recursivelyUncacheFiberNode);\n  }\n}\n\nfunction appendInitialChild(parentInstance, child) {\n  parentInstance._children.push(child);\n}\n\nfunction createInstance(\n  type,\n  props,\n  rootContainerInstance,\n  hostContext,\n  internalInstanceHandle\n) {\n  var tag = allocateTag();\n  var viewConfig = ReactNativeViewConfigRegistry.get(type);\n\n  {\n    for (var key in viewConfig.validAttributes) {\n      if (props.hasOwnProperty(key)) {\n        deepFreezeAndThrowOnMutationInDev(props[key]);\n      }\n    }\n  }\n\n  invariant(\n    type !== \"RCTView\" || !hostContext.isInAParentText,\n    \"Nesting of <View> within <Text> is not currently supported.\"\n  );\n\n  var updatePayload = create(props, viewConfig.validAttributes);\n\n  UIManager.createView(\n    tag, // reactTag\n    viewConfig.uiViewClassName, // viewName\n    rootContainerInstance, // rootTag\n    updatePayload // props\n  );\n\n  var component = new ReactNativeFiberHostComponent(tag, viewConfig);\n\n  precacheFiberNode(internalInstanceHandle, tag);\n  updateFiberProps(tag, props);\n\n  // Not sure how to avoid this cast. Flow is okay if the component is defined\n  // in the same file but if it's external it can't see the types.\n  return component;\n}\n\nfunction createTextInstance(\n  text,\n  rootContainerInstance,\n  hostContext,\n  internalInstanceHandle\n) {\n  invariant(\n    hostContext.isInAParentText,\n    \"Text strings must be rendered within a <Text> component.\"\n  );\n\n  var tag = allocateTag();\n\n  UIManager.createView(\n    tag, // reactTag\n    \"RCTRawText\", // viewName\n    rootContainerInstance, // rootTag\n    { text: text } // props\n  );\n\n  precacheFiberNode(internalInstanceHandle, tag);\n\n  return tag;\n}\n\nfunction finalizeInitialChildren(\n  parentInstance,\n  type,\n  props,\n  rootContainerInstance,\n  hostContext\n) {\n  // Don't send a no-op message over the bridge.\n  if (parentInstance._children.length === 0) {\n    return false;\n  }\n\n  // Map from child objects to native tags.\n  // Either way we need to pass a copy of the Array to prevent it from being frozen.\n  var nativeTags = parentInstance._children.map(function(child) {\n    return typeof child === \"number\"\n      ? child // Leaf node (eg text)\n      : child._nativeTag;\n  });\n\n  UIManager.setChildren(\n    parentInstance._nativeTag, // containerTag\n    nativeTags // reactTags\n  );\n\n  return false;\n}\n\nfunction getRootHostContext(rootContainerInstance) {\n  return { isInAParentText: false };\n}\n\nfunction getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  var prevIsInAParentText = parentHostContext.isInAParentText;\n  var isInAParentText =\n    type === \"AndroidTextInput\" || // Android\n    type === \"RCTMultilineTextInputView\" || // iOS\n    type === \"RCTSinglelineTextInputView\" || // iOS\n    type === \"RCTText\" ||\n    type === \"RCTVirtualText\";\n\n  if (prevIsInAParentText !== isInAParentText) {\n    return { isInAParentText: isInAParentText };\n  } else {\n    return parentHostContext;\n  }\n}\n\nfunction getPublicInstance(instance) {\n  return instance;\n}\n\nfunction prepareForCommit(containerInfo) {\n  // Noop\n}\n\nfunction prepareUpdate(\n  instance,\n  type,\n  oldProps,\n  newProps,\n  rootContainerInstance,\n  hostContext\n) {\n  return UPDATE_SIGNAL;\n}\n\nfunction resetAfterCommit(containerInfo) {\n  // Noop\n}\n\nvar now = now$1;\nvar isPrimaryRenderer = true;\nvar scheduleDeferredCallback = scheduleDeferredCallback$1;\nvar cancelDeferredCallback = cancelDeferredCallback$1;\n\nvar scheduleTimeout = setTimeout;\nvar cancelTimeout = clearTimeout;\nvar noTimeout = -1;\n\nfunction shouldDeprioritizeSubtree(type, props) {\n  return false;\n}\n\nfunction shouldSetTextContent(type, props) {\n  // TODO (bvaughn) Revisit this decision.\n  // Always returning false simplifies the createInstance() implementation,\n  // But creates an additional child Fiber for raw text children.\n  // No additional native views are created though.\n  // It's not clear to me which is better so I'm deferring for now.\n  // More context @ github.com/facebook/react/pull/8560#discussion_r92111303\n  return false;\n}\n\n// -------------------\n//     Mutation\n// -------------------\n\nvar supportsMutation = true;\n\nfunction appendChild(parentInstance, child) {\n  var childTag = typeof child === \"number\" ? child : child._nativeTag;\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  if (index >= 0) {\n    children.splice(index, 1);\n    children.push(child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerTag\n      [index], // moveFromIndices\n      [children.length - 1], // moveToIndices\n      [], // addChildReactTags\n      [], // addAtIndices\n      [] // removeAtIndices\n    );\n  } else {\n    children.push(child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerTag\n      [], // moveFromIndices\n      [], // moveToIndices\n      [childTag], // addChildReactTags\n      [children.length - 1], // addAtIndices\n      [] // removeAtIndices\n    );\n  }\n}\n\nfunction appendChildToContainer(parentInstance, child) {\n  var childTag = typeof child === \"number\" ? child : child._nativeTag;\n  UIManager.setChildren(\n    parentInstance, // containerTag\n    [childTag] // reactTags\n  );\n}\n\nfunction commitTextUpdate(textInstance, oldText, newText) {\n  UIManager.updateView(\n    textInstance, // reactTag\n    \"RCTRawText\", // viewName\n    { text: newText } // props\n  );\n}\n\nfunction commitUpdate(\n  instance,\n  updatePayloadTODO,\n  type,\n  oldProps,\n  newProps,\n  internalInstanceHandle\n) {\n  var viewConfig = instance.viewConfig;\n\n  updateFiberProps(instance._nativeTag, newProps);\n\n  var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);\n\n  // Avoid the overhead of bridge calls if there's no update.\n  // This is an expensive no-op for Android, and causes an unnecessary\n  // view invalidation for certain components (eg RCTTextInput) on iOS.\n  if (updatePayload != null) {\n    UIManager.updateView(\n      instance._nativeTag, // reactTag\n      viewConfig.uiViewClassName, // viewName\n      updatePayload // props\n    );\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  // Move existing child or add new child?\n  if (index >= 0) {\n    children.splice(index, 1);\n    var beforeChildIndex = children.indexOf(beforeChild);\n    children.splice(beforeChildIndex, 0, child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerID\n      [index], // moveFromIndices\n      [beforeChildIndex], // moveToIndices\n      [], // addChildReactTags\n      [], // addAtIndices\n      [] // removeAtIndices\n    );\n  } else {\n    var _beforeChildIndex = children.indexOf(beforeChild);\n    children.splice(_beforeChildIndex, 0, child);\n\n    var childTag = typeof child === \"number\" ? child : child._nativeTag;\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerID\n      [], // moveFromIndices\n      [], // moveToIndices\n      [childTag], // addChildReactTags\n      [_beforeChildIndex], // addAtIndices\n      [] // removeAtIndices\n    );\n  }\n}\n\nfunction insertInContainerBefore(parentInstance, child, beforeChild) {\n  // TODO (bvaughn): Remove this check when...\n  // We create a wrapper object for the container in ReactNative render()\n  // Or we refactor to remove wrapper objects entirely.\n  // For more info on pros/cons see PR #8560 description.\n  invariant(\n    typeof parentInstance !== \"number\",\n    \"Container does not support insertBefore operation\"\n  );\n}\n\nfunction removeChild(parentInstance, child) {\n  recursivelyUncacheFiberNode(child);\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  children.splice(index, 1);\n\n  UIManager.manageChildren(\n    parentInstance._nativeTag, // containerID\n    [], // moveFromIndices\n    [], // moveToIndices\n    [], // addChildReactTags\n    [], // addAtIndices\n    [index] // removeAtIndices\n  );\n}\n\nfunction removeChildFromContainer(parentInstance, child) {\n  recursivelyUncacheFiberNode(child);\n  UIManager.manageChildren(\n    parentInstance, // containerID\n    [], // moveFromIndices\n    [], // moveToIndices\n    [], // addChildReactTags\n    [], // addAtIndices\n    [0] // removeAtIndices\n  );\n}\n\nfunction resetTextContent(instance) {\n  // Noop\n}\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nvar describeComponentFrame = function(name, source, ownerName) {\n  var sourceInfo = \"\";\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, \"\");\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n        if (match) {\n          var pathBeforeSlash = match[1];\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, \"\");\n            fileName = folderName + \"/\" + fileName;\n          }\n        }\n      }\n    }\n    sourceInfo = \" (at \" + fileName + \":\" + source.lineNumber + \")\";\n  } else if (ownerName) {\n    sourceInfo = \" (created by \" + ownerName + \")\";\n  }\n  return \"\\n    in \" + (name || \"Unknown\") + sourceInfo;\n};\n\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case FunctionalComponentLazy:\n    case ClassComponent:\n    case ClassComponentLazy:\n    case HostComponent:\n    case Mode:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber.type);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner.type);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return \"\";\n  }\n}\n\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  var info = \"\";\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    node = node.return;\n  } while (node);\n  return info;\n}\n\nvar current = null;\nvar phase = null;\n\nfunction getCurrentFiberOwnerNameInDevOrNull() {\n  {\n    if (current === null) {\n      return null;\n    }\n    var owner = current._debugOwner;\n    if (owner !== null && typeof owner !== \"undefined\") {\n      return getComponentName(owner.type);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackInDev() {\n  {\n    if (current === null) {\n      return \"\";\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackByFiberInDevAndProd(current);\n  }\n  return \"\";\n}\n\nfunction resetCurrentFiber() {\n  {\n    ReactDebugCurrentFrame.getCurrentStack = null;\n    current = null;\n    phase = null;\n  }\n}\n\nfunction setCurrentFiber(fiber) {\n  {\n    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;\n    current = fiber;\n    phase = null;\n  }\n}\n\nfunction setCurrentPhase(lifeCyclePhase) {\n  {\n    phase = lifeCyclePhase;\n  }\n}\n\nvar debugRenderPhaseSideEffects = false;\nvar debugRenderPhaseSideEffectsForStrictMode = false;\nvar enableGetDerivedStateFromCatch = false;\nvar enableSuspense = false;\nvar enableUserTimingAPI = true;\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\nvar warnAboutDeprecatedLifecycles = false;\nvar warnAboutLegacyContextAPI = false;\nvar enableProfilerTimer = true;\nvar enableSchedulerTracking = true;\n\n// Only used in www builds.\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = \"\\u269B\";\nvar warningEmoji = \"\\u26D4\";\nvar supportsUserTiming =\n  typeof performance !== \"undefined\" &&\n  typeof performance.mark === \"function\" &&\n  typeof performance.clearMarks === \"function\" &&\n  typeof performance.measure === \"function\" &&\n  typeof performance.clearMeasures === \"function\";\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function(markName) {\n  return reactEmoji + \" \" + markName;\n};\n\nvar formatLabel = function(label, warning) {\n  var prefix = warning ? warningEmoji + \" \" : reactEmoji + \" \";\n  var suffix = warning ? \" Warning: \" + warning : \"\";\n  return \"\" + prefix + label + suffix;\n};\n\nvar beginMark = function(markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function(markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function(label, markName, warning) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function(label, debugID) {\n  return label + \" (#\" + debugID + \")\";\n};\n\nvar getFiberLabel = function(componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + \" [\" + (isMounted ? \"update\" : \"mount\") + \"]\";\n  } else {\n    // Composite component methods.\n    return componentName + \".\" + phase;\n  }\n};\n\nvar beginFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber.type) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber.type) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function(fiber, phase, warning) {\n  var componentName = getComponentName(fiber.type) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning);\n};\n\nvar shouldIgnoreFiber = function(fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function() {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function() {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber.return;\n  }\n};\n\nvar resumeTimersRecursively = function(fiber) {\n  if (fiber.return !== null) {\n    resumeTimersRecursively(fiber.return);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function() {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (\n      currentPhase !== null &&\n      currentPhase !== \"componentWillMount\" &&\n      currentPhase !== \"componentWillReceiveProps\"\n    ) {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark(\"(Waiting for async callback...)\");\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning = didExpire ? \"React was blocked by main thread\" : null;\n      endMark(\n        \"(Waiting for async callback... will force flush in \" +\n          expirationTime +\n          \" ms)\",\n        \"(Waiting for async callback...)\",\n        warning\n      );\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning = \"An error was thrown inside this error boundary\";\n    endFiberMark(fiber, null, warning);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning = hasScheduledUpdateInCurrentPhase\n        ? \"Scheduled a cascading update\"\n        : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark(\"(React Tree Reconciliation)\");\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning = \"A top-level update interrupted the previous render\";\n      } else {\n        var componentName = getComponentName(interruptedBy.type) || \"Unknown\";\n        warning =\n          \"An update to \" + componentName + \" interrupted the previous render\";\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning = \"There were cascading updates\";\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot\n      ? \"(React Tree Reconciliation: Completed Root)\"\n      : \"(React Tree Reconciliation: Yielded)\";\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, \"(React Tree Reconciliation)\", warning);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark(\"(Committing Changes)\");\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning = \"Lifecycle hook scheduled a cascading update\";\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning = \"Caused by a cascading update in earlier commit\";\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark(\"(Committing Changes)\", \"(Committing Changes)\", warning);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Snapshot Effects)\");\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Snapshot Effects: \" + count + \" Total)\",\n      \"(Committing Snapshot Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Host Effects)\");\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Host Effects: \" + count + \" Total)\",\n      \"(Committing Host Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Calling Lifecycle Methods)\");\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Calling Lifecycle Methods: \" + count + \" Total)\",\n      \"(Calling Lifecycle Methods)\",\n      null\n    );\n  }\n}\n\nvar valueStack = [];\n\nvar fiberStack = void 0;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warningWithoutStack$1(false, \"Unexpected pop.\");\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warningWithoutStack$1(false, \"Unexpected Fiber popped.\");\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction checkThatStackIsEmpty() {\n  {\n    if (index !== -1) {\n      warningWithoutStack$1(\n        false,\n        \"Expected an empty stack. Something was not reset properly.\"\n      );\n    }\n  }\n}\n\nfunction resetStackAfterFatalErrorInDev() {\n  {\n    index = -1;\n    valueStack.length = 0;\n    fiberStack.length = 0;\n  }\n}\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar emptyContextObject = {};\n{\n  Object.freeze(emptyContextObject);\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyContextObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(\n  workInProgress,\n  Component,\n  didPushOwnContextIfProvider\n) {\n  if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n    // If the fiber is a context provider itself, when we read its context\n    // we may have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyContextObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (\n    instance &&\n    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n  ) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(type) || \"Unknown\";\n    checkPropTypes(\n      contextTypes,\n      context,\n      \"context\",\n      name,\n      getCurrentFiberStackInDev\n    );\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextProvider(type) {\n  var childContextTypes = type.childContextTypes;\n  return childContextTypes !== null && childContextTypes !== undefined;\n}\n\nfunction popContext(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  invariant(\n    contextStackCursor.current === emptyContextObject,\n    \"Unexpected context found on stack. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== \"function\") {\n    {\n      var componentName = getComponentName(type) || \"Unknown\";\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warningWithoutStack$1(\n          false,\n          \"%s.childContextTypes is specified but there is no getChildContext() method \" +\n            \"on the instance. You can either define getChildContext() on %s or remove \" +\n            \"childContextTypes from it.\",\n          componentName,\n          componentName\n        );\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    setCurrentPhase(\"getChildContext\");\n  }\n  startPhaseTimer(fiber, \"getChildContext\");\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    invariant(\n      contextKey in childContextTypes,\n      '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n      getComponentName(type) || \"Unknown\",\n      contextKey\n    );\n  }\n  {\n    var name = getComponentName(type) || \"Unknown\";\n    checkPropTypes(\n      childContextTypes,\n      childContext,\n      \"child context\",\n      name,\n      // In practice, there is one case in which we won't get a stack. It's when\n      // somebody calls unstable_renderSubtreeIntoContainer() and we process\n      // context from the parent component instance. The stack will be missing\n      // because it's outside of the reconciliation, and so the pointer has not\n      // been set. This is rare and doesn't matter. We'll also remove that API.\n      getCurrentFiberStackInDev\n    );\n  }\n\n  return Object.assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext =\n    (instance && instance.__reactInternalMemoizedMergedChildContext) ||\n    emptyContextObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(\n    didPerformWorkStackCursor,\n    didPerformWorkStackCursor.current,\n    workInProgress\n  );\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  var instance = workInProgress.stateNode;\n  invariant(\n    instance,\n    \"Expected to have an instance by this point. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(\n      workInProgress,\n      type,\n      previousContext\n    );\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  invariant(\n    isFiberMounted(fiber) &&\n      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy),\n    \"Expected subtree parent to be a mounted class component. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  var node = fiber;\n  do {\n    switch (node.tag) {\n      case HostRoot:\n        return node.stateNode.context;\n      case ClassComponent: {\n        var Component = node.type;\n        if (isContextProvider(Component)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n        break;\n      }\n      case ClassComponentLazy: {\n        var _Component = getResultFromResolvedThenable(node.type);\n        if (isContextProvider(_Component)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n        break;\n      }\n    }\n    node = node.return;\n  } while (node !== null);\n  invariant(\n    false,\n    \"Found unexpected detached subtree parent. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function(arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warningWithoutStack$1(\n          false,\n          \"React DevTools encountered an error: %s\",\n          err\n        );\n      }\n    }\n  };\n}\n\nvar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warningWithoutStack$1(\n        false,\n        \"The installed version of React DevTools is too old and will not work \" +\n          \"with the current version of React. Please update React DevTools. \" +\n          \"https://fb.me/react-devtools\"\n      );\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function(root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function(fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warningWithoutStack$1(\n        false,\n        \"React DevTools encountered an error: %s.\",\n        err\n      );\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === \"function\") {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === \"function\") {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = maxSigned31BitInt;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return (\n    MAGIC_NUMBER_OFFSET +\n    ceiling(\n      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE\n    )\n  );\n}\n\nvar LOW_PRIORITY_EXPIRATION = 5000;\nvar LOW_PRIORITY_BATCH_SIZE = 250;\n\nfunction computeAsyncExpiration(currentTime) {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE\n  );\n}\n\n// We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\n//\n// If the main thread is being blocked so long that you hit the expiration,\n// it's a problem that could be solved with better scheduling.\n//\n// People will be more likely to notice this and fix it with the long\n// expiration time in development.\n//\n// In production we opt for better UX at the risk of masking scheduling\n// problems, by expiring fast.\nvar HIGH_PRIORITY_EXPIRATION = 500;\nvar HIGH_PRIORITY_BATCH_SIZE = 100;\n\nfunction computeInteractiveExpiration(currentTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE\n  );\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\nvar ProfileMode = 4;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.firstContextDependency = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function(tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction resolveLazyComponentTag(fiber, Component) {\n  if (typeof Component === \"function\") {\n    return shouldConstruct(Component)\n      ? ClassComponentLazy\n      : FunctionalComponentLazy;\n  } else if (\n    Component !== undefined &&\n    Component !== null &&\n    Component.$$typeof\n  ) {\n    return ForwardRefLazy;\n  }\n  return IndeterminateComponent;\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode\n    );\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  }\n\n  // Don't touching the subtree's expiration time, which has not changed.\n  workInProgress.childExpirationTime = current.childExpirationTime;\n  if (pendingProps !== current.pendingProps) {\n    // This fiber has new props.\n    workInProgress.expirationTime = expirationTime;\n  } else {\n    // This fiber's props have not changed.\n    workInProgress.expirationTime = current.expirationTime;\n  }\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.firstContextDependency = current.firstContextDependency;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === \"function\") {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === \"string\") {\n    fiberTag = HostComponent;\n  } else {\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(\n          pendingProps.children,\n          mode,\n          expirationTime,\n          key\n        );\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n      case REACT_PLACEHOLDER_TYPE:\n        fiberTag = PlaceholderComponent;\n        break;\n      default: {\n        if (typeof type === \"object\" && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n              fiberTag = ContextProvider;\n              break getTag;\n            case REACT_CONTEXT_TYPE:\n              // This is a consumer\n              fiberTag = ContextConsumer;\n              break getTag;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = ForwardRef;\n              break getTag;\n            default: {\n              if (typeof type.then === \"function\") {\n                fiberTag = IndeterminateComponent;\n                break getTag;\n              }\n            }\n          }\n        }\n        var info = \"\";\n        {\n          if (\n            type === undefined ||\n            (typeof type === \"object\" &&\n              type !== null &&\n              Object.keys(type).length === 0)\n          ) {\n            info +=\n              \" You likely forgot to export your component from the file \" +\n              \"it's defined in, or you might have mixed up default and \" +\n              \"named imports.\";\n          }\n          var ownerName = owner ? getComponentName(owner.type) : null;\n          if (ownerName) {\n            info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n          }\n        }\n        invariant(\n          false,\n          \"Element type is invalid: expected a string (for built-in \" +\n            \"components) or a class/function (for composite components) \" +\n            \"but got: %s.%s\",\n          type == null ? type : typeof type,\n          info\n        );\n      }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, expirationTime, key) {\n  {\n    if (\n      typeof pendingProps.id !== \"string\" ||\n      typeof pendingProps.onRender !== \"function\"\n    ) {\n      warningWithoutStack$1(\n        false,\n        'Profiler must specify an \"id\" string and \"onRender\" function as props'\n      );\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.type = REACT_PROFILER_TYPE;\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = \"DELETED\";\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.firstContextDependency = source.firstContextDependency;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.childExpirationTime = source.childExpirationTime;\n  target.alternate = source.alternate;\n  if (enableProfilerTimer) {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n/* eslint-disable no-use-before-define */\n// TODO: This should be lifted into the renderer.\n\n// The following attributes are only used by interaction tracking builds.\n// They enable interactions to be associated with their async work,\n// And expose interaction metadata to the React DevTools Profiler plugin.\n// Note that these attributes are only defined when the enableSchedulerTracking flag is enabled.\n\n// Exported FiberRoot type includes all properties,\n// To avoid requiring potentially error-prone :any casts throughout the project.\n// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracking is true).\n// The types are defined separately within this file to ensure they stay in sync.\n// (We don't have to use an inline :any cast when enableSchedulerTracking is disabled.)\n\n/* eslint-enable no-use-before-define */\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n\n  var root = void 0;\n  if (enableSchedulerTracking) {\n    root = {\n      current: uninitializedFiber,\n      containerInfo: containerInfo,\n      pendingChildren: null,\n\n      earliestPendingTime: NoWork,\n      latestPendingTime: NoWork,\n      earliestSuspendedTime: NoWork,\n      latestSuspendedTime: NoWork,\n      latestPingedTime: NoWork,\n\n      didError: false,\n\n      pendingCommitExpirationTime: NoWork,\n      finishedWork: null,\n      timeoutHandle: noTimeout,\n      context: null,\n      pendingContext: null,\n      hydrate: hydrate,\n      nextExpirationTimeToWorkOn: NoWork,\n      expirationTime: NoWork,\n      firstBatch: null,\n      nextScheduledRoot: null,\n\n      interactionThreadID: tracking.unstable_getThreadID(),\n      memoizedInteractions: new Set(),\n      pendingInteractionMap: new Map()\n    };\n  } else {\n    root = {\n      current: uninitializedFiber,\n      containerInfo: containerInfo,\n      pendingChildren: null,\n\n      earliestPendingTime: NoWork,\n      latestPendingTime: NoWork,\n      earliestSuspendedTime: NoWork,\n      latestSuspendedTime: NoWork,\n      latestPingedTime: NoWork,\n\n      didError: false,\n\n      pendingCommitExpirationTime: NoWork,\n      finishedWork: null,\n      timeoutHandle: noTimeout,\n      context: null,\n      pendingContext: null,\n      hydrate: hydrate,\n      nextExpirationTimeToWorkOn: NoWork,\n      expirationTime: NoWork,\n      firstBatch: null,\n      nextScheduledRoot: null\n    };\n  }\n\n  uninitializedFiber.stateNode = root;\n\n  // The reason for the way the Flow types are structured in this file,\n  // Is to avoid needing :any casts everywhere interaction tracking fields are used.\n  // Unfortunately that requires an :any cast for non-interaction tracking capable builds.\n  // $FlowFixMe Remove this :any cast and replace it with something better.\n  return root;\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function() {};\n\n{\n  var printWarning = function(format) {\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message =\n      \"Warning: \" +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function(condition, format) {\n    if (format === undefined) {\n      throw new Error(\n        \"`lowPriorityWarning(condition, format, ...args)` requires a warning \" +\n          \"message argument\"\n      );\n    }\n    if (!condition) {\n      for (\n        var _len2 = arguments.length,\n          args = Array(_len2 > 2 ? _len2 - 2 : 0),\n          _key2 = 2;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function() {},\n  flushPendingDeprecationWarnings: function() {},\n  flushPendingUnsafeLifecycleWarnings: function() {},\n  recordDeprecationWarnings: function(fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n  recordLegacyContextWarning: function(fiber, instance) {},\n  flushLegacyContextWarning: function() {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: \"componentDidMount\",\n    UNSAFE_componentWillReceiveProps: \"static getDerivedStateFromProps\",\n    UNSAFE_componentWillUpdate: \"componentDidUpdate\"\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n  var pendingLegacyContextWarning = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n  var didWarnAboutLegacyContext = new Set();\n\n  var setToSortedString = function(set) {\n    var array = [];\n    set.forEach(function(value) {\n      array.push(value);\n    });\n    return array.sort().join(\", \");\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function() {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n    pendingLegacyContextWarning = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n    pendingUnsafeLifecycleWarnings.forEach(function(\n      lifecycleWarningsMap,\n      strictRoot\n    ) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function(lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function(fiber) {\n            componentNames.add(getComponentName(fiber.type) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace(\"UNSAFE_\", \"\");\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = setToSortedString(componentNames);\n\n          lifecyclesWarningMesages.push(\n            formatted +\n              \": Please update the following components to use \" +\n              (suggestion + \" instead: \" + sortedComponentNames)\n          );\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n\n        warningWithoutStack$1(\n          false,\n          \"Unsafe lifecycle methods were found within a strict-mode tree:%s\" +\n            \"\\n\\n%s\" +\n            \"\\n\\nLearn more about this warning here:\" +\n            \"\\nhttps://fb.me/react-strict-mode-warnings\",\n          strictRootComponentStack,\n          lifecyclesWarningMesages.join(\"\\n\\n\")\n        );\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var findStrictRoot = function(fiber) {\n    var maybeStrictRoot = null;\n\n    var node = fiber;\n    while (node !== null) {\n      if (node.mode & StrictMode) {\n        maybeStrictRoot = node;\n      }\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function() {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function(fiber) {\n        uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillMount is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidMount instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillMount.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        sortedNames\n      );\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n        _uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = setToSortedString(_uniqueNames);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillReceiveProps is deprecated and will be removed in the next major version. \" +\n          \"Use static getDerivedStateFromProps instead.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames\n      );\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n        _uniqueNames2.add(getComponentName(fiber.type) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillUpdate is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidUpdate instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillUpdate.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames2\n      );\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function(\n    fiber,\n    instance\n  ) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (\n      typeof instance.componentWillMount === \"function\" &&\n      instance.componentWillMount.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillReceiveProps === \"function\" &&\n      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillUpdate === \"function\" &&\n      instance.componentWillUpdate.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(\n    fiber,\n    instance\n  ) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack$1(\n        false,\n        \"Expected to find a StrictMode component in a strict mode tree. \" +\n          \"This error is likely caused by a bug in React. Please file an issue.\"\n      );\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (\n      (typeof instance.componentWillMount === \"function\" &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true) ||\n      typeof instance.UNSAFE_componentWillMount === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillMount\");\n    }\n    if (\n      (typeof instance.componentWillReceiveProps === \"function\" &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !==\n          true) ||\n      typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillReceiveProps\");\n    }\n    if (\n      (typeof instance.componentWillUpdate === \"function\" &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true) ||\n      typeof instance.UNSAFE_componentWillUpdate === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillUpdate\");\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function(lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function(\n    fiber,\n    instance\n  ) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack$1(\n        false,\n        \"Expected to find a StrictMode component in a strict mode tree. \" +\n          \"This error is likely caused by a bug in React. Please file an issue.\"\n      );\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (\n      fiber.type.contextTypes != null ||\n      fiber.type.childContextTypes != null ||\n      (instance !== null && typeof instance.getChildContext === \"function\")\n    ) {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n    pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n      var uniqueNames = new Set();\n      fiberArray.forEach(function(fiber) {\n        uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n      var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n\n      warningWithoutStack$1(\n        false,\n        \"Legacy context API has been detected within a strict-mode tree: %s\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-strict-mode-warnings\",\n        strictRootComponentStack,\n        sortedNames\n      );\n    });\n  };\n}\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n// TODO: Offscreen updates should never suspend. However, a promise that\n// suspended inside an offscreen subtree should be able to ping at the priority\n// of the outer render.\n\nfunction markPendingPriorityLevel(root, expirationTime) {\n  // If there's a gap between completing a failed root and retrying it,\n  // additional updates may be scheduled. Clear `didError`, in case the update\n  // is sufficient to fix the error.\n  root.didError = false;\n\n  // Update the latest and earliest pending times\n  var earliestPendingTime = root.earliestPendingTime;\n  if (earliestPendingTime === NoWork) {\n    // No other pending updates.\n    root.earliestPendingTime = root.latestPendingTime = expirationTime;\n  } else {\n    if (earliestPendingTime > expirationTime) {\n      // This is the earliest pending update.\n      root.earliestPendingTime = expirationTime;\n    } else {\n      var latestPendingTime = root.latestPendingTime;\n      if (latestPendingTime < expirationTime) {\n        // This is the latest pending update\n        root.latestPendingTime = expirationTime;\n      }\n    }\n  }\n  findNextExpirationTimeToWorkOn(expirationTime, root);\n}\n\nfunction markCommittedPriorityLevels(root, earliestRemainingTime) {\n  root.didError = false;\n\n  if (earliestRemainingTime === NoWork) {\n    // Fast path. There's no remaining work. Clear everything.\n    root.earliestPendingTime = NoWork;\n    root.latestPendingTime = NoWork;\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  // Let's see if the previous latest known pending level was just flushed.\n  var latestPendingTime = root.latestPendingTime;\n  if (latestPendingTime !== NoWork) {\n    if (latestPendingTime < earliestRemainingTime) {\n      // We've flushed all the known pending levels.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      var earliestPendingTime = root.earliestPendingTime;\n      if (earliestPendingTime < earliestRemainingTime) {\n        // We've flushed the earliest known pending level. Set this to the\n        // latest pending time.\n        root.earliestPendingTime = root.latestPendingTime;\n      }\n    }\n  }\n\n  // Now let's handle the earliest remaining level in the whole tree. We need to\n  // decide whether to treat it as a pending level or as suspended. Check\n  // it falls within the range of known suspended levels.\n\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestRemainingTime > latestSuspendedTime) {\n    // The earliest remaining level is later than all the suspended work. That\n    // means we've flushed all the suspended work.\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  if (earliestRemainingTime < earliestSuspendedTime) {\n    // The earliest remaining time is earlier than all the suspended work.\n    // Treat it as a pending update.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  // The earliest remaining time falls within the range of known suspended\n  // levels. We should treat this as suspended work.\n  findNextExpirationTimeToWorkOn(NoWork, root);\n}\n\nfunction hasLowerPriorityWork(root, erroredExpirationTime) {\n  var latestPendingTime = root.latestPendingTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  var latestPingedTime = root.latestPingedTime;\n  return (\n    (latestPendingTime !== NoWork &&\n      latestPendingTime > erroredExpirationTime) ||\n    (latestSuspendedTime !== NoWork &&\n      latestSuspendedTime > erroredExpirationTime) ||\n    (latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime)\n  );\n}\n\nfunction isPriorityLevelSuspended(root, expirationTime) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  return (\n    earliestSuspendedTime !== NoWork &&\n    expirationTime >= earliestSuspendedTime &&\n    expirationTime <= latestSuspendedTime\n  );\n}\n\nfunction markSuspendedPriorityLevel(root, suspendedTime) {\n  root.didError = false;\n  clearPing(root, suspendedTime);\n\n  // First, check the known pending levels and update them if needed.\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPendingTime = root.latestPendingTime;\n  if (earliestPendingTime === suspendedTime) {\n    if (latestPendingTime === suspendedTime) {\n      // Both known pending levels were suspended. Clear them.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      // The earliest pending level was suspended. Clear by setting it to the\n      // latest pending level.\n      root.earliestPendingTime = latestPendingTime;\n    }\n  } else if (latestPendingTime === suspendedTime) {\n    // The latest pending level was suspended. Clear by setting it to the\n    // latest pending level.\n    root.latestPendingTime = earliestPendingTime;\n  }\n\n  // Finally, update the known suspended levels.\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // No other suspended levels.\n    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;\n  } else {\n    if (earliestSuspendedTime > suspendedTime) {\n      // This is the earliest suspended level.\n      root.earliestSuspendedTime = suspendedTime;\n    } else if (latestSuspendedTime < suspendedTime) {\n      // This is the latest suspended level\n      root.latestSuspendedTime = suspendedTime;\n    }\n  }\n\n  findNextExpirationTimeToWorkOn(suspendedTime, root);\n}\n\nfunction markPingedPriorityLevel(root, pingedTime) {\n  root.didError = false;\n\n  // TODO: When we add back resuming, we need to ensure the progressed work\n  // is thrown out and not reused during the restarted render. One way to\n  // invalidate the progressed work is to restart at expirationTime + 1.\n  var latestPingedTime = root.latestPingedTime;\n  if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {\n    root.latestPingedTime = pingedTime;\n  }\n  findNextExpirationTimeToWorkOn(pingedTime, root);\n}\n\nfunction clearPing(root, completedTime) {\n  // TODO: Track whether the root was pinged during the render phase. If so,\n  // we need to make sure we don't lose track of it.\n  var latestPingedTime = root.latestPingedTime;\n  if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {\n    root.latestPingedTime = NoWork;\n  }\n}\n\nfunction findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {\n  var earliestExpirationTime = renderExpirationTime;\n\n  var earliestPendingTime = root.earliestPendingTime;\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (\n    earliestExpirationTime === NoWork ||\n    (earliestPendingTime !== NoWork &&\n      earliestPendingTime < earliestExpirationTime)\n  ) {\n    earliestExpirationTime = earliestPendingTime;\n  }\n  if (\n    earliestExpirationTime === NoWork ||\n    (earliestSuspendedTime !== NoWork &&\n      earliestSuspendedTime < earliestExpirationTime)\n  ) {\n    earliestExpirationTime = earliestSuspendedTime;\n  }\n  return earliestExpirationTime;\n}\n\nfunction didExpireAtExpirationTime(root, currentTime) {\n  var expirationTime = root.expirationTime;\n  if (expirationTime !== NoWork && currentTime >= expirationTime) {\n    // The root has expired. Flush all work up to the current time.\n    root.nextExpirationTimeToWorkOn = currentTime;\n  }\n}\n\nfunction findNextExpirationTimeToWorkOn(completedExpirationTime, root) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPingedTime = root.latestPingedTime;\n\n  // Work on the earliest pending time. Failing that, work on the latest\n  // pinged time.\n  var nextExpirationTimeToWorkOn =\n    earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;\n\n  // If there is no pending or pinged work, check if there's suspended work\n  // that's lower priority than what we just completed.\n  if (\n    nextExpirationTimeToWorkOn === NoWork &&\n    (completedExpirationTime === NoWork ||\n      latestSuspendedTime > completedExpirationTime)\n  ) {\n    // The lowest priority suspended work is the work most likely to be\n    // committed next. Let's start rendering it again, so that if it times out,\n    // it's ready to commit.\n    nextExpirationTimeToWorkOn = latestSuspendedTime;\n  }\n\n  var expirationTime = nextExpirationTimeToWorkOn;\n  if (\n    expirationTime !== NoWork &&\n    earliestSuspendedTime !== NoWork &&\n    earliestSuspendedTime < expirationTime\n  ) {\n    // Expire using the earliest known expiration time.\n    expirationTime = earliestSuspendedTime;\n  }\n\n  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;\n  root.expirationTime = expirationTime;\n}\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which is\n// can be mutated and processed asynchronously before it is committed  a form\n// of double buffering. If a work-in-progress render is discarded before\n// finishing, we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate = false;\n\nvar didWarnUpdateInsideUpdate = void 0;\nvar currentlyProcessingQueue = void 0;\nvar resetCurrentlyProcessingQueue = void 0;\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = function() {\n    currentlyProcessingQueue = null;\n  };\n}\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    firstUpdate: null,\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue(currentQueue) {\n  var queue = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction createUpdate(expirationTime) {\n  return {\n    expirationTime: expirationTime,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n    nextEffect: null\n  };\n}\n\nfunction appendUpdateToQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\nfunction enqueueUpdate(fiber, update) {\n  // Update queues are created lazily.\n  var alternate = fiber.alternate;\n  var queue1 = void 0;\n  var queue2 = void 0;\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(\n          alternate.memoizedState\n        );\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list  we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n\n  {\n    if (\n      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) &&\n      (currentlyProcessingQueue === queue1 ||\n        (queue2 !== null && currentlyProcessingQueue === queue2)) &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      warningWithoutStack$1(\n        false,\n        \"An update (setState, replaceState, or forceUpdate) was scheduled \" +\n          \"from inside an update function. Update functions should be pure, \" +\n          \"with zero side-effects. Consider using componentDidUpdate or a \" +\n          \"callback.\"\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nfunction enqueueCapturedUpdate(workInProgress, update) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  var workInProgressQueue = workInProgress.updateQueue;\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(\n      workInProgress.memoizedState\n    );\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(\n      workInProgress,\n      workInProgressQueue\n    );\n  }\n\n  // Append the update to the end of the list.\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone(workInProgress, queue) {\n  var current = workInProgress.alternate;\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n  return queue;\n}\n\nfunction getStateFromUpdate(\n  workInProgress,\n  queue,\n  update,\n  prevState,\n  nextProps,\n  instance\n) {\n  switch (update.tag) {\n    case ReplaceState: {\n      var _payload = update.payload;\n      if (typeof _payload === \"function\") {\n        // Updater function\n        {\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            _payload.call(instance, prevState, nextProps);\n          }\n        }\n        return _payload.call(instance, prevState, nextProps);\n      }\n      // State object\n      return _payload;\n    }\n    case CaptureUpdate: {\n      workInProgress.effectTag =\n        (workInProgress.effectTag & ~ShouldCapture) | DidCapture;\n    }\n    // Intentional fallthrough\n    case UpdateState: {\n      var _payload2 = update.payload;\n      var partialState = void 0;\n      if (typeof _payload2 === \"function\") {\n        // Updater function\n        {\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            _payload2.call(instance, prevState, nextProps);\n          }\n        }\n        partialState = _payload2.call(instance, prevState, nextProps);\n      } else {\n        // Partial state object\n        partialState = _payload2;\n      }\n      if (partialState === null || partialState === undefined) {\n        // Null and undefined are treated as no-ops.\n        return prevState;\n      }\n      // Merge the partial state and the previous state.\n      return Object.assign({}, prevState, partialState);\n    }\n    case ForceUpdate: {\n      hasForceUpdate = true;\n      return prevState;\n    }\n  }\n  return prevState;\n}\n\nfunction processUpdateQueue(\n  workInProgress,\n  queue,\n  props,\n  instance,\n  renderExpirationTime\n) {\n  hasForceUpdate = false;\n\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  {\n    currentlyProcessingQueue = queue;\n  }\n\n  // These values may change as we process the queue.\n  var newBaseState = queue.baseState;\n  var newFirstUpdate = null;\n  var newExpirationTime = NoWork;\n\n  // Iterate through the list of updates to compute the result.\n  var update = queue.firstUpdate;\n  var resultState = newBaseState;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update;\n        // Since this is the first update that was skipped, the current result\n        // is the new base state.\n        newBaseState = resultState;\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (\n        newExpirationTime === NoWork ||\n        newExpirationTime > updateExpirationTime\n      ) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance\n      );\n      var _callback = update.callback;\n      if (_callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    }\n    // Continue to the next update.\n    update = update.next;\n  }\n\n  // Separately, iterate though the list of captured updates.\n  var newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n  while (update !== null) {\n    var _updateExpirationTime = update.expirationTime;\n    if (_updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update;\n        // If this is the first update that was skipped, the current result is\n        // the new base state.\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (\n        newExpirationTime === NoWork ||\n        newExpirationTime > _updateExpirationTime\n      ) {\n        newExpirationTime = _updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance\n      );\n      var _callback2 = update.callback;\n      if (_callback2 !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate;\n\n  // Set the remaining expiration time to be whatever is remaining in the queue.\n  // This should be fine because the only two other things that contribute to\n  // expiration time are props and context. We're already in the middle of the\n  // begin phase by the time we start processing the queue, so we've already\n  // dealt with the props. Context in components that specify\n  // shouldComponentUpdate is tricky; but we'll have to account for\n  // that regardless.\n  workInProgress.expirationTime = newExpirationTime;\n  workInProgress.memoizedState = resultState;\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  invariant(\n    typeof callback === \"function\",\n    \"Invalid argument passed as callback. Expected a function. Instead \" +\n      \"received: %s\",\n    callback\n  );\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\n\nfunction commitUpdateQueue(\n  finishedWork,\n  finishedQueue,\n  instance,\n  renderExpirationTime\n) {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    }\n    // Clear the list of captured updates.\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  }\n\n  // Commit the effects\n  commitUpdateEffects(finishedQueue.firstEffect, instance);\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n\n  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n}\n\nfunction commitUpdateEffects(effect, instance) {\n  while (effect !== null) {\n    var _callback3 = effect.callback;\n    if (_callback3 !== null) {\n      effect.callback = null;\n      callCallback(_callback3, instance);\n    }\n    effect = effect.nextEffect;\n  }\n}\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = warningWithoutStack$1;\n\n{\n  warning = function(condition, format) {\n    if (condition) {\n      return;\n    }\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n    // eslint-disable-next-line react-internal/warning-and-invariant-args\n\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 2 ? _len - 2 : 0),\n        _key = 2;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    warningWithoutStack$1.apply(\n      undefined,\n      [false, format + \"%s\"].concat(args, [stack])\n    );\n  };\n}\n\nvar warning$1 = warning;\n\nvar valueCursor = createCursor(null);\n\nvar rendererSigil = void 0;\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nvar currentlyRenderingFiber = null;\nvar lastContextDependency = null;\nvar lastContextWithAllBitsObserved = null;\n\nfunction resetContextDependences() {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastContextWithAllBitsObserved = null;\n}\n\nfunction pushProvider(providerFiber, nextValue) {\n  var context = providerFiber.type._context;\n\n  if (isPrimaryRenderer) {\n    push(valueCursor, context._currentValue, providerFiber);\n\n    context._currentValue = nextValue;\n    {\n      !(\n        context._currentRenderer === undefined ||\n        context._currentRenderer === null ||\n        context._currentRenderer === rendererSigil\n      )\n        ? warningWithoutStack$1(\n            false,\n            \"Detected multiple renderers concurrently rendering the \" +\n              \"same context provider. This is currently unsupported.\"\n          )\n        : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(valueCursor, context._currentValue2, providerFiber);\n\n    context._currentValue2 = nextValue;\n    {\n      !(\n        context._currentRenderer2 === undefined ||\n        context._currentRenderer2 === null ||\n        context._currentRenderer2 === rendererSigil\n      )\n        ? warningWithoutStack$1(\n            false,\n            \"Detected multiple renderers concurrently rendering the \" +\n              \"same context provider. This is currently unsupported.\"\n          )\n        : void 0;\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\n\nfunction popProvider(providerFiber) {\n  var currentValue = valueCursor.current;\n\n  pop(valueCursor, providerFiber);\n\n  var context = providerFiber.type._context;\n  if (isPrimaryRenderer) {\n    context._currentValue = currentValue;\n  } else {\n    context._currentValue2 = currentValue;\n  }\n}\n\nfunction calculateChangedBits(context, newValue, oldValue) {\n  // Use Object.is to compare the new context value to the old value. Inlined\n  // Object.is polyfill.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n  if (\n    (oldValue === newValue &&\n      (oldValue !== 0 || 1 / oldValue === 1 / newValue)) ||\n    (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare\n  ) {\n    // No change\n    return 0;\n  } else {\n    var changedBits =\n      typeof context._calculateChangedBits === \"function\"\n        ? context._calculateChangedBits(oldValue, newValue)\n        : maxSigned31BitInt;\n\n    {\n      !((changedBits & maxSigned31BitInt) === changedBits)\n        ? warning$1(\n            false,\n            \"calculateChangedBits: Expected the return value to be a \" +\n              \"31-bit integer. Instead received: %s\",\n            changedBits\n          )\n        : void 0;\n    }\n    return changedBits | 0;\n  }\n}\n\nfunction propagateContextChange(\n  workInProgress,\n  context,\n  changedBits,\n  renderExpirationTime\n) {\n  var fiber = workInProgress.child;\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n  while (fiber !== null) {\n    var nextFiber = void 0;\n\n    // Visit this fiber.\n    var dependency = fiber.firstContextDependency;\n    if (dependency !== null) {\n      do {\n        // Check if the context matches.\n        if (\n          dependency.context === context &&\n          (dependency.observedBits & changedBits) !== 0\n        ) {\n          // Match! Schedule an update on this fiber.\n\n          if (\n            fiber.tag === ClassComponent ||\n            fiber.tag === ClassComponentLazy\n          ) {\n            // Schedule a force update on the work-in-progress.\n            var update = createUpdate(renderExpirationTime);\n            update.tag = ForceUpdate;\n            // TODO: Because we don't have a work-in-progress, this will add the\n            // update to the current fiber, too, which means it will persist even if\n            // this render is thrown away. Since it's a race condition, not sure it's\n            // worth fixing.\n            enqueueUpdate(fiber, update);\n          }\n\n          if (\n            fiber.expirationTime === NoWork ||\n            fiber.expirationTime > renderExpirationTime\n          ) {\n            fiber.expirationTime = renderExpirationTime;\n          }\n          var alternate = fiber.alternate;\n          if (\n            alternate !== null &&\n            (alternate.expirationTime === NoWork ||\n              alternate.expirationTime > renderExpirationTime)\n          ) {\n            alternate.expirationTime = renderExpirationTime;\n          }\n          // Update the child expiration time of all the ancestors, including\n          // the alternates.\n          var node = fiber.return;\n          while (node !== null) {\n            alternate = node.alternate;\n            if (\n              node.childExpirationTime === NoWork ||\n              node.childExpirationTime > renderExpirationTime\n            ) {\n              node.childExpirationTime = renderExpirationTime;\n              if (\n                alternate !== null &&\n                (alternate.childExpirationTime === NoWork ||\n                  alternate.childExpirationTime > renderExpirationTime)\n              ) {\n                alternate.childExpirationTime = renderExpirationTime;\n              }\n            } else if (\n              alternate !== null &&\n              (alternate.childExpirationTime === NoWork ||\n                alternate.childExpirationTime > renderExpirationTime)\n            ) {\n              alternate.childExpirationTime = renderExpirationTime;\n            } else {\n              // Neither alternate was updated, which means the rest of the\n              // ancestor path already has sufficient priority.\n              break;\n            }\n            node = node.return;\n          }\n        }\n        nextFiber = fiber.child;\n        dependency = dependency.next;\n      } while (dependency !== null);\n    } else if (fiber.tag === ContextProvider) {\n      // Don't scan deeper if this is a matching provider\n      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n    } else {\n      // Traverse down.\n      nextFiber = fiber.child;\n    }\n\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n        var sibling = nextFiber.sibling;\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        }\n        // No more siblings. Traverse up.\n        nextFiber = nextFiber.return;\n      }\n    }\n    fiber = nextFiber;\n  }\n}\n\nfunction prepareToReadContext(workInProgress, renderExpirationTime) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  lastContextWithAllBitsObserved = null;\n\n  // Reset the work-in-progress list\n  workInProgress.firstContextDependency = null;\n}\n\nfunction readContext(context, observedBits) {\n  if (lastContextWithAllBitsObserved === context) {\n    // Nothing to do. We already observe everything in this context.\n  } else if (observedBits === false || observedBits === 0) {\n    // Do not observe any updates.\n  } else {\n    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.\n    if (\n      typeof observedBits !== \"number\" ||\n      observedBits === maxSigned31BitInt\n    ) {\n      // Observe all updates.\n      lastContextWithAllBitsObserved = context;\n      resolvedObservedBits = maxSigned31BitInt;\n    } else {\n      resolvedObservedBits = observedBits;\n    }\n\n    var contextItem = {\n      context: context,\n      observedBits: resolvedObservedBits,\n      next: null\n    };\n\n    if (lastContextDependency === null) {\n      invariant(\n        currentlyRenderingFiber !== null,\n        \"Context.unstable_read(): Context can only be read while React is \" +\n          \"rendering, e.g. inside the render method or getDerivedStateFromProps.\"\n      );\n      // This is the first dependency in the list\n      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;\n    } else {\n      // Append a new context item.\n      lastContextDependency = lastContextDependency.next = contextItem;\n    }\n  }\n  return isPrimaryRenderer ? context._currentValue : context._currentValue2;\n}\n\nvar NO_CONTEXT = {};\n\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  invariant(\n    c !== NO_CONTEXT,\n    \"Expected host context to exist. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar commitTime = 0;\nvar profilerStartTime = -1;\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  commitTime = now();\n}\n\nfunction startProfilerTimer(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = now();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = now();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  if (profilerStartTime >= 0) {\n    var elapsedTime = now() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n    profilerStartTime = -1;\n  }\n}\n\n/*eslint-disable no-self-compare */\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== \"object\" ||\n    objA === null ||\n    typeof objB !== \"object\" ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nvar emptyRefsObject = new React.Component().refs;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar warnOnUndefinedDerivedState = void 0;\nvar warnOnInvalidCallback = void 0;\nvar didWarnAboutDirectlyAssigningPropsToState = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback, callerName) {\n    if (callback === null || typeof callback === \"function\") {\n      return;\n    }\n    var key = callerName + \"_\" + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warningWithoutStack$1(\n        false,\n        \"%s(...): Expected the last optional `callback` argument to be a \" +\n          \"function. Instead received: %s.\",\n        callerName,\n        callback\n      );\n    }\n  };\n\n  warnOnUndefinedDerivedState = function(type, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentName(type) || \"Component\";\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warningWithoutStack$1(\n          false,\n          \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" +\n            \"You have returned undefined.\",\n          componentName\n        );\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        \"_processChildContext is not available in React 16+. This likely \" +\n          \"means you have multiple copies of React and are attempting to nest \" +\n          \"a React 15 tree inside a React 16 tree using \" +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          \"to make sure you have only one copy of React (and ideally, switch \" +\n          \"to ReactDOM.createPortal).\"\n      );\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(\n  workInProgress,\n  ctor,\n  getDerivedStateFromProps,\n  nextProps\n) {\n  var prevState = workInProgress.memoizedState;\n\n  {\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  var memoizedState =\n    partialState === null || partialState === undefined\n      ? prevState\n      : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function(inst, payload, callback) {\n    var fiber = get$1(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"setState\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueReplaceState: function(inst, payload, callback) {\n    var fiber = get$1(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"replaceState\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueForceUpdate: function(inst, callback) {\n    var fiber = get$1(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"forceUpdate\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  }\n};\n\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextLegacyContext\n) {\n  var instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === \"function\") {\n    startPhaseTimer(workInProgress, \"shouldComponentUpdate\");\n    var shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextLegacyContext\n    );\n    stopPhaseTimer();\n\n    {\n      !(shouldUpdate !== undefined)\n        ? warningWithoutStack$1(\n            false,\n            \"%s.shouldComponentUpdate(): Returned undefined instead of a \" +\n              \"boolean value. Make sure to return true or false.\",\n            getComponentName(ctor) || \"Component\"\n          )\n        : void 0;\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  var instance = workInProgress.stateNode;\n  {\n    var name = getComponentName(ctor) || \"Component\";\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n        warningWithoutStack$1(\n          false,\n          \"%s(...): No `render` method found on the returned component \" +\n            \"instance: did you accidentally return an object from the constructor?\",\n          name\n        );\n      } else {\n        warningWithoutStack$1(\n          false,\n          \"%s(...): No `render` method found on the returned component \" +\n            \"instance: you may have forgotten to define `render`.\",\n          name\n        );\n      }\n    }\n\n    var noGetInitialStateOnES6 =\n      !instance.getInitialState ||\n      instance.getInitialState.isReactClassApproved ||\n      instance.state;\n    !noGetInitialStateOnES6\n      ? warningWithoutStack$1(\n          false,\n          \"getInitialState was defined on %s, a plain JavaScript class. \" +\n            \"This is only supported for classes created using React.createClass. \" +\n            \"Did you mean to define a state property instead?\",\n          name\n        )\n      : void 0;\n    var noGetDefaultPropsOnES6 =\n      !instance.getDefaultProps ||\n      instance.getDefaultProps.isReactClassApproved;\n    !noGetDefaultPropsOnES6\n      ? warningWithoutStack$1(\n          false,\n          \"getDefaultProps was defined on %s, a plain JavaScript class. \" +\n            \"This is only supported for classes created using React.createClass. \" +\n            \"Use a static property to define defaultProps instead.\",\n          name\n        )\n      : void 0;\n    var noInstancePropTypes = !instance.propTypes;\n    !noInstancePropTypes\n      ? warningWithoutStack$1(\n          false,\n          \"propTypes was defined as an instance property on %s. Use a static \" +\n            \"property to define propTypes instead.\",\n          name\n        )\n      : void 0;\n    var noInstanceContextTypes = !instance.contextTypes;\n    !noInstanceContextTypes\n      ? warningWithoutStack$1(\n          false,\n          \"contextTypes was defined as an instance property on %s. Use a static \" +\n            \"property to define contextTypes instead.\",\n          name\n        )\n      : void 0;\n    var noComponentShouldUpdate =\n      typeof instance.componentShouldUpdate !== \"function\";\n    !noComponentShouldUpdate\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" +\n            \"The name is phrased as a question because the function is \" +\n            \"expected to return a value.\",\n          name\n        )\n      : void 0;\n    if (\n      ctor.prototype &&\n      ctor.prototype.isPureReactComponent &&\n      typeof instance.shouldComponentUpdate !== \"undefined\"\n    ) {\n      warningWithoutStack$1(\n        false,\n        \"%s has a method called shouldComponentUpdate(). \" +\n          \"shouldComponentUpdate should not be used when extending React.PureComponent. \" +\n          \"Please extend React.Component if shouldComponentUpdate is used.\",\n        getComponentName(ctor) || \"A pure component\"\n      );\n    }\n    var noComponentDidUnmount =\n      typeof instance.componentDidUnmount !== \"function\";\n    !noComponentDidUnmount\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"componentDidUnmount(). But there is no such lifecycle method. \" +\n            \"Did you mean componentWillUnmount()?\",\n          name\n        )\n      : void 0;\n    var noComponentDidReceiveProps =\n      typeof instance.componentDidReceiveProps !== \"function\";\n    !noComponentDidReceiveProps\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"componentDidReceiveProps(). But there is no such lifecycle method. \" +\n            \"If you meant to update the state in response to changing props, \" +\n            \"use componentWillReceiveProps(). If you meant to fetch data or \" +\n            \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n          name\n        )\n      : void 0;\n    var noComponentWillRecieveProps =\n      typeof instance.componentWillRecieveProps !== \"function\";\n    !noComponentWillRecieveProps\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n          name\n        )\n      : void 0;\n    var noUnsafeComponentWillRecieveProps =\n      typeof instance.UNSAFE_componentWillRecieveProps !== \"function\";\n    !noUnsafeComponentWillRecieveProps\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n          name\n        )\n      : void 0;\n    var hasMutatedProps = instance.props !== newProps;\n    !(instance.props === undefined || !hasMutatedProps)\n      ? warningWithoutStack$1(\n          false,\n          \"%s(...): When calling super() in `%s`, make sure to pass \" +\n            \"up the same props that your component's constructor was passed.\",\n          name,\n          name\n        )\n      : void 0;\n    var noInstanceDefaultProps = !instance.defaultProps;\n    !noInstanceDefaultProps\n      ? warningWithoutStack$1(\n          false,\n          \"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" +\n            \" Instead, define defaultProps as a static property on %s.\",\n          name,\n          name\n        )\n      : void 0;\n\n    if (\n      typeof instance.getSnapshotBeforeUpdate === \"function\" &&\n      typeof instance.componentDidUpdate !== \"function\" &&\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)\n    ) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      warningWithoutStack$1(\n        false,\n        \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" +\n          \"This component defines getSnapshotBeforeUpdate() only.\",\n        getComponentName(ctor)\n      );\n    }\n\n    var noInstanceGetDerivedStateFromProps =\n      typeof instance.getDerivedStateFromProps !== \"function\";\n    !noInstanceGetDerivedStateFromProps\n      ? warningWithoutStack$1(\n          false,\n          \"%s: getDerivedStateFromProps() is defined as an instance method \" +\n            \"and will be ignored. Instead, declare it as a static method.\",\n          name\n        )\n      : void 0;\n    var noInstanceGetDerivedStateFromCatch =\n      typeof instance.getDerivedStateFromCatch !== \"function\";\n    !noInstanceGetDerivedStateFromCatch\n      ? warningWithoutStack$1(\n          false,\n          \"%s: getDerivedStateFromCatch() is defined as an instance method \" +\n            \"and will be ignored. Instead, declare it as a static method.\",\n          name\n        )\n      : void 0;\n    var noStaticGetSnapshotBeforeUpdate =\n      typeof ctor.getSnapshotBeforeUpdate !== \"function\";\n    !noStaticGetSnapshotBeforeUpdate\n      ? warningWithoutStack$1(\n          false,\n          \"%s: getSnapshotBeforeUpdate() is defined as a static method \" +\n            \"and will be ignored. Instead, declare it as an instance method.\",\n          name\n        )\n      : void 0;\n    var _state = instance.state;\n    if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n      warningWithoutStack$1(\n        false,\n        \"%s.state: must be set to an object or null\",\n        name\n      );\n    }\n    if (typeof instance.getChildContext === \"function\") {\n      !(typeof ctor.childContextTypes === \"object\")\n        ? warningWithoutStack$1(\n            false,\n            \"%s.getChildContext(): childContextTypes must be defined in order to \" +\n              \"use getChildContext().\",\n            name\n          )\n        : void 0;\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  set(instance, workInProgress);\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(\n  workInProgress,\n  ctor,\n  props,\n  renderExpirationTime\n) {\n  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n  var contextTypes = ctor.contextTypes;\n  var isContextConsumer = contextTypes !== null && contextTypes !== undefined;\n  var context = isContextConsumer\n    ? getMaskedContext(workInProgress, unmaskedContext)\n    : emptyContextObject;\n\n  // Instantiate twice to help detect side-effects.\n  {\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  var instance = new ctor(props, context);\n  var state = (workInProgress.memoizedState =\n    instance.state !== null && instance.state !== undefined\n      ? instance.state\n      : null);\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n      var componentName = getComponentName(ctor) || \"Component\";\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warningWithoutStack$1(\n          false,\n          \"`%s` uses `getDerivedStateFromProps` but its initial state is \" +\n            \"%s. This is not recommended. Instead, define the initial state by \" +\n            \"assigning an object to `this.state` in the constructor of `%s`. \" +\n            \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n          componentName,\n          instance.state === null ? \"null\" : \"undefined\",\n          componentName\n        );\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (\n      typeof ctor.getDerivedStateFromProps === \"function\" ||\n      typeof instance.getSnapshotBeforeUpdate === \"function\"\n    ) {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n      if (\n        typeof instance.componentWillMount === \"function\" &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        foundWillMountName = \"componentWillMount\";\n      } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n        foundWillMountName = \"UNSAFE_componentWillMount\";\n      }\n      if (\n        typeof instance.componentWillReceiveProps === \"function\" &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n      ) {\n        foundWillReceivePropsName = \"componentWillReceiveProps\";\n      } else if (\n        typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n      ) {\n        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n      }\n      if (\n        typeof instance.componentWillUpdate === \"function\" &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\n      ) {\n        foundWillUpdateName = \"componentWillUpdate\";\n      } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n      }\n      if (\n        foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null\n      ) {\n        var _componentName = getComponentName(ctor) || \"Component\";\n        var newApiName =\n          typeof ctor.getDerivedStateFromProps === \"function\"\n            ? \"getDerivedStateFromProps()\"\n            : \"getSnapshotBeforeUpdate()\";\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n          warningWithoutStack$1(\n            false,\n            \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" +\n              \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" +\n              \"The above lifecycles should be removed. Learn more about this warning here:\\n\" +\n              \"https://fb.me/react-async-component-lifecycle-hooks\",\n            _componentName,\n            newApiName,\n            foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\",\n            foundWillReceivePropsName !== null\n              ? \"\\n  \" + foundWillReceivePropsName\n              : \"\",\n            foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\"\n          );\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (isContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, \"componentWillMount\");\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === \"function\") {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    {\n      warningWithoutStack$1(\n        false,\n        \"%s.componentWillMount(): Assigning directly to this.state is \" +\n          \"deprecated (except inside a component's \" +\n          \"constructor). Use setState instead.\",\n        getComponentName(workInProgress.type) || \"Component\"\n      );\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextLegacyContext\n) {\n  var oldState = instance.state;\n  startPhaseTimer(workInProgress, \"componentWillReceiveProps\");\n  if (typeof instance.componentWillReceiveProps === \"function\") {\n    instance.componentWillReceiveProps(newProps, nextLegacyContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextLegacyContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentName(workInProgress.type) || \"Component\";\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warningWithoutStack$1(\n          false,\n          \"%s.componentWillReceiveProps(): Assigning directly to \" +\n            \"this.state is deprecated (except inside a component's \" +\n            \"constructor). Use setState instead.\",\n          componentName\n        );\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(\n  workInProgress,\n  ctor,\n  newProps,\n  renderExpirationTime\n) {\n  {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  var instance = workInProgress.stateNode;\n  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n  {\n    if (instance.state === newProps) {\n      var componentName = getComponentName(ctor) || \"Component\";\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        warningWithoutStack$1(\n          false,\n          \"%s: It is not recommended to assign props directly to state \" +\n            \"because updates to props won't be reflected in state. \" +\n            \"In most cases, it is better to use props directly.\",\n          componentName\n        );\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n        workInProgress,\n        instance\n      );\n\n      ReactStrictModeWarnings.recordLegacyContextWarning(\n        workInProgress,\n        instance\n      );\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordDeprecationWarnings(\n        workInProgress,\n        instance\n      );\n    }\n  }\n\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    typeof ctor.getDerivedStateFromProps !== \"function\" &&\n    typeof instance.getSnapshotBeforeUpdate !== \"function\" &&\n    (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n      typeof instance.componentWillMount === \"function\")\n  ) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      processUpdateQueue(\n        workInProgress,\n        updateQueue,\n        newProps,\n        instance,\n        renderExpirationTime\n      );\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === \"function\") {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(\n  workInProgress,\n  ctor,\n  newProps,\n  renderExpirationTime\n) {\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var nextLegacyUnmaskedContext = getUnmaskedContext(\n    workInProgress,\n    ctor,\n    true\n  );\n  var nextLegacyContext = getMaskedContext(\n    workInProgress,\n    nextLegacyUnmaskedContext\n  );\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles =\n    typeof getDerivedStateFromProps === \"function\" ||\n    typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n      typeof instance.componentWillReceiveProps === \"function\")\n  ) {\n    if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextLegacyContext\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = (instance.state = oldState);\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime\n    );\n    newState = workInProgress.memoizedState;\n  }\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextLegacyContext\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n        typeof instance.componentWillMount === \"function\")\n    ) {\n      startPhaseTimer(workInProgress, \"componentWillMount\");\n      if (typeof instance.componentWillMount === \"function\") {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextLegacyContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(\n  current,\n  workInProgress,\n  ctor,\n  newProps,\n  renderExpirationTime\n) {\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var nextLegacyUnmaskedContext = getUnmaskedContext(\n    workInProgress,\n    ctor,\n    true\n  );\n  var nextLegacyContext = getMaskedContext(\n    workInProgress,\n    nextLegacyUnmaskedContext\n  );\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles =\n    typeof getDerivedStateFromProps === \"function\" ||\n    typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n      typeof instance.componentWillReceiveProps === \"function\")\n  ) {\n    if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextLegacyContext\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = (instance.state = oldState);\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextLegacyContext\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillUpdate === \"function\" ||\n        typeof instance.componentWillUpdate === \"function\")\n    ) {\n      startPhaseTimer(workInProgress, \"componentWillUpdate\");\n      if (typeof instance.componentWillUpdate === \"function\") {\n        instance.componentWillUpdate(newProps, newState, nextLegacyContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n        instance.UNSAFE_componentWillUpdate(\n          newProps,\n          newState,\n          nextLegacyContext\n        );\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextLegacyContext;\n\n  return shouldUpdate;\n}\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutGenerators = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function(child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function(child) {\n    if (child === null || typeof child !== \"object\") {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === \"object\",\n      \"React Component in warnForMissingKey should have a _store. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    child._store.validated = true;\n\n    var currentComponentErrorInfo =\n      \"Each child in an array or iterator should have a unique \" +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      \"more information.\" +\n      getCurrentFiberStackInDev();\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning$1(\n      false,\n      \"Each child in an array or iterator should have a unique \" +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        \"more information.\"\n    );\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current$$1, element) {\n  var mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== \"function\" &&\n    typeof mixedRef !== \"object\"\n  ) {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber.type) || \"Component\";\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warningWithoutStack$1(\n            false,\n            'A string ref, \"%s\", has been found within a strict mode tree. ' +\n              \"String refs are a source of potential bugs and should be avoided. \" +\n              \"We recommend using createRef() instead.\" +\n              \"\\n%s\" +\n              \"\\n\\nLearn more about using refs safely here:\" +\n              \"\\nhttps://fb.me/react-strict-mode-string-ref\",\n            mixedRef,\n            getStackByFiberInDevAndProd(returnFiber)\n          );\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        invariant(\n          ownerFiber.tag === ClassComponent ||\n            ownerFiber.tag === ClassComponentLazy,\n          \"Stateless function components cannot have refs.\"\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        \"Missing owner for string ref %s. This error is likely caused by a \" +\n          \"bug in React. Please file an issue.\",\n        mixedRef\n      );\n      var stringRef = \"\" + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current$$1 !== null &&\n        current$$1.ref !== null &&\n        typeof current$$1.ref === \"function\" &&\n        current$$1.ref._stringRef === stringRef\n      ) {\n        return current$$1.ref;\n      }\n      var ref = function(value) {\n        var refs = inst.refs;\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === \"string\",\n        \"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\"\n      );\n      invariant(\n        element._owner,\n        \"Element ref was specified as a string (%s) but no owner was set. This could happen for one of\" +\n          \" the following reasons:\\n\" +\n          \"1. You may be adding a ref to a functional component\\n\" +\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n          \"3. You have multiple copies of React loaded\\n\" +\n          \"See https://fb.me/react-refs-must-have-owner for more information.\",\n        mixedRef\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== \"textarea\") {\n    var addendum = \"\";\n    {\n      addendum =\n        \" If you meant to render a collection of children, use an array \" +\n        \"instead.\" +\n        getCurrentFiberStackInDev();\n    }\n    invariant(\n      false,\n      \"Objects are not valid as a React child (found: %s).%s\",\n      Object.prototype.toString.call(newChild) === \"[object Object]\"\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\n        : newChild,\n      addendum\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo =\n    \"Functions are not valid as a React child. This may happen if \" +\n    \"you return a Component instead of <Component /> from render. \" +\n    \"Or maybe you meant to call this function rather than return it.\" +\n    getCurrentFiberStackInDev();\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning$1(\n    false,\n    \"Functions are not valid as a React child. This may happen if \" +\n      \"you return a Component instead of <Component /> from render. \" +\n      \"Or maybe you meant to call this function rather than return it.\"\n  );\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current$$1 = newFiber.alternate;\n    if (current$$1 !== null) {\n      var oldIndex = current$$1.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(\n    returnFiber,\n    current$$1,\n    textContent,\n    expirationTime\n  ) {\n    if (current$$1 === null || current$$1.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(\n        textContent,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current$$1, element, expirationTime) {\n    if (current$$1 !== null && current$$1.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current$$1, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current$$1, element);\n      existing.return = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.ref = coerceRef(returnFiber, current$$1, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current$$1, portal, expirationTime) {\n    if (\n      current$$1 === null ||\n      current$$1.tag !== HostPortal ||\n      current$$1.stateNode.containerInfo !== portal.containerInfo ||\n      current$$1.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      var created = createFiberFromPortal(\n        portal,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(\n        current$$1,\n        portal.children || [],\n        expirationTime\n      );\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(\n    returnFiber,\n    current$$1,\n    fragment,\n    expirationTime,\n    key\n  ) {\n    if (current$$1 === null || current$$1.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        expirationTime,\n        key\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText(\n        \"\" + newChild,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created.ref = coerceRef(returnFiber, null, newChild);\n          _created.return = returnFiber;\n          return _created;\n        }\n        case REACT_PORTAL_TYPE: {\n          var _created2 = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created2.return = returnFiber;\n          return _created2;\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          expirationTime,\n          null\n        );\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    expirationTime\n  ) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              _matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key\n            );\n          }\n          return updateElement(\n            returnFiber,\n            _matchedFiber,\n            newChild,\n            expirationTime\n          );\n        }\n        case REACT_PORTAL_TYPE: {\n          var _matchedFiber2 =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            _matchedFiber2,\n            newChild,\n            expirationTime\n          );\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          _matchedFiber3,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== \"object\" || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== \"string\") {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning$1(\n            false,\n            \"Encountered two children with the same key, `%s`. \" +\n              \"Keys should be unique so that components maintain their identity \" +\n              \"across updates. Non-unique keys may cause children to be \" +\n              \"duplicated and/or omitted  the behavior is unsupported and \" +\n              \"could change in a future version.\",\n            key\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    expirationTime\n  ) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime\n        );\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              _newFiber2.key === null ? newIdx : _newFiber2.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildrenIterable,\n    expirationTime\n  ) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === \"function\",\n      \"An object is not an iterable. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (\n        typeof Symbol === \"function\" &&\n        // $FlowFixMe Flow doesn't know about toStringTag\n        newChildrenIterable[Symbol.toStringTag] === \"Generator\"\n      ) {\n        !didWarnAboutGenerators\n          ? warning$1(\n              false,\n              \"Using Generators as children is unsupported and will likely yield \" +\n                \"unexpected results because enumerating a generator mutates it. \" +\n                \"You may convert it to an array with `Array.from()` or the \" +\n                \"`[...spread]` operator before rendering. Keep in mind \" +\n                \"you might need to polyfill these features for older browsers.\"\n            )\n          : void 0;\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if (newChildrenIterable.entries === iteratorFn) {\n        !didWarnAboutMaps\n          ? warning$1(\n              false,\n              \"Using Maps as children is unsupported and will likely yield \" +\n                \"unexpected results. Convert it to a sequence/iterable of keyed \" +\n                \"ReactElements instead.\"\n            )\n          : void 0;\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, \"An iterable object provided no iterator.\");\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime\n      );\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              _newFiber4.key === null ? newIdx : _newFiber4.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber,\n    currentFirstChild,\n    textContent,\n    expirationTime\n  ) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(\n      textContent,\n      returnFiber.mode,\n      expirationTime\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber,\n    currentFirstChild,\n    element,\n    expirationTime\n  ) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === Fragment\n            ? element.type === REACT_FRAGMENT_TYPE\n            : child.type === element.type\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(\n            child,\n            element.type === REACT_FRAGMENT_TYPE\n              ? element.props.children\n              : element.props,\n            expirationTime\n          );\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        expirationTime,\n        element.key\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber,\n    currentFirstChild,\n    portal,\n    expirationTime\n  ) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(\n      portal,\n      returnFiber.mode,\n      expirationTime\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    expirationTime\n  ) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment =\n      typeof newChild === \"object\" &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === \"object\" && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n      }\n    }\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          \"\" + newChild,\n          expirationTime\n        )\n      );\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === \"undefined\" && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n        case ClassComponentLazy: {\n          {\n            var instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent: {\n          var Component = returnFiber.type;\n          invariant(\n            false,\n            \"%s(...): Nothing was returned from render. This usually means a \" +\n              \"return statement is missing. Or, to render nothing, \" +\n              \"return null.\",\n            Component.displayName || Component.name || \"Component\"\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current$$1, workInProgress) {\n  invariant(\n    current$$1 === null || workInProgress.child === current$$1.child,\n    \"Resuming work not yet implemented.\"\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(\n    currentChild,\n    currentChild.pendingProps,\n    currentChild.expirationTime\n  );\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n      currentChild.expirationTime\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false;\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(\n          returnFiber.stateNode.containerInfo,\n          instance\n        );\n        break;\n      case HostComponent:\n        didNotHydrateInstance(\n          returnFiber.type,\n          returnFiber.memoizedProps,\n          returnFiber.stateNode,\n          instance\n        );\n        break;\n    }\n  }\n\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion;\n\n  // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.effectTag |= Placement;\n  {\n    switch (returnFiber.tag) {\n      case HostRoot: {\n        var parentContainer = returnFiber.stateNode.containerInfo;\n        switch (fiber.tag) {\n          case HostComponent:\n            var type = fiber.type;\n            var props = fiber.pendingProps;\n            didNotFindHydratableContainerInstance(parentContainer, type, props);\n            break;\n          case HostText:\n            var text = fiber.pendingProps;\n            didNotFindHydratableContainerTextInstance(parentContainer, text);\n            break;\n        }\n        break;\n      }\n      case HostComponent: {\n        var parentType = returnFiber.type;\n        var parentProps = returnFiber.memoizedProps;\n        var parentInstance = returnFiber.stateNode;\n        switch (fiber.tag) {\n          case HostComponent:\n            var _type = fiber.type;\n            var _props = fiber.pendingProps;\n            didNotFindHydratableInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              _type,\n              _props\n            );\n            break;\n          case HostText:\n            var _text = fiber.pendingProps;\n            didNotFindHydratableTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              _text\n            );\n            break;\n        }\n        break;\n      }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent: {\n      var type = fiber.type;\n      var props = fiber.pendingProps;\n      var instance = canHydrateInstance(nextInstance, type, props);\n      if (instance !== null) {\n        fiber.stateNode = instance;\n        return true;\n      }\n      return false;\n    }\n    case HostText: {\n      var text = fiber.pendingProps;\n      var textInstance = canHydrateTextInstance(nextInstance, text);\n      if (textInstance !== null) {\n        fiber.stateNode = textInstance;\n        return true;\n      }\n      return false;\n    }\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n  var nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  var firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\n  }\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild(nextInstance);\n}\n\nfunction prepareToHydrateHostInstance(\n  fiber,\n  rootContainerInstance,\n  hostContext\n) {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      \"Expected prepareToHydrateHostInstance() to never be called. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n\n  var instance = fiber.stateNode;\n  var updatePayload = hydrateInstance(\n    instance,\n    fiber.type,\n    fiber.memoizedProps,\n    rootContainerInstance,\n    hostContext,\n    fiber\n  );\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = updatePayload;\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      \"Expected prepareToHydrateHostTextInstance() to never be called. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      var returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot: {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            didNotMatchHydratedContainerTextInstance(\n              parentContainer,\n              textInstance,\n              textContent\n            );\n            break;\n          }\n          case HostComponent: {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            didNotMatchHydratedTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              textInstance,\n              textContent\n            );\n            break;\n          }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n  while (\n    parent !== null &&\n    parent.tag !== HostComponent &&\n    parent.tag !== HostRoot\n  ) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  var type = fiber.type;\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n  if (\n    fiber.tag !== HostComponent ||\n    (type !== \"head\" &&\n      type !== \"body\" &&\n      !shouldSetTextContent(type, fiber.memoizedProps))\n  ) {\n    var nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  nextHydratableInstance = hydrationParentFiber\n    ? getNextHydratableSibling(fiber.stateNode)\n    : null;\n  return true;\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nfunction readLazyComponentType(thenable) {\n  var status = thenable._reactStatus;\n  switch (status) {\n    case Resolved:\n      var Component = thenable._reactResult;\n      return Component;\n    case Rejected:\n      throw thenable._reactResult;\n    case Pending:\n      throw thenable;\n    default: {\n      thenable._reactStatus = Pending;\n      thenable.then(\n        function(resolvedValue) {\n          if (thenable._reactStatus === Pending) {\n            thenable._reactStatus = Resolved;\n            if (typeof resolvedValue === \"object\" && resolvedValue !== null) {\n              // If the `default` property is not empty, assume it's the result\n              // of an async import() and use that. Otherwise, use the\n              // resolved value itself.\n              var defaultExport = resolvedValue.default;\n              resolvedValue =\n                defaultExport !== undefined && defaultExport !== null\n                  ? defaultExport\n                  : resolvedValue;\n            } else {\n              resolvedValue = resolvedValue;\n            }\n            thenable._reactResult = resolvedValue;\n          }\n        },\n        function(error) {\n          if (thenable._reactStatus === Pending) {\n            thenable._reactStatus = Rejected;\n            thenable._reactResult = error;\n          }\n        }\n      );\n      throw thenable;\n    }\n  }\n}\n\nvar ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\nfunction reconcileChildren(\n  current$$1,\n  workInProgress,\n  nextChildren,\n  renderExpirationTime\n) {\n  if (current$$1 === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime\n    );\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current$$1.child,\n      nextChildren,\n      renderExpirationTime\n    );\n  }\n}\n\nfunction updateForwardRef(\n  current$$1,\n  workInProgress,\n  type,\n  nextProps,\n  renderExpirationTime\n) {\n  var render = type.render;\n  var ref = workInProgress.ref;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextProps) {\n    var currentRef = current$$1 !== null ? current$$1.ref : null;\n    if (ref === currentRef) {\n      return bailoutOnAlreadyFinishedWork(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    }\n  }\n\n  var nextChildren = void 0;\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase(\"render\");\n    nextChildren = render(nextProps, ref);\n    setCurrentPhase(null);\n  }\n\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current$$1, workInProgress, renderExpirationTime) {\n  var nextChildren = workInProgress.pendingProps;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateMode(current$$1, workInProgress, renderExpirationTime) {\n  var nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current$$1, workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction markRef(current$$1, workInProgress) {\n  var ref = workInProgress.ref;\n  if (\n    (current$$1 === null && ref !== null) ||\n    (current$$1 !== null && current$$1.ref !== ref)\n  ) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionalComponent(\n  current$$1,\n  workInProgress,\n  Component,\n  nextProps,\n  renderExpirationTime\n) {\n  var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  var nextChildren = void 0;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase(\"render\");\n    nextChildren = Component(nextProps, context);\n    setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(\n  current$$1,\n  workInProgress,\n  Component,\n  nextProps,\n  renderExpirationTime\n) {\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  var hasContext = void 0;\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  var shouldUpdate = void 0;\n  if (current$$1 === null) {\n    if (workInProgress.stateNode === null) {\n      // In the initial pass we might need to construct the instance.\n      constructClassInstance(\n        workInProgress,\n        Component,\n        nextProps,\n        renderExpirationTime\n      );\n      mountClassInstance(\n        workInProgress,\n        Component,\n        nextProps,\n        renderExpirationTime\n      );\n      shouldUpdate = true;\n    } else {\n      // In a resume, we'll already have an instance we can reuse.\n      shouldUpdate = resumeMountClassInstance(\n        workInProgress,\n        Component,\n        nextProps,\n        renderExpirationTime\n      );\n    }\n  } else {\n    shouldUpdate = updateClassInstance(\n      current$$1,\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime\n    );\n  }\n  return finishClassComponent(\n    current$$1,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime\n  );\n}\n\nfunction finishClassComponent(\n  current$$1,\n  workInProgress,\n  Component,\n  shouldUpdate,\n  hasContext,\n  renderExpirationTime\n) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current$$1, workInProgress);\n\n  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(\n      current$$1,\n      workInProgress,\n      renderExpirationTime\n    );\n  }\n\n  var instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner$3.current = workInProgress;\n  var nextChildren = void 0;\n  if (\n    didCaptureError &&\n    (!enableGetDerivedStateFromCatch ||\n      typeof Component.getDerivedStateFromCatch !== \"function\")\n  ) {\n    // If we captured an error, but getDerivedStateFrom catch is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    {\n      setCurrentPhase(\"render\");\n      nextChildren = instance.render();\n      if (\n        debugRenderPhaseSideEffects ||\n        (debugRenderPhaseSideEffectsForStrictMode &&\n          workInProgress.mode & StrictMode)\n      ) {\n        instance.render();\n      }\n      setCurrentPhase(null);\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  if (current$$1 !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile twice: first to delete\n    // all the existing children.\n    reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n    workInProgress.child = null;\n    // Now we can continue reconciling like normal. This has the effect of\n    // remounting all children regardless of whether their their\n    // identity matches.\n  }\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  // Memoize props and state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  memoizeState(workInProgress, instance.state);\n  memoizeProps(workInProgress, instance.props);\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n  if (root.pendingContext) {\n    pushTopLevelContextObject(\n      workInProgress,\n      root.pendingContext,\n      root.pendingContext !== root.context\n    );\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current$$1, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  var updateQueue = workInProgress.updateQueue;\n  invariant(\n    updateQueue !== null,\n    \"If the root does not have an updateQueue, we should have already \" +\n      \"bailed out. This error is likely caused by a bug in React. Please \" +\n      \"file an issue.\"\n  );\n  var nextProps = workInProgress.pendingProps;\n  var prevState = workInProgress.memoizedState;\n  var prevChildren = prevState !== null ? prevState.element : null;\n  processUpdateQueue(\n    workInProgress,\n    updateQueue,\n    nextProps,\n    null,\n    renderExpirationTime\n  );\n  var nextState = workInProgress.memoizedState;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  var nextChildren = nextState.element;\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(\n      current$$1,\n      workInProgress,\n      renderExpirationTime\n    );\n  }\n  var root = workInProgress.stateNode;\n  if (\n    (current$$1 === null || current$$1.child === null) &&\n    root.hydrate &&\n    enterHydrationState(workInProgress)\n  ) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n\n    // This is a bit of a hack. We track the host root as a placement to\n    // know that we're currently in a mounting state. That way isMounted\n    // works as expected. We must reset this before committing.\n    // TODO: Delete this when we delete isMounted and findDOMNode.\n    workInProgress.effectTag |= Placement;\n\n    // Ensure that children mount into this root without tracking\n    // side-effects. This ensures that we don't store Placement effects on\n    // nodes that will be hydrated.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime\n    );\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    reconcileChildren(\n      current$$1,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n    resetHydrationState();\n  }\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current$$1, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current$$1 === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;\n\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also have access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current$$1, workInProgress);\n\n  // Check the host config to see if the children are offscreen/hidden.\n  if (\n    renderExpirationTime !== Never &&\n    workInProgress.mode & AsyncMode &&\n    shouldDeprioritizeSubtree(type, nextProps)\n  ) {\n    // Schedule this fiber to re-render at offscreen priority. Then bailout.\n    workInProgress.expirationTime = Never;\n    workInProgress.memoizedProps = nextProps;\n    return null;\n  }\n\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current$$1, workInProgress) {\n  if (current$$1 === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  var nextProps = workInProgress.pendingProps;\n  memoizeProps(workInProgress, nextProps);\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction resolveDefaultProps(Component, baseProps) {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    var props = Object.assign({}, baseProps);\n    var defaultProps = Component.defaultProps;\n    for (var propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n    return props;\n  }\n  return baseProps;\n}\n\nfunction mountIndeterminateComponent(\n  current$$1,\n  workInProgress,\n  Component,\n  renderExpirationTime\n) {\n  invariant(\n    current$$1 === null,\n    \"An indeterminate component should never have mounted. This error is \" +\n      \"likely caused by a bug in React. Please file an issue.\"\n  );\n\n  var props = workInProgress.pendingProps;\n  if (\n    typeof Component === \"object\" &&\n    Component !== null &&\n    typeof Component.then === \"function\"\n  ) {\n    Component = readLazyComponentType(Component);\n    var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(\n      workInProgress,\n      Component\n    ));\n    var resolvedProps = resolveDefaultProps(Component, props);\n    switch (resolvedTag) {\n      case FunctionalComponentLazy: {\n        return updateFunctionalComponent(\n          current$$1,\n          workInProgress,\n          Component,\n          resolvedProps,\n          renderExpirationTime\n        );\n      }\n      case ClassComponentLazy: {\n        return updateClassComponent(\n          current$$1,\n          workInProgress,\n          Component,\n          resolvedProps,\n          renderExpirationTime\n        );\n      }\n      case ForwardRefLazy: {\n        return updateForwardRef(\n          current$$1,\n          workInProgress,\n          Component,\n          resolvedProps,\n          renderExpirationTime\n        );\n      }\n      default: {\n        // This message intentionally doesn't metion ForwardRef because the\n        // fact that it's a separate type of work is an implementation detail.\n        invariant(\n          false,\n          \"Element type is invalid. Received a promise that resolves to: %s. \" +\n            \"Promise elements must resolve to a class or function.\",\n          Component\n        );\n      }\n    }\n  }\n\n  var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  var value = void 0;\n\n  {\n    if (\n      Component.prototype &&\n      typeof Component.prototype.render === \"function\"\n    ) {\n      var componentName = getComponentName(Component) || \"Unknown\";\n\n      if (!didWarnAboutBadClass[componentName]) {\n        warningWithoutStack$1(\n          false,\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            \"This is likely to cause errors. Change %s to extend React.Component instead.\",\n          componentName,\n          componentName\n        );\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    ReactCurrentOwner$3.current = workInProgress;\n    value = Component(props, context);\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    typeof value.render === \"function\" &&\n    value.$$typeof === undefined\n  ) {\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = false;\n    if (isContextProvider(Component)) {\n      hasContext = true;\n      pushContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    if (typeof getDerivedStateFromProps === \"function\") {\n      applyDerivedStateFromProps(\n        workInProgress,\n        Component,\n        getDerivedStateFromProps,\n        props\n      );\n    }\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n    return finishClassComponent(\n      current$$1,\n      workInProgress,\n      Component,\n      true,\n      hasContext,\n      renderExpirationTime\n    );\n  } else {\n    // Proceed under the assumption that this is a functional component\n    workInProgress.tag = FunctionalComponent;\n    {\n      if (Component) {\n        !!Component.childContextTypes\n          ? warningWithoutStack$1(\n              false,\n              \"%s(...): childContextTypes cannot be defined on a functional component.\",\n              Component.displayName || Component.name || \"Component\"\n            )\n          : void 0;\n      }\n      if (workInProgress.ref !== null) {\n        var info = \"\";\n        var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n        if (ownerName) {\n          info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n        }\n\n        var warningKey = ownerName || workInProgress._debugID || \"\";\n        var debugSource = workInProgress._debugSource;\n        if (debugSource) {\n          warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n        }\n        if (!didWarnAboutStatelessRefs[warningKey]) {\n          didWarnAboutStatelessRefs[warningKey] = true;\n          warning$1(\n            false,\n            \"Stateless function components cannot be given refs. \" +\n              \"Attempts to access this ref will fail.%s\",\n            info\n          );\n        }\n      }\n\n      if (typeof Component.getDerivedStateFromProps === \"function\") {\n        var _componentName = getComponentName(Component) || \"Unknown\";\n\n        if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n          warningWithoutStack$1(\n            false,\n            \"%s: Stateless functional components do not support getDerivedStateFromProps.\",\n            _componentName\n          );\n          didWarnAboutGetDerivedStateOnFunctionalComponent[\n            _componentName\n          ] = true;\n        }\n      }\n    }\n    reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);\n    memoizeProps(workInProgress, props);\n    return workInProgress.child;\n  }\n}\n\nfunction updatePlaceholderComponent(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  if (enableSuspense) {\n    var nextProps = workInProgress.pendingProps;\n\n    // Check if we already attempted to render the normal state. If we did,\n    // and we timed out, render the placeholder state.\n    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;\n\n    var nextDidTimeout = void 0;\n    if (current$$1 !== null && workInProgress.updateQueue !== null) {\n      // We're outside strict mode. Something inside this Placeholder boundary\n      // suspended during the last commit. Switch to the placholder.\n      workInProgress.updateQueue = null;\n      nextDidTimeout = true;\n      // If we're recovering from an error, reconcile twice: first to delete\n      // all the existing children.\n      reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n      current$$1.child = null;\n      // Now we can continue reconciling like normal. This has the effect of\n      // remounting all children regardless of whether their their\n      // identity matches.\n    } else {\n      nextDidTimeout = !alreadyCaptured;\n    }\n\n    if ((workInProgress.mode & StrictMode) !== NoEffect) {\n      if (nextDidTimeout) {\n        // If the timed-out view commits, schedule an update effect to record\n        // the committed time.\n        workInProgress.effectTag |= Update;\n      } else {\n        // The state node points to the time at which placeholder timed out.\n        // We can clear it once we switch back to the normal children.\n        workInProgress.stateNode = null;\n      }\n    }\n\n    // If the `children` prop is a function, treat it like a render prop.\n    // TODO: This is temporary until we finalize a lower level API.\n    var children = nextProps.children;\n    var nextChildren = void 0;\n    if (typeof children === \"function\") {\n      nextChildren = children(nextDidTimeout);\n    } else {\n      nextChildren = nextDidTimeout ? nextProps.fallback : children;\n    }\n\n    workInProgress.memoizedProps = nextProps;\n    workInProgress.memoizedState = nextDidTimeout;\n    reconcileChildren(\n      current$$1,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n    return workInProgress.child;\n  } else {\n    return null;\n  }\n}\n\nfunction updatePortalComponent(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n  if (current$$1 === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime\n    );\n    memoizeProps(workInProgress, nextChildren);\n  } else {\n    reconcileChildren(\n      current$$1,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n    memoizeProps(workInProgress, nextChildren);\n  }\n  return workInProgress.child;\n}\n\nfunction updateContextProvider(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n\n  var newValue = newProps.value;\n  workInProgress.memoizedProps = newProps;\n\n  {\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(\n        providerPropTypes,\n        newProps,\n        \"prop\",\n        \"Context.Provider\",\n        getCurrentFiberStackInDev\n      );\n    }\n  }\n\n  pushProvider(workInProgress, newValue);\n\n  if (oldProps !== null) {\n    var oldValue = oldProps.value;\n    var changedBits = calculateChangedBits(context, newValue, oldValue);\n    if (changedBits === 0) {\n      // No change. Bailout early if children are the same.\n      if (oldProps.children === newProps.children && !hasContextChanged()) {\n        return bailoutOnAlreadyFinishedWork(\n          current$$1,\n          workInProgress,\n          renderExpirationTime\n        );\n      }\n    } else {\n      // The context value changed. Search for matching consumers and schedule\n      // them to update.\n      propagateContextChange(\n        workInProgress,\n        context,\n        changedBits,\n        renderExpirationTime\n      );\n    }\n  }\n\n  var newChildren = newProps.children;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    newChildren,\n    renderExpirationTime\n  );\n  return workInProgress.child;\n}\n\nfunction updateContextConsumer(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  var context = workInProgress.type;\n  var newProps = workInProgress.pendingProps;\n  var render = newProps.children;\n\n  {\n    !(typeof render === \"function\")\n      ? warningWithoutStack$1(\n          false,\n          \"A context consumer was rendered with multiple children, or a child \" +\n            \"that isn't a function. A context consumer expects a single child \" +\n            \"that is a function. If you did pass a function, make sure there \" +\n            \"is no trailing or leading whitespace around it.\"\n        )\n      : void 0;\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  var newValue = readContext(context, newProps.unstable_observedBits);\n  var newChildren = void 0;\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase(\"render\");\n    newChildren = render(newValue);\n    setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    newChildren,\n    renderExpirationTime\n  );\n  workInProgress.memoizedProps = newProps;\n  return workInProgress.child;\n}\n\n/*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\nfunction bailoutOnAlreadyFinishedWork(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  cancelWorkTimer(workInProgress);\n\n  if (current$$1 !== null) {\n    // Reuse previous context list\n    workInProgress.firstContextDependency = current$$1.firstContextDependency;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  // Check if the children have any pending work.\n  var childExpirationTime = workInProgress.childExpirationTime;\n  if (\n    childExpirationTime === NoWork ||\n    childExpirationTime > renderExpirationTime\n  ) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    return null;\n  } else {\n    // This fiber doesn't have work, but its subtree does. Clone the child\n    // fibers and continue.\n    cloneChildFibers(current$$1, workInProgress);\n    return workInProgress.child;\n  }\n}\n\n// TODO: Delete memoizeProps/State and move to reconcile/bailout instead\nfunction memoizeProps(workInProgress, nextProps) {\n  workInProgress.memoizedProps = nextProps;\n}\n\nfunction memoizeState(workInProgress, nextState) {\n  workInProgress.memoizedState = nextState;\n  // Don't reset the updateQueue, in case there are pending updates. Resetting\n  // is handled by processUpdateQueue.\n}\n\nfunction beginWork(current$$1, workInProgress, renderExpirationTime) {\n  var updateExpirationTime = workInProgress.expirationTime;\n  if (\n    !hasContextChanged() &&\n    (updateExpirationTime === NoWork ||\n      updateExpirationTime > renderExpirationTime)\n  ) {\n    // This fiber does not have any pending work. Bailout without entering\n    // the begin phase. There's still some bookkeeping we that needs to be done\n    // in this optimized path, mostly pushing stuff onto the stack.\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        resetHydrationState();\n        break;\n      case HostComponent:\n        pushHostContext(workInProgress);\n        break;\n      case ClassComponent: {\n        var Component = workInProgress.type;\n        if (isContextProvider(Component)) {\n          pushContextProvider(workInProgress);\n        }\n        break;\n      }\n      case ClassComponentLazy: {\n        var thenable = workInProgress.type;\n        var _Component = getResultFromResolvedThenable(thenable);\n        if (isContextProvider(_Component)) {\n          pushContextProvider(workInProgress);\n        }\n        break;\n      }\n      case HostPortal:\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        break;\n      case ContextProvider: {\n        var newValue = workInProgress.memoizedProps.value;\n        pushProvider(workInProgress, newValue);\n        break;\n      }\n      case Profiler:\n        if (enableProfilerTimer) {\n          workInProgress.effectTag |= Update;\n        }\n        break;\n    }\n    return bailoutOnAlreadyFinishedWork(\n      current$$1,\n      workInProgress,\n      renderExpirationTime\n    );\n  }\n\n  // Before entering the begin phase, clear the expiration time.\n  workInProgress.expirationTime = NoWork;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      var _Component3 = workInProgress.type;\n      return mountIndeterminateComponent(\n        current$$1,\n        workInProgress,\n        _Component3,\n        renderExpirationTime\n      );\n    }\n    case FunctionalComponent: {\n      var _Component4 = workInProgress.type;\n      var _unresolvedProps = workInProgress.pendingProps;\n      return updateFunctionalComponent(\n        current$$1,\n        workInProgress,\n        _Component4,\n        _unresolvedProps,\n        renderExpirationTime\n      );\n    }\n    case FunctionalComponentLazy: {\n      var _thenable2 = workInProgress.type;\n      var _Component5 = getResultFromResolvedThenable(_thenable2);\n      var _unresolvedProps2 = workInProgress.pendingProps;\n      var _child = updateFunctionalComponent(\n        current$$1,\n        workInProgress,\n        _Component5,\n        resolveDefaultProps(_Component5, _unresolvedProps2),\n        renderExpirationTime\n      );\n      workInProgress.memoizedProps = _unresolvedProps2;\n      return _child;\n    }\n    case ClassComponent: {\n      var _Component6 = workInProgress.type;\n      var _unresolvedProps3 = workInProgress.pendingProps;\n      return updateClassComponent(\n        current$$1,\n        workInProgress,\n        _Component6,\n        _unresolvedProps3,\n        renderExpirationTime\n      );\n    }\n    case ClassComponentLazy: {\n      var _thenable3 = workInProgress.type;\n      var _Component7 = getResultFromResolvedThenable(_thenable3);\n      var _unresolvedProps4 = workInProgress.pendingProps;\n      var _child2 = updateClassComponent(\n        current$$1,\n        workInProgress,\n        _Component7,\n        resolveDefaultProps(_Component7, _unresolvedProps4),\n        renderExpirationTime\n      );\n      workInProgress.memoizedProps = _unresolvedProps4;\n      return _child2;\n    }\n    case HostRoot:\n      return updateHostRoot(current$$1, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    case HostText:\n      return updateHostText(current$$1, workInProgress);\n    case PlaceholderComponent:\n      return updatePlaceholderComponent(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    case HostPortal:\n      return updatePortalComponent(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    case ForwardRef: {\n      var type = workInProgress.type;\n      return updateForwardRef(\n        current$$1,\n        workInProgress,\n        type,\n        workInProgress.pendingProps,\n        renderExpirationTime\n      );\n    }\n    case ForwardRefLazy:\n      var _thenable = workInProgress.type;\n      var _Component2 = getResultFromResolvedThenable(_thenable);\n      var unresolvedProps = workInProgress.pendingProps;\n      var child = updateForwardRef(\n        current$$1,\n        workInProgress,\n        _Component2,\n        resolveDefaultProps(_Component2, unresolvedProps),\n        renderExpirationTime\n      );\n      workInProgress.memoizedProps = unresolvedProps;\n      return child;\n    case Fragment:\n      return updateFragment(current$$1, workInProgress, renderExpirationTime);\n    case Mode:\n      return updateMode(current$$1, workInProgress, renderExpirationTime);\n    case Profiler:\n      return updateProfiler(current$$1, workInProgress, renderExpirationTime);\n    case ContextProvider:\n      return updateContextProvider(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    case ContextConsumer:\n      return updateContextConsumer(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    default:\n      invariant(\n        false,\n        \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n          \"React. Please file an issue.\"\n      );\n  }\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef$1(workInProgress) {\n  workInProgress.effectTag |= Ref;\n}\n\nfunction appendAllChildren(parent, workInProgress) {\n  // We only have the top Fiber that was created but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = workInProgress.child;\n  while (node !== null) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      appendInitialChild(parent, node.stateNode);\n    } else if (node.tag === HostPortal) {\n      // If we have a portal child, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nvar updateHostContainer = void 0;\nvar updateHostComponent$1 = void 0;\nvar updateHostText$1 = void 0;\nif (supportsMutation) {\n  // Mutation mode\n\n  updateHostContainer = function(workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    type,\n    newProps,\n    rootContainerInstance\n  ) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    var oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    var instance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    var updatePayload = prepareUpdate(\n      instance,\n      type,\n      oldProps,\n      newProps,\n      rootContainerInstance,\n      currentHostContext\n    );\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  var appendAllChildrenToContainer = function(\n    containerChildSet,\n    workInProgress\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendChildToContainerChildSet(containerChildSet, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function(workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    type,\n    newProps,\n    rootContainerInstance\n  ) {\n    var currentInstance = current.stateNode;\n    var oldProps = current.memoizedProps;\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    var recyclableInstance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    var updatePayload = null;\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(\n        recyclableInstance,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      );\n    }\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    var newInstance = cloneInstance(\n      currentInstance,\n      updatePayload,\n      type,\n      oldProps,\n      newProps,\n      workInProgress,\n      childrenUnchanged,\n      recyclableInstance\n    );\n    if (\n      finalizeInitialChildren(\n        newInstance,\n        type,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      )\n    ) {\n      markUpdate(workInProgress);\n    }\n    workInProgress.stateNode = newInstance;\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress);\n    }\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(\n        newText,\n        rootContainerInstance,\n        currentHostContext,\n        workInProgress\n      );\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function(workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    type,\n    newProps,\n    rootContainerInstance\n  ) {\n    // Noop\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    // Noop\n  };\n}\n\nfunction completeWork(current, workInProgress, renderExpirationTime) {\n  var newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case FunctionalComponent:\n    case FunctionalComponentLazy:\n      break;\n    case ClassComponent: {\n      var Component = workInProgress.type;\n      if (isContextProvider(Component)) {\n        popContext(workInProgress);\n      }\n      break;\n    }\n    case ClassComponentLazy: {\n      var _Component = getResultFromResolvedThenable(workInProgress.type);\n      if (isContextProvider(_Component)) {\n        popContext(workInProgress);\n      }\n      break;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelContextObject(workInProgress);\n      var fiberRoot = workInProgress.stateNode;\n      if (fiberRoot.pendingContext) {\n        fiberRoot.context = fiberRoot.pendingContext;\n        fiberRoot.pendingContext = null;\n      }\n      if (current === null || current.child === null) {\n        // If we hydrated, pop so that we can delete any remaining children\n        // that weren't hydrated.\n        popHydrationState(workInProgress);\n        // This resets the hacky state to fix isMounted before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag &= ~Placement;\n      }\n      updateHostContainer(workInProgress);\n      break;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      var rootContainerInstance = getRootHostContainer();\n      var type = workInProgress.type;\n      if (current !== null && workInProgress.stateNode != null) {\n        updateHostComponent$1(\n          current,\n          workInProgress,\n          type,\n          newProps,\n          rootContainerInstance\n        );\n\n        if (current.ref !== workInProgress.ref) {\n          markRef$1(workInProgress);\n        }\n      } else {\n        if (!newProps) {\n          invariant(\n            workInProgress.stateNode !== null,\n            \"We must have new props for new mounts. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          // This can happen when we abort work.\n          break;\n        }\n\n        var currentHostContext = getHostContext();\n        // TODO: Move createInstance to beginWork and keep it on a context\n        // \"stack\" as the parent. Then append children as we go in beginWork\n        // or completeWork depending on we want to add then top->down or\n        // bottom->up. Top->down is faster in IE11.\n        var wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // TODO: Move this and createInstance step into the beginPhase\n          // to consolidate.\n          if (\n            prepareToHydrateHostInstance(\n              workInProgress,\n              rootContainerInstance,\n              currentHostContext\n            )\n          ) {\n            // If changes to the hydrated node needs to be applied at the\n            // commit-phase we mark this as such.\n            markUpdate(workInProgress);\n          }\n        } else {\n          var instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress\n          );\n\n          appendAllChildren(instance, workInProgress);\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              instance,\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = instance;\n        }\n\n        if (workInProgress.ref !== null) {\n          // If there is a ref on a host node we need to schedule a callback\n          markRef$1(workInProgress);\n        }\n      }\n      break;\n    }\n    case HostText: {\n      var newText = newProps;\n      if (current && workInProgress.stateNode != null) {\n        var oldText = current.memoizedProps;\n        // If we have an alternate, that means this is an update and we need\n        // to schedule a side-effect to do the updates.\n        updateHostText$1(current, workInProgress, oldText, newText);\n      } else {\n        if (typeof newText !== \"string\") {\n          invariant(\n            workInProgress.stateNode !== null,\n            \"We must have new props for new mounts. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          // This can happen when we abort work.\n        }\n        var _rootContainerInstance = getRootHostContainer();\n        var _currentHostContext = getHostContext();\n        var _wasHydrated = popHydrationState(workInProgress);\n        if (_wasHydrated) {\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            _rootContainerInstance,\n            _currentHostContext,\n            workInProgress\n          );\n        }\n      }\n      break;\n    }\n    case ForwardRef:\n    case ForwardRefLazy:\n      break;\n    case PlaceholderComponent:\n      break;\n    case Fragment:\n      break;\n    case Mode:\n      break;\n    case Profiler:\n      break;\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      break;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      break;\n    case ContextConsumer:\n      break;\n    // Error cases\n    case IndeterminateComponent:\n      invariant(\n        false,\n        \"An indeterminate component should have become determinate before \" +\n          \"completing. This error is likely caused by a bug in React. Please \" +\n          \"file an issue.\"\n      );\n    // eslint-disable-next-line no-fallthrough\n    default:\n      invariant(\n        false,\n        \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n          \"React. Please file an issue.\"\n      );\n  }\n\n  return null;\n}\n\n// Module provided by RN:\n/**\n * Intercept lifecycle errors and ensure they are shown with the correct stack\n * trace within the native redbox component.\n */\nfunction showErrorDialog(capturedError) {\n  var componentStack = capturedError.componentStack,\n    error = capturedError.error;\n\n  var errorToHandle = void 0;\n\n  // Typically Errors are thrown but eg strings or null can be thrown as well.\n  if (error instanceof Error) {\n    var message = error.message,\n      name = error.name;\n\n    var summary = message ? name + \": \" + message : name;\n\n    errorToHandle = error;\n\n    try {\n      errorToHandle.message =\n        summary + \"\\n\\nThis error is located at:\" + componentStack;\n    } catch (e) {}\n  } else if (typeof error === \"string\") {\n    errorToHandle = new Error(\n      error + \"\\n\\nThis error is located at:\" + componentStack\n    );\n  } else {\n    errorToHandle = new Error(\"Unspecified error at:\" + componentStack);\n  }\n\n  ExceptionsManager.handleException(errorToHandle, false);\n\n  // Return false here to prevent ReactFiberErrorLogger default behavior of\n  // logging error details to console.error. Calls to console.error are\n  // automatically routed to the native redbox controller, which we've already\n  // done above by calling ExceptionsManager.\n  return false;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  {\n    var componentName = capturedError.componentName,\n      componentStack = capturedError.componentStack,\n      errorBoundaryName = capturedError.errorBoundaryName,\n      errorBoundaryFound = capturedError.errorBoundaryFound,\n      willRetry = capturedError.willRetry;\n\n    // Browsers support silencing uncaught errors by calling\n    // `preventDefault()` in window `error` handler.\n    // We record this information as an expando on the error.\n\n    if (error != null && error._suppressLogging) {\n      if (errorBoundaryFound && willRetry) {\n        // The error is recoverable and was silenced.\n        // Ignore it and don't print the stack addendum.\n        // This is handy for testing error boundaries without noise.\n        return;\n      }\n      // The error is fatal. Since the silencing might have\n      // been accidental, we'll surface it anyway.\n      // However, the browser would have silenced the original error\n      // so we'll print it first, and then print the stack addendum.\n      console.error(error);\n      // For a more detailed description of this block, see:\n      // https://github.com/facebook/react/pull/13384\n    }\n\n    var componentNameMessage = componentName\n      ? \"The above error occurred in the <\" + componentName + \"> component:\"\n      : \"The above error occurred in one of your React components:\";\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage =\n          \"React will try to recreate this component tree from scratch \" +\n          (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      } else {\n        errorBoundaryMessage =\n          \"This error was initially handled by the error boundary \" +\n          errorBoundaryName +\n          \".\\n\" +\n          \"Recreating the tree from scratch failed so React will unmount the tree.\";\n      }\n    } else {\n      errorBoundaryMessage =\n        \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" +\n        \"Visit https://fb.me/react-error-boundaries to learn more about error boundaries.\";\n    }\n    var combinedMessage =\n      \"\" +\n      componentNameMessage +\n      componentStack +\n      \"\\n\\n\" +\n      (\"\" + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar emptyObject$1 = {};\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : \"\",\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(function() {\n      throw e;\n    });\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function(current$$1, instance) {\n  startPhaseTimer(current$$1, \"componentWillUnmount\");\n  instance.props = current$$1.memoizedProps;\n  instance.state = current$$1.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current$$1, instance) {\n  {\n    invokeGuardedCallback(\n      null,\n      callComponentWillUnmountWithTimer,\n      null,\n      current$$1,\n      instance\n    );\n    if (hasCaughtError()) {\n      var unmountError = clearCaughtError();\n      captureCommitPhaseError(current$$1, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current$$1) {\n  var ref = current$$1.ref;\n  if (ref !== null) {\n    if (typeof ref === \"function\") {\n      {\n        invokeGuardedCallback(null, ref, null, null);\n        if (hasCaughtError()) {\n          var refError = clearCaughtError();\n          captureCommitPhaseError(current$$1, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(current$$1, finishedWork) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      if (finishedWork.effectTag & Snapshot) {\n        if (current$$1 !== null) {\n          var prevProps = current$$1.memoizedProps;\n          var prevState = current$$1.memoizedState;\n          startPhaseTimer(finishedWork, \"getSnapshotBeforeUpdate\");\n          var instance = finishedWork.stateNode;\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n          {\n            var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n              didWarnSet.add(finishedWork.type);\n              warningWithoutStack$1(\n                false,\n                \"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" +\n                  \"must be returned. You have returned undefined.\",\n                getComponentName(finishedWork.type)\n              );\n            }\n          }\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          stopPhaseTimer();\n        }\n      }\n      return;\n    }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n      // Nothing to do for these component types\n      return;\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitLifeCycles(\n  finishedRoot,\n  current$$1,\n  finishedWork,\n  committedExpirationTime\n) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      var instance = finishedWork.stateNode;\n      if (finishedWork.effectTag & Update) {\n        if (current$$1 === null) {\n          startPhaseTimer(finishedWork, \"componentDidMount\");\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          instance.componentDidMount();\n          stopPhaseTimer();\n        } else {\n          var prevProps = current$$1.memoizedProps;\n          var prevState = current$$1.memoizedState;\n          startPhaseTimer(finishedWork, \"componentDidUpdate\");\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          instance.componentDidUpdate(\n            prevProps,\n            prevState,\n            instance.__reactInternalSnapshotBeforeUpdate\n          );\n          stopPhaseTimer();\n        }\n      }\n      var updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        instance.props = finishedWork.memoizedProps;\n        instance.state = finishedWork.memoizedState;\n        commitUpdateQueue(\n          finishedWork,\n          updateQueue,\n          instance,\n          committedExpirationTime\n        );\n      }\n      return;\n    }\n    case HostRoot: {\n      var _updateQueue = finishedWork.updateQueue;\n      if (_updateQueue !== null) {\n        var _instance = null;\n        if (finishedWork.child !== null) {\n          switch (finishedWork.child.tag) {\n            case HostComponent:\n              _instance = getPublicInstance(finishedWork.child.stateNode);\n              break;\n            case ClassComponent:\n            case ClassComponentLazy:\n              _instance = finishedWork.child.stateNode;\n              break;\n          }\n        }\n        commitUpdateQueue(\n          finishedWork,\n          _updateQueue,\n          _instance,\n          committedExpirationTime\n        );\n      }\n      return;\n    }\n    case HostComponent: {\n      var _instance2 = finishedWork.stateNode;\n\n      // Renderers may schedule work to be done after host components are mounted\n      // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n      // These effects should only be committed when components are first mounted,\n      // aka when there is no current/alternate.\n      if (current$$1 === null && finishedWork.effectTag & Update) {\n        var type = finishedWork.type;\n        var props = finishedWork.memoizedProps;\n      }\n\n      return;\n    }\n    case HostText: {\n      // We have no life-cycles associated with text.\n      return;\n    }\n    case HostPortal: {\n      // We have no life-cycles associated with portals.\n      return;\n    }\n    case Profiler: {\n      if (enableProfilerTimer) {\n        var onRender = finishedWork.memoizedProps.onRender;\n\n        if (enableSchedulerTracking) {\n          onRender(\n            finishedWork.memoizedProps.id,\n            current$$1 === null ? \"mount\" : \"update\",\n            finishedWork.actualDuration,\n            finishedWork.treeBaseDuration,\n            finishedWork.actualStartTime,\n            getCommitTime(),\n            finishedRoot.memoizedInteractions\n          );\n        } else {\n          onRender(\n            finishedWork.memoizedProps.id,\n            current$$1 === null ? \"mount\" : \"update\",\n            finishedWork.actualDuration,\n            finishedWork.treeBaseDuration,\n            finishedWork.actualStartTime,\n            getCommitTime()\n          );\n        }\n      }\n      return;\n    }\n    case PlaceholderComponent: {\n      if (enableSuspense) {\n        if ((finishedWork.mode & StrictMode) === NoEffect) {\n          // In loose mode, a placeholder times out by scheduling a synchronous\n          // update in the commit phase. Use `updateQueue` field to signal that\n          // the Timeout needs to switch to the placeholder. We don't need an\n          // entire queue. Any non-null value works.\n          // $FlowFixMe - Intentionally using a value other than an UpdateQueue.\n          finishedWork.updateQueue = emptyObject$1;\n          scheduleWork(finishedWork, Sync);\n        } else {\n          // In strict mode, the Update effect is used to record the time at\n          // which the placeholder timed out.\n          var currentTime = requestCurrentTime();\n          finishedWork.stateNode = { timedOutAt: currentTime };\n        }\n      }\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse = void 0;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    if (typeof ref === \"function\") {\n      ref(instanceToUse);\n    } else {\n      {\n        if (!ref.hasOwnProperty(\"current\")) {\n          warningWithoutStack$1(\n            false,\n            \"Unexpected ref object provided for %s. \" +\n              \"Use either a ref-setter function or React.createRef().%s\",\n            getComponentName(finishedWork.type),\n            getStackByFiberInDevAndProd(finishedWork)\n          );\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current$$1) {\n  var currentRef = current$$1.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === \"function\") {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(current$$1) {\n  onCommitUnmount(current$$1);\n\n  switch (current$$1.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      safelyDetachRef(current$$1);\n      var instance = current$$1.stateNode;\n      if (typeof instance.componentWillUnmount === \"function\") {\n        safelyCallComponentWillUnmount(current$$1, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      safelyDetachRef(current$$1);\n      return;\n    }\n    case HostPortal: {\n      // TODO: this is recursive.\n      // We are also not using this parent because\n      // the portal will get pushed immediately.\n      if (supportsMutation) {\n        unmountHostComponents(current$$1);\n      } else if (supportsPersistence) {\n        emptyPortalContainer(current$$1);\n      }\n      return;\n    }\n  }\n}\n\nfunction commitNestedUnmounts(root) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  var node = root;\n  while (true) {\n    commitUnmount(node);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (\n      node.child !== null &&\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      (!supportsMutation || node.tag !== HostPortal)\n    ) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current$$1) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current$$1.return = null;\n  current$$1.child = null;\n  if (current$$1.alternate) {\n    current$$1.alternate.child = null;\n    current$$1.alternate.return = null;\n  }\n}\n\nfunction emptyPortalContainer(current$$1) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current$$1.stateNode;\n  var containerInfo = portal.containerInfo;\n\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      return;\n    }\n    case HostComponent: {\n      return;\n    }\n    case HostText: {\n      return;\n    }\n    case HostRoot:\n    case HostPortal: {\n      var portalOrRoot = finishedWork.stateNode;\n      var containerInfo = portalOrRoot.containerInfo,\n        _pendingChildren = portalOrRoot.pendingChildren;\n\n      replaceContainerChildren(containerInfo, _pendingChildren);\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n  invariant(\n    false,\n    \"Expected to find a host parent. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n}\n\nfunction isHostParent(fiber) {\n  return (\n    fiber.tag === HostComponent ||\n    fiber.tag === HostRoot ||\n    fiber.tag === HostPortal\n  );\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  var node = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (node.tag !== HostComponent && node.tag !== HostText) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  var parentFiber = getHostParentFiber(finishedWork);\n\n  // Note: these two variables *must* always be updated together.\n  var parent = void 0;\n  var isContainer = void 0;\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentFiber.stateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    default:\n      invariant(\n        false,\n        \"Invalid host parent fiber. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n  }\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  var before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = finishedWork;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, node.stateNode, before);\n        } else {\n          insertBefore(parent, node.stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, node.stateNode);\n        } else {\n          appendChild(parent, node.stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {\n      // If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(current$$1) {\n  // We only have the top Fiber that was deleted but we need recurse down its\n  var node = current$$1;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  var currentParentIsValid = false;\n\n  // Note: these two variables *must* always be updated together.\n  var currentParent = void 0;\n  var currentParentIsContainer = void 0;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      var parent = node.return;\n      findParent: while (true) {\n        invariant(\n          parent !== null,\n          \"Expected to find a host parent. This error is likely caused by \" +\n            \"a bug in React. Please file an issue.\"\n        );\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parent.stateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(node);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      }\n      // Don't visit children because we already visited them.\n    } else if (node.tag === HostPortal) {\n      // When we go into a portal, it becomes the parent to remove from.\n      // We will reassign it back when we pop the portal on the way up.\n      currentParent = node.stateNode.containerInfo;\n      currentParentIsContainer = true;\n      // Visit children because portals might contain host components.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(node);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current$$1) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current$$1) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(current$$1) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current$$1);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(current$$1);\n  }\n  detachFiber(current$$1);\n}\n\nfunction commitWork(current$$1, finishedWork) {\n  if (!supportsMutation) {\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      return;\n    }\n    case HostComponent: {\n      var instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        var newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldProps =\n          current$$1 !== null ? current$$1.memoizedProps : newProps;\n        var type = finishedWork.type;\n        // TODO: Type the updateQueue to be specific to host components.\n        var updatePayload = finishedWork.updateQueue;\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      invariant(\n        finishedWork.stateNode !== null,\n        \"This should have a text node initialized. This error is likely \" +\n          \"caused by a bug in React. Please file an issue.\"\n      );\n      var textInstance = finishedWork.stateNode;\n      var newText = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case HostRoot: {\n      return;\n    }\n    case Profiler: {\n      return;\n    }\n    case PlaceholderComponent: {\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitResetTextContent(current$$1) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current$$1.stateNode);\n}\n\nfunction NoopComponent() {\n  return null;\n}\n\nfunction createRootErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: null };\n  var error = errorInfo.value;\n  update.callback = function() {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;\n  if (\n    enableGetDerivedStateFromCatch &&\n    typeof getDerivedStateFromCatch === \"function\"\n  ) {\n    var error = errorInfo.value;\n    update.payload = function() {\n      return getDerivedStateFromCatch(error);\n    };\n  }\n\n  var inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n    update.callback = function callback() {\n      if (\n        !enableGetDerivedStateFromCatch ||\n        getDerivedStateFromCatch !== \"function\"\n      ) {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromCatch is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      var error = errorInfo.value;\n      var stack = errorInfo.stack;\n      logError(fiber, errorInfo);\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : \"\"\n      });\n    };\n  }\n  return update;\n}\n\nfunction throwException(\n  root,\n  returnFiber,\n  sourceFiber,\n  value,\n  renderExpirationTime\n) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete;\n  // Its effect list is no longer valid.\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (\n    enableSuspense &&\n    value !== null &&\n    typeof value === \"object\" &&\n    typeof value.then === \"function\"\n  ) {\n    // This is a thenable.\n    var thenable = value;\n\n    // Find the earliest timeout threshold of all the placeholders in the\n    // ancestor path. We could avoid this traversal by storing the thresholds on\n    // the stack, but we choose not to because we only hit this path if we're\n    // IO-bound (i.e. if something suspends). Whereas the stack is used even in\n    // the non-IO- bound case.\n    var _workInProgress = returnFiber;\n    var earliestTimeoutMs = -1;\n    var startTimeMs = -1;\n    do {\n      if (_workInProgress.tag === PlaceholderComponent) {\n        var current = _workInProgress.alternate;\n        if (\n          current !== null &&\n          current.memoizedState === true &&\n          current.stateNode !== null\n        ) {\n          // Reached a placeholder that already timed out. Each timed out\n          // placeholder acts as the root of a new suspense boundary.\n\n          // Use the time at which the placeholder timed out as the start time\n          // for the current render.\n          var timedOutAt = current.stateNode.timedOutAt;\n          startTimeMs = expirationTimeToMs(timedOutAt);\n\n          // Do not search any further.\n          break;\n        }\n        var timeoutPropMs = _workInProgress.pendingProps.delayMs;\n        if (typeof timeoutPropMs === \"number\") {\n          if (timeoutPropMs <= 0) {\n            earliestTimeoutMs = 0;\n          } else if (\n            earliestTimeoutMs === -1 ||\n            timeoutPropMs < earliestTimeoutMs\n          ) {\n            earliestTimeoutMs = timeoutPropMs;\n          }\n        }\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n\n    // Schedule the nearest Placeholder to re-render the timed out view.\n    _workInProgress = returnFiber;\n    do {\n      if (_workInProgress.tag === PlaceholderComponent) {\n        var didTimeout = _workInProgress.memoizedState;\n        if (!didTimeout) {\n          // Found the nearest boundary.\n\n          // If the boundary is not in async mode, we should not suspend, and\n          // likewise, when the promise resolves, we should ping synchronously.\n          var pingTime =\n            (_workInProgress.mode & AsyncMode) === NoEffect\n              ? Sync\n              : renderExpirationTime;\n\n          // Attach a listener to the promise to \"ping\" the root and retry.\n          var onResolveOrReject = retrySuspendedRoot.bind(\n            null,\n            root,\n            _workInProgress,\n            pingTime\n          );\n          thenable.then(onResolveOrReject, onResolveOrReject);\n\n          // If the boundary is outside of strict mode, we should *not* suspend\n          // the commit. Pretend as if the suspended component rendered null and\n          // keep rendering. In the commit phase, we'll schedule a subsequent\n          // synchronous update to re-render the Placeholder.\n          //\n          // Note: It doesn't matter whether the component that suspended was\n          // inside a strict mode tree. If the Placeholder is outside of it, we\n          // should *not* suspend the commit.\n          if ((_workInProgress.mode & StrictMode) === NoEffect) {\n            _workInProgress.effectTag |= Update;\n\n            // Unmount the source fiber's children\n            var nextChildren = null;\n            reconcileChildren(\n              sourceFiber.alternate,\n              sourceFiber,\n              nextChildren,\n              renderExpirationTime\n            );\n            sourceFiber.effectTag &= ~Incomplete;\n            if (sourceFiber.tag === IndeterminateComponent) {\n              // Let's just assume it's a functional component. This fiber will\n              // be unmounted in the immediate next commit, anyway.\n              sourceFiber.tag = FunctionalComponent;\n            }\n\n            if (\n              sourceFiber.tag === ClassComponent ||\n              sourceFiber.tag === ClassComponentLazy\n            ) {\n              // We're going to commit this fiber even though it didn't\n              // complete. But we shouldn't call any lifecycle methods or\n              // callbacks. Remove all lifecycle effect tags.\n              sourceFiber.effectTag &= ~LifecycleEffectMask;\n              if (sourceFiber.alternate === null) {\n                // We're about to mount a class component that doesn't have an\n                // instance. Turn this into a dummy functional component instead,\n                // to prevent type errors. This is a bit weird but it's an edge\n                // case and we're about to synchronously delete this\n                // component, anyway.\n                sourceFiber.tag = FunctionalComponent;\n                sourceFiber.type = NoopComponent;\n              }\n            }\n\n            // Exit without suspending.\n            return;\n          }\n\n          // Confirmed that the boundary is in a strict mode tree. Continue with\n          // the normal suspend path.\n\n          var absoluteTimeoutMs = void 0;\n          if (earliestTimeoutMs === -1) {\n            // If no explicit threshold is given, default to an abitrarily large\n            // value. The actual size doesn't matter because the threshold for the\n            // whole tree will be clamped to the expiration time.\n            absoluteTimeoutMs = maxSigned31BitInt;\n          } else {\n            if (startTimeMs === -1) {\n              // This suspend happened outside of any already timed-out\n              // placeholders. We don't know exactly when the update was scheduled,\n              // but we can infer an approximate start time from the expiration\n              // time. First, find the earliest uncommitted expiration time in the\n              // tree, including work that is suspended. Then subtract the offset\n              // used to compute an async update's expiration time. This will cause\n              // high priority (interactive) work to expire earlier than necessary,\n              // but we can account for this by adjusting for the Just Noticeable\n              // Difference.\n              var earliestExpirationTime = findEarliestOutstandingPriorityLevel(\n                root,\n                renderExpirationTime\n              );\n              var earliestExpirationTimeMs = expirationTimeToMs(\n                earliestExpirationTime\n              );\n              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n            }\n            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;\n          }\n\n          // Mark the earliest timeout in the suspended fiber's ancestor path.\n          // After completing the root, we'll take the largest of all the\n          // suspended fiber's timeouts and use it to compute a timeout for the\n          // whole tree.\n          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);\n\n          _workInProgress.effectTag |= ShouldCapture;\n          _workInProgress.expirationTime = renderExpirationTime;\n          return;\n        }\n        // This boundary already captured during this render. Continue to the\n        // next boundary.\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n    // No boundary was found. Fallthrough to error mode.\n    value = new Error(\n      \"An update was suspended, but no placeholder UI was provided.\"\n    );\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  renderDidError();\n  value = createCapturedValue(value, sourceFiber);\n  var workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot: {\n        var _errorInfo = value;\n        workInProgress.effectTag |= ShouldCapture;\n        workInProgress.expirationTime = renderExpirationTime;\n        var update = createRootErrorUpdate(\n          workInProgress,\n          _errorInfo,\n          renderExpirationTime\n        );\n        enqueueCapturedUpdate(workInProgress, update);\n        return;\n      }\n      case ClassComponent:\n      case ClassComponentLazy:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n        if (\n          (workInProgress.effectTag & DidCapture) === NoEffect &&\n          ((typeof ctor.getDerivedStateFromCatch === \"function\" &&\n            enableGetDerivedStateFromCatch) ||\n            (instance !== null &&\n              typeof instance.componentDidCatch === \"function\" &&\n              !isAlreadyFailedLegacyErrorBoundary(instance)))\n        ) {\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          // Schedule the error boundary to re-render using updated state\n          var _update = createClassErrorUpdate(\n            workInProgress,\n            errorInfo,\n            renderExpirationTime\n          );\n          enqueueCapturedUpdate(workInProgress, _update);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction unwindWork(workInProgress, renderExpirationTime) {\n  switch (workInProgress.tag) {\n    case ClassComponent: {\n      var Component = workInProgress.type;\n      if (isContextProvider(Component)) {\n        popContext(workInProgress);\n      }\n      var effectTag = workInProgress.effectTag;\n      if (effectTag & ShouldCapture) {\n        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case ClassComponentLazy: {\n      var _Component = workInProgress.type._reactResult;\n      if (isContextProvider(_Component)) {\n        popContext(workInProgress);\n      }\n      var _effectTag = workInProgress.effectTag;\n      if (_effectTag & ShouldCapture) {\n        workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelContextObject(workInProgress);\n      var _effectTag2 = workInProgress.effectTag;\n      invariant(\n        (_effectTag2 & DidCapture) === NoEffect,\n        \"The root failed to unmount after an error. This is likely a bug in \" +\n          \"React. Please file an issue.\"\n      );\n      workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture;\n      return workInProgress;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      return null;\n    }\n    case PlaceholderComponent: {\n      var _effectTag3 = workInProgress.effectTag;\n      if (_effectTag3 & ShouldCapture) {\n        workInProgress.effectTag = (_effectTag3 & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      popProvider(workInProgress);\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork) {\n  switch (interruptedWork.tag) {\n    case ClassComponent: {\n      var childContextTypes = interruptedWork.type.childContextTypes;\n      if (childContextTypes !== null && childContextTypes !== undefined) {\n        popContext(interruptedWork);\n      }\n      break;\n    }\n    case ClassComponentLazy: {\n      var _childContextTypes =\n        interruptedWork.type._reactResult.childContextTypes;\n      if (_childContextTypes !== null && _childContextTypes !== undefined) {\n        popContext(interruptedWork);\n      }\n      break;\n    }\n    case HostRoot: {\n      popHostContainer(interruptedWork);\n      popTopLevelContextObject(interruptedWork);\n      break;\n    }\n    case HostComponent: {\n      popHostContext(interruptedWork);\n      break;\n    }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case ContextProvider:\n      popProvider(interruptedWork);\n      break;\n    default:\n      break;\n  }\n}\n\nvar Dispatcher = {\n  readContext: readContext\n};\n\nvar ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\nif (enableSchedulerTracking) {\n  // Provide explicit error message when production+profiling bundle of e.g. react-dom\n  // is used with production (non-profiling) bundle of schedule/tracking\n  invariant(\n    tracking.__interactionsRef != null &&\n      tracking.__interactionsRef.current != null,\n    \"It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) \" +\n      \"without also replacing the `schedule/tracking` module with `schedule/tracking-profiling`. \" +\n      \"Your bundler might have a setting for aliasing both modules. \" +\n      \"Learn more at http://fb.me/react-profiling\"\n  );\n}\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function(fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber.type) || \"ReactClass\";\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warningWithoutStack$1(\n      false,\n      \"Can't call setState (or forceUpdate) on an unmounted component. This \" +\n        \"is a no-op, but it indicates a memory leak in your application. To \" +\n        \"fix, cancel all subscriptions and asynchronous tasks in the \" +\n        \"componentWillUnmount method.%s\",\n      getStackByFiberInDevAndProd(fiber)\n    );\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function(instance) {\n    switch (phase) {\n      case \"getChildContext\":\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warningWithoutStack$1(\n          false,\n          \"setState(...): Cannot call setState() inside getChildContext()\"\n        );\n        didWarnSetStateChildContext = true;\n        break;\n      case \"render\":\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warningWithoutStack$1(\n          false,\n          \"Cannot update during an existing state transition (such as within \" +\n            \"`render`). Render methods should be a pure function of props and state.\"\n        );\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\n// Represents the expiration time that incoming updates should use. (If this\n// is NoWork, use the default strategy: async updates in async mode, sync\n// updates in sync mode.)\nvar expirationContext = NoWork;\n\nvar isWorking = false;\n\n// The next work in progress fiber that we're currently working on.\nvar nextUnitOfWork = null;\nvar nextRoot = null;\n// The time at which we're currently rendering work.\nvar nextRenderExpirationTime = NoWork;\nvar nextLatestAbsoluteTimeoutMs = -1;\nvar nextRenderDidError = false;\n\n// The next fiber with an effect that we're currently committing.\nvar nextEffect = null;\n\nvar isCommitting$1 = false;\n\nvar legacyErrorBoundariesThatAlreadyFailed = null;\n\n// Used for performance tracking.\nvar interruptedBy = null;\n\n// Do not decrement interaction counts in the event of suspense timeouts.\n// This would lead to prematurely calling the interaction-complete hook.\nvar suspenseDidTimeout = false;\n\nvar stashedWorkInProgressProperties = void 0;\nvar replayUnitOfWork = void 0;\nvar isReplayingFailedUnitOfWork = void 0;\nvar originalReplayError = void 0;\nvar rethrowOriginalError = void 0;\nif (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  stashedWorkInProgressProperties = null;\n  isReplayingFailedUnitOfWork = false;\n  originalReplayError = null;\n  replayUnitOfWork = function(failedUnitOfWork, thrownValue, isYieldy) {\n    if (\n      thrownValue !== null &&\n      typeof thrownValue === \"object\" &&\n      typeof thrownValue.then === \"function\"\n    ) {\n      // Don't replay promises. Treat everything else like an error.\n      // TODO: Need to figure out a different strategy if/when we add\n      // support for catching other types.\n      return;\n    }\n\n    // Restore the original state of the work-in-progress\n    if (stashedWorkInProgressProperties === null) {\n      // This should never happen. Don't throw because this code is DEV-only.\n      warningWithoutStack$1(\n        false,\n        \"Could not replay rendering after an error. This is likely a bug in React. \" +\n          \"Please file an issue.\"\n      );\n      return;\n    }\n    assignFiberPropertiesInDEV(\n      failedUnitOfWork,\n      stashedWorkInProgressProperties\n    );\n\n    switch (failedUnitOfWork.tag) {\n      case HostRoot:\n        popHostContainer(failedUnitOfWork);\n        popTopLevelContextObject(failedUnitOfWork);\n        break;\n      case HostComponent:\n        popHostContext(failedUnitOfWork);\n        break;\n      case ClassComponent: {\n        var Component = failedUnitOfWork.type;\n        if (isContextProvider(Component)) {\n          popContext(failedUnitOfWork);\n        }\n        break;\n      }\n      case ClassComponentLazy: {\n        var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);\n        if (isContextProvider(_Component)) {\n          popContext(failedUnitOfWork);\n        }\n        break;\n      }\n      case HostPortal:\n        popHostContainer(failedUnitOfWork);\n        break;\n      case ContextProvider:\n        popProvider(failedUnitOfWork);\n        break;\n    }\n    // Replay the begin phase.\n    isReplayingFailedUnitOfWork = true;\n    originalReplayError = thrownValue;\n    invokeGuardedCallback(null, workLoop, null, isYieldy);\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    if (hasCaughtError()) {\n      var replayError = clearCaughtError();\n      if (replayError != null && thrownValue != null) {\n        try {\n          // Reading the expando property is intentionally\n          // inside `try` because it might be a getter or Proxy.\n          if (replayError._suppressLogging) {\n            // Also suppress logging for the original error.\n            thrownValue._suppressLogging = true;\n          }\n        } catch (inner) {\n          // Ignore.\n        }\n      }\n    } else {\n      // If the begin phase did not fail the second time, set this pointer\n      // back to the original value.\n      nextUnitOfWork = failedUnitOfWork;\n    }\n  };\n  rethrowOriginalError = function() {\n    throw originalReplayError;\n  };\n}\n\nfunction resetStack() {\n  if (nextUnitOfWork !== null) {\n    var interruptedWork = nextUnitOfWork.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    checkThatStackIsEmpty();\n  }\n\n  nextRoot = null;\n  nextRenderExpirationTime = NoWork;\n  nextLatestAbsoluteTimeoutMs = -1;\n  nextRenderDidError = false;\n  nextUnitOfWork = null;\n}\n\nfunction commitAllHostEffects() {\n  while (nextEffect !== null) {\n    {\n      setCurrentFiber(nextEffect);\n    }\n    recordEffect();\n\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      var current$$1 = nextEffect.alternate;\n      if (current$$1 !== null) {\n        commitDetachRef(current$$1);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every\n    // possible bitmap value, we remove the secondary effects from the\n    // effect tag and switch on that value.\n    var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement: {\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n        // any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted\n        // does and isMounted is deprecated anyway so we should be able\n        // to kill this.\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      case PlacementAndUpdate: {\n        // Placement\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n        // any life-cycles like componentDidMount gets called.\n        nextEffect.effectTag &= ~Placement;\n\n        // Update\n        var _current = nextEffect.alternate;\n        commitWork(_current, nextEffect);\n        break;\n      }\n      case Update: {\n        var _current2 = nextEffect.alternate;\n        commitWork(_current2, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(nextEffect);\n        break;\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitBeforeMutationLifecycles() {\n  while (nextEffect !== null) {\n    {\n      setCurrentFiber(nextEffect);\n    }\n\n    var effectTag = nextEffect.effectTag;\n    if (effectTag & Snapshot) {\n      recordEffect();\n      var current$$1 = nextEffect.alternate;\n      commitBeforeMutationLifeCycles(current$$1, nextEffect);\n    }\n\n    // Don't cleanup effects yet;\n    // This will be done by commitAllLifeCycles()\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitAllLifeCycles(finishedRoot, committedExpirationTime) {\n  {\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n    }\n\n    if (warnAboutLegacyContextAPI) {\n      ReactStrictModeWarnings.flushLegacyContextWarning();\n    }\n  }\n  while (nextEffect !== null) {\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      var current$$1 = nextEffect.alternate;\n      commitLifeCycles(\n        finishedRoot,\n        current$$1,\n        nextEffect,\n        committedExpirationTime\n      );\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    var next = nextEffect.nextEffect;\n    // Ensure that we clean these up so that we don't accidentally keep them.\n    // I'm not actually sure this matters because we can't reset firstEffect\n    // and lastEffect since they're on every node, not just the effectful\n    // ones. So we have to clean everything as we reuse nodes anyway.\n    nextEffect.nextEffect = null;\n    // Ensure that we reset the effectTag here so that we can rely on effect\n    // tags to reason about the current life-cycle.\n    nextEffect = next;\n  }\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction commitRoot(root, finishedWork) {\n  isWorking = true;\n  isCommitting$1 = true;\n  startCommitTimer();\n\n  invariant(\n    root.current !== finishedWork,\n    \"Cannot commit the same tree as before. This is probably a bug \" +\n      \"related to the return field. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n  var committedExpirationTime = root.pendingCommitExpirationTime;\n  invariant(\n    committedExpirationTime !== NoWork,\n    \"Cannot commit an incomplete root. This error is likely caused by a \" +\n      \"bug in React. Please file an issue.\"\n  );\n  root.pendingCommitExpirationTime = NoWork;\n\n  // Update the pending priority levels to account for the work that we are\n  // about to commit. This needs to happen before calling the lifecycles, since\n  // they may schedule additional updates.\n  var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;\n  var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;\n  var earliestRemainingTimeBeforeCommit =\n    updateExpirationTimeBeforeCommit === NoWork ||\n    (childExpirationTimeBeforeCommit !== NoWork &&\n      childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit)\n      ? childExpirationTimeBeforeCommit\n      : updateExpirationTimeBeforeCommit;\n  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);\n\n  var prevInteractions = null;\n  var committedInteractions = enableSchedulerTracking ? [] : null;\n  if (enableSchedulerTracking) {\n    // Restore any pending interactions at this point,\n    // So that cascading work triggered during the render phase will be accounted for.\n    prevInteractions = tracking.__interactionsRef.current;\n    tracking.__interactionsRef.current = root.memoizedInteractions;\n\n    // We are potentially finished with the current batch of interactions.\n    // So we should clear them out of the pending interaction map.\n    // We do this at the start of commit in case cascading work is scheduled by commit phase lifecycles.\n    // In that event, interaction data may be added back into the pending map for a future commit.\n    // We also store the interactions we are about to commit so that we can notify subscribers after we're done.\n    // These are stored as an Array rather than a Set,\n    // Because the same interaction may be pending for multiple expiration times,\n    // In which case it's important that we decrement the count the right number of times after finishing.\n    root.pendingInteractionMap.forEach(function(\n      scheduledInteractions,\n      scheduledExpirationTime\n    ) {\n      if (scheduledExpirationTime <= committedExpirationTime) {\n        committedInteractions.push.apply(\n          committedInteractions,\n          Array.from(scheduledInteractions)\n        );\n        root.pendingInteractionMap.delete(scheduledExpirationTime);\n      }\n    });\n  }\n\n  // Reset this to null before calling lifecycles\n  ReactCurrentOwner$2.current = null;\n\n  var firstEffect = void 0;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if\n    // it had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  prepareForCommit(root.containerInfo);\n\n  // Invoke instances of getSnapshotBeforeUpdate before mutation.\n  nextEffect = firstEffect;\n  startCommitSnapshotEffectsTimer();\n  while (nextEffect !== null) {\n    var didError = false;\n    var error = void 0;\n    {\n      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n    if (didError) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitSnapshotEffectsTimer();\n\n  if (enableProfilerTimer) {\n    // Mark the current commit time to be shared by all Profilers in this batch.\n    // This enables them to be grouped later.\n    recordCommitTime();\n  }\n\n  // Commit all the side-effects within a tree. We'll do this in two passes.\n  // The first pass performs all the host insertions, updates, deletions and\n  // ref unmounts.\n  nextEffect = firstEffect;\n  startCommitHostEffectsTimer();\n  while (nextEffect !== null) {\n    var _didError = false;\n    var _error = void 0;\n    {\n      invokeGuardedCallback(null, commitAllHostEffects, null);\n      if (hasCaughtError()) {\n        _didError = true;\n        _error = clearCaughtError();\n      }\n    }\n    if (_didError) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, _error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitHostEffectsTimer();\n\n  resetAfterCommit(root.containerInfo);\n\n  // The work-in-progress tree is now the current tree. This must come after\n  // the first pass of the commit phase, so that the previous tree is still\n  // current during componentWillUnmount, but before the second pass, so that\n  // the finished work is current during componentDidMount/Update.\n  root.current = finishedWork;\n\n  // In the second pass we'll perform all life-cycles and ref callbacks.\n  // Life-cycles happen as a separate pass so that all placements, updates,\n  // and deletions in the entire tree have already been invoked.\n  // This pass also triggers any renderer-specific initial effects.\n  nextEffect = firstEffect;\n  startCommitLifeCyclesTimer();\n  while (nextEffect !== null) {\n    var _didError2 = false;\n    var _error2 = void 0;\n    {\n      invokeGuardedCallback(\n        null,\n        commitAllLifeCycles,\n        null,\n        root,\n        committedExpirationTime\n      );\n      if (hasCaughtError()) {\n        _didError2 = true;\n        _error2 = clearCaughtError();\n      }\n    }\n    if (_didError2) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, _error2);\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n\n  isCommitting$1 = false;\n  isWorking = false;\n  stopCommitLifeCyclesTimer();\n  stopCommitTimer();\n  onCommitRoot(finishedWork.stateNode);\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n  }\n\n  var updateExpirationTimeAfterCommit = finishedWork.expirationTime;\n  var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;\n  var earliestRemainingTimeAfterCommit =\n    updateExpirationTimeAfterCommit === NoWork ||\n    (childExpirationTimeAfterCommit !== NoWork &&\n      childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit)\n      ? childExpirationTimeAfterCommit\n      : updateExpirationTimeAfterCommit;\n  if (earliestRemainingTimeAfterCommit === NoWork) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n  onCommit(root, earliestRemainingTimeAfterCommit);\n\n  if (enableSchedulerTracking) {\n    tracking.__interactionsRef.current = prevInteractions;\n\n    var subscriber = void 0;\n\n    try {\n      subscriber = tracking.__subscriberRef.current;\n      if (subscriber !== null && root.memoizedInteractions.size > 0) {\n        var threadID = computeThreadID(\n          committedExpirationTime,\n          root.interactionThreadID\n        );\n        subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n      }\n    } catch (error) {\n      // It's not safe for commitRoot() to throw.\n      // Store the error for now and we'll re-throw in finishRendering().\n      if (!hasUnhandledError) {\n        hasUnhandledError = true;\n        unhandledError = error;\n      }\n    } finally {\n      // Don't update interaction counts if we're frozen due to suspense.\n      // In this case, we can skip the completed-work check entirely.\n      if (!suspenseDidTimeout) {\n        // Now that we're done, check the completed batch of interactions.\n        // If no more work is outstanding for a given interaction,\n        // We need to notify the subscribers that it's finished.\n        committedInteractions.forEach(function(interaction) {\n          interaction.__count--;\n          if (subscriber !== null && interaction.__count === 0) {\n            try {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            } catch (error) {\n              // It's not safe for commitRoot() to throw.\n              // Store the error for now and we'll re-throw in finishRendering().\n              if (!hasUnhandledError) {\n                hasUnhandledError = true;\n                unhandledError = error;\n              }\n            }\n          }\n        });\n      }\n    }\n  }\n}\n\nfunction resetChildExpirationTime(workInProgress, renderTime) {\n  if (renderTime !== Never && workInProgress.childExpirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  var newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n    // We're in profiling mode.\n    // Let's use this same traversal to update the render durations.\n    var actualDuration = workInProgress.actualDuration;\n    var treeBaseDuration = workInProgress.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0.\n    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration.\n    // If the fiber has not been cloned though, (meaning no work was done),\n    // Then this value will reflect the amount of time spent working on a previous render.\n    // In that case it should not bubble.\n    // We determine whether it was cloned by comparing the child pointer.\n    var shouldBubbleActualDurations =\n      workInProgress.alternate === null ||\n      workInProgress.child !== workInProgress.alternate.child;\n\n    var child = workInProgress.child;\n    while (child !== null) {\n      var childUpdateExpirationTime = child.expirationTime;\n      var childChildExpirationTime = child.childExpirationTime;\n      if (\n        newChildExpirationTime === NoWork ||\n        (childUpdateExpirationTime !== NoWork &&\n          childUpdateExpirationTime < newChildExpirationTime)\n      ) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (\n        newChildExpirationTime === NoWork ||\n        (childChildExpirationTime !== NoWork &&\n          childChildExpirationTime < newChildExpirationTime)\n      ) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    workInProgress.actualDuration = actualDuration;\n    workInProgress.treeBaseDuration = treeBaseDuration;\n  } else {\n    var _child = workInProgress.child;\n    while (_child !== null) {\n      var _childUpdateExpirationTime = _child.expirationTime;\n      var _childChildExpirationTime = _child.childExpirationTime;\n      if (\n        newChildExpirationTime === NoWork ||\n        (_childUpdateExpirationTime !== NoWork &&\n          _childUpdateExpirationTime < newChildExpirationTime)\n      ) {\n        newChildExpirationTime = _childUpdateExpirationTime;\n      }\n      if (\n        newChildExpirationTime === NoWork ||\n        (_childChildExpirationTime !== NoWork &&\n          _childChildExpirationTime < newChildExpirationTime)\n      ) {\n        newChildExpirationTime = _childChildExpirationTime;\n      }\n      _child = _child.sibling;\n    }\n  }\n\n  workInProgress.childExpirationTime = newChildExpirationTime;\n}\n\nfunction completeUnitOfWork(workInProgress) {\n  // Attempt to complete the current unit of work, then move to the\n  // next sibling. If there are no more siblings, return to the\n  // parent fiber.\n  while (true) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current$$1 = workInProgress.alternate;\n    {\n      setCurrentFiber(workInProgress);\n    }\n\n    var returnFiber = workInProgress.return;\n    var siblingFiber = workInProgress.sibling;\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      // This fiber completed.\n      if (enableProfilerTimer) {\n        if (workInProgress.mode & ProfileMode) {\n          startProfilerTimer(workInProgress);\n        }\n\n        nextUnitOfWork = completeWork(\n          current$$1,\n          workInProgress,\n          nextRenderExpirationTime\n        );\n\n        if (workInProgress.mode & ProfileMode) {\n          // Update render duration assuming we didn't error.\n          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n        }\n      } else {\n        nextUnitOfWork = completeWork(\n          current$$1,\n          workInProgress,\n          nextRenderExpirationTime\n        );\n      }\n      var next = nextUnitOfWork;\n      stopWorkTimer(workInProgress);\n      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);\n      {\n        resetCurrentFiber();\n      }\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (\n        returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        return null;\n      }\n    } else {\n      if (workInProgress.mode & ProfileMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(workInProgress, nextRenderExpirationTime);\n      // Because this fiber did not complete, don't reset its expiration time.\n      if (workInProgress.effectTag & DidCapture) {\n        // Restarting an error boundary\n        stopFailedWorkTimer(workInProgress);\n      } else {\n        stopWorkTimer(workInProgress);\n      }\n\n      {\n        resetCurrentFiber();\n      }\n\n      if (_next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (enableProfilerTimer) {\n          // Include the time spent working on failed children before continuing.\n          if (_next.mode & ProfileMode) {\n            var actualDuration = _next.actualDuration;\n            var child = _next.child;\n            while (child !== null) {\n              actualDuration += child.actualDuration;\n              child = child.sibling;\n            }\n            _next.actualDuration = actualDuration;\n          }\n        }\n\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.effectTag &= HostEffectMask;\n        return _next;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  // Without this explicit null return Flow complains of invalid return type\n  // TODO Remove the above while(true) loop\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction performUnitOfWork(workInProgress) {\n  // The current, flushed, state of this fiber is the alternate.\n  // Ideally nothing should rely on this, but relying on it here\n  // means that we don't need an additional field on the work in\n  // progress.\n  var current$$1 = workInProgress.alternate;\n\n  // See if beginning this work spawns more work.\n  startWorkTimer(workInProgress);\n  {\n    setCurrentFiber(workInProgress);\n  }\n\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(\n      stashedWorkInProgressProperties,\n      workInProgress\n    );\n  }\n\n  var next = void 0;\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      startProfilerTimer(workInProgress);\n    }\n\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n\n    if (workInProgress.mode & ProfileMode) {\n      // Record the render duration assuming we didn't bailout (or error).\n      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n    }\n  } else {\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n  }\n\n  {\n    resetCurrentFiber();\n    if (isReplayingFailedUnitOfWork) {\n      // Currently replaying a failed unit of work. This should be unreachable,\n      // because the render phase is meant to be idempotent, and it should\n      // have thrown again. Since it didn't, rethrow the original error, so\n      // React's internal stack is not misaligned.\n      rethrowOriginalError();\n    }\n  }\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n  }\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(workInProgress);\n  }\n\n  ReactCurrentOwner$2.current = null;\n\n  return next;\n}\n\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    // Flush work without yielding\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {\n    // Flush asynchronous work until the deadline runs out of time.\n    while (nextUnitOfWork !== null && !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\nfunction renderRoot(root, isYieldy, isExpired) {\n  invariant(\n    !isWorking,\n    \"renderRoot was called recursively. This error is likely caused \" +\n      \"by a bug in React. Please file an issue.\"\n  );\n  isWorking = true;\n  ReactCurrentOwner$2.currentDispatcher = Dispatcher;\n\n  var expirationTime = root.nextExpirationTimeToWorkOn;\n\n  var prevInteractions = null;\n  if (enableSchedulerTracking) {\n    // We're about to start new tracked work.\n    // Restore pending interactions so cascading work triggered during the render phase will be accounted for.\n    prevInteractions = tracking.__interactionsRef.current;\n    tracking.__interactionsRef.current = root.memoizedInteractions;\n  }\n\n  // Check if we're starting from a fresh stack, or if we're resuming from\n  // previously yielded work.\n  if (\n    expirationTime !== nextRenderExpirationTime ||\n    root !== nextRoot ||\n    nextUnitOfWork === null\n  ) {\n    // Reset the stack and start working from the root.\n    resetStack();\n    nextRoot = root;\n    nextRenderExpirationTime = expirationTime;\n    nextUnitOfWork = createWorkInProgress(\n      nextRoot.current,\n      null,\n      nextRenderExpirationTime\n    );\n    root.pendingCommitExpirationTime = NoWork;\n\n    if (enableSchedulerTracking) {\n      // Determine which interactions this batch of work currently includes,\n      // So that we can accurately attribute time spent working on it,\n      var interactions = new Set();\n      root.pendingInteractionMap.forEach(function(\n        scheduledInteractions,\n        scheduledExpirationTime\n      ) {\n        if (scheduledExpirationTime <= expirationTime) {\n          scheduledInteractions.forEach(function(interaction) {\n            return interactions.add(interaction);\n          });\n        }\n      });\n\n      // Store the current set of interactions on the FiberRoot for a few reasons:\n      // We can re-use it in hot functions like renderRoot() without having to recalculate it.\n      // We will also use it in commitWork() to pass to any Profiler onRender() hooks.\n      // This also provides DevTools with a way to access it when the onCommitRoot() hook is called.\n      root.memoizedInteractions = interactions;\n\n      if (interactions.size > 0) {\n        var subscriber = tracking.__subscriberRef.current;\n        if (subscriber !== null) {\n          var threadID = computeThreadID(\n            expirationTime,\n            root.interactionThreadID\n          );\n          try {\n            subscriber.onWorkStarted(interactions, threadID);\n          } catch (error) {\n            // Work thrown by an interaction tracking subscriber should be rethrown,\n            // But only once it's safe (to avoid leaveing the scheduler in an invalid state).\n            // Store the error for now and we'll re-throw in finishRendering().\n            if (!hasUnhandledError) {\n              hasUnhandledError = true;\n              unhandledError = error;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var didFatal = false;\n\n  startWorkLoopTimer(nextUnitOfWork);\n\n  do {\n    try {\n      workLoop(isYieldy);\n    } catch (thrownValue) {\n      if (nextUnitOfWork === null) {\n        // This is a fatal error.\n        didFatal = true;\n        onUncaughtError(thrownValue);\n      } else {\n        {\n          // Reset global debug state\n          // We assume this is defined in DEV\n          resetCurrentlyProcessingQueue();\n        }\n\n        var failedUnitOfWork = nextUnitOfWork;\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);\n        }\n\n        // TODO: we already know this isn't true in some cases.\n        // At least this shows a nicer error message until we figure out the cause.\n        // https://github.com/facebook/react/issues/12449#issuecomment-386727431\n        invariant(\n          nextUnitOfWork !== null,\n          \"Failed to replay rendering after an error. This \" +\n            \"is likely caused by a bug in React. Please file an issue \" +\n            \"with a reproducing case to help us find it.\"\n        );\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber.return;\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n        } else {\n          throwException(\n            root,\n            returnFiber,\n            sourceFiber,\n            thrownValue,\n            nextRenderExpirationTime\n          );\n          nextUnitOfWork = completeUnitOfWork(sourceFiber);\n          continue;\n        }\n      }\n    }\n    break;\n  } while (true);\n\n  if (enableSchedulerTracking) {\n    // Tracked work is done for now; restore the previous interactions.\n    tracking.__interactionsRef.current = prevInteractions;\n  }\n\n  // We're done performing work. Time to clean up.\n  isWorking = false;\n  ReactCurrentOwner$2.currentDispatcher = null;\n  resetContextDependences();\n\n  // Yield back to main thread.\n  if (didFatal) {\n    var _didCompleteRoot = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot);\n    interruptedBy = null;\n    // There was a fatal error.\n    {\n      resetStackAfterFatalErrorInDev();\n    }\n    // `nextRoot` points to the in-progress root. A non-null value indicates\n    // that we're in the middle of an async render. Set it to null to indicate\n    // there's no more work to be done in the current batch.\n    nextRoot = null;\n    onFatal(root);\n    return;\n  }\n\n  if (nextUnitOfWork !== null) {\n    // There's still remaining async work in this tree, but we ran out of time\n    // in the current frame. Yield back to the renderer. Unless we're\n    // interrupted by a higher priority update, we'll continue later from where\n    // we left off.\n    var _didCompleteRoot2 = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);\n    interruptedBy = null;\n    onYield(root);\n    return;\n  }\n\n  // We completed the whole tree.\n  var didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  var rootWorkInProgress = root.current.alternate;\n  invariant(\n    rootWorkInProgress !== null,\n    \"Finished root should have a work-in-progress. This error is likely \" +\n      \"caused by a bug in React. Please file an issue.\"\n  );\n\n  // `nextRoot` points to the in-progress root. A non-null value indicates\n  // that we're in the middle of an async render. Set it to null to indicate\n  // there's no more work to be done in the current batch.\n  nextRoot = null;\n  interruptedBy = null;\n\n  if (nextRenderDidError) {\n    // There was an error\n    if (hasLowerPriorityWork(root, expirationTime)) {\n      // There's lower priority work. If so, it may have the effect of fixing\n      // the exception that was just thrown. Exit without committing. This is\n      // similar to a suspend, but without a timeout because we're not waiting\n      // for a promise to resolve. React will restart at the lower\n      // priority level.\n      markSuspendedPriorityLevel(root, expirationTime);\n      var suspendedExpirationTime = expirationTime;\n      var rootExpirationTime = root.expirationTime;\n      onSuspend(\n        root,\n        rootWorkInProgress,\n        suspendedExpirationTime,\n        rootExpirationTime,\n        -1 // Indicates no timeout\n      );\n      return;\n    } else if (\n      // There's no lower priority work, but we're rendering asynchronously.\n      // Synchronsouly attempt to render the same level one more time. This is\n      // similar to a suspend, but without a timeout because we're not waiting\n      // for a promise to resolve.\n      !root.didError &&\n      !isExpired\n    ) {\n      root.didError = true;\n      var _suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime);\n      var _rootExpirationTime = (root.expirationTime = Sync);\n      onSuspend(\n        root,\n        rootWorkInProgress,\n        _suspendedExpirationTime,\n        _rootExpirationTime,\n        -1 // Indicates no timeout\n      );\n      return;\n    }\n  }\n\n  if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {\n    // The tree was suspended.\n    var _suspendedExpirationTime2 = expirationTime;\n    markSuspendedPriorityLevel(root, _suspendedExpirationTime2);\n\n    // Find the earliest uncommitted expiration time in the tree, including\n    // work that is suspended. The timeout threshold cannot be longer than\n    // the overall expiration.\n    var earliestExpirationTime = findEarliestOutstandingPriorityLevel(\n      root,\n      expirationTime\n    );\n    var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {\n      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;\n    }\n\n    // Subtract the current time from the absolute timeout to get the number\n    // of milliseconds until the timeout. In other words, convert an absolute\n    // timestamp to a relative time. This is the value that is passed\n    // to `setTimeout`.\n    var currentTimeMs = expirationTimeToMs(requestCurrentTime());\n    var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;\n    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;\n\n    // TODO: Account for the Just Noticeable Difference\n\n    var _rootExpirationTime2 = root.expirationTime;\n    onSuspend(\n      root,\n      rootWorkInProgress,\n      _suspendedExpirationTime2,\n      _rootExpirationTime2,\n      msUntilTimeout\n    );\n    return;\n  }\n\n  // Ready to commit.\n  onComplete(root, rootWorkInProgress, expirationTime);\n}\n\nfunction dispatch(sourceFiber, value, expirationTime) {\n  invariant(\n    !isWorking || isCommitting$1,\n    \"dispatch: Cannot dispatch during the render phase.\"\n  );\n\n  var fiber = sourceFiber.return;\n  while (fiber !== null) {\n    switch (fiber.tag) {\n      case ClassComponent:\n      case ClassComponentLazy:\n        var ctor = fiber.type;\n        var instance = fiber.stateNode;\n        if (\n          typeof ctor.getDerivedStateFromCatch === \"function\" ||\n          (typeof instance.componentDidCatch === \"function\" &&\n            !isAlreadyFailedLegacyErrorBoundary(instance))\n        ) {\n          var errorInfo = createCapturedValue(value, sourceFiber);\n          var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);\n          enqueueUpdate(fiber, update);\n          scheduleWork(fiber, expirationTime);\n          return;\n        }\n        break;\n      case HostRoot: {\n        var _errorInfo = createCapturedValue(value, sourceFiber);\n        var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);\n        enqueueUpdate(fiber, _update);\n        scheduleWork(fiber, expirationTime);\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    var rootFiber = sourceFiber;\n    var _errorInfo2 = createCapturedValue(value, rootFiber);\n    var _update2 = createRootErrorUpdate(\n      rootFiber,\n      _errorInfo2,\n      expirationTime\n    );\n    enqueueUpdate(rootFiber, _update2);\n    scheduleWork(rootFiber, expirationTime);\n  }\n}\n\nfunction captureCommitPhaseError(fiber, error) {\n  return dispatch(fiber, error, Sync);\n}\n\nfunction computeThreadID(expirationTime, interactionThreadID) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + interactionThreadID;\n}\n\nfunction computeExpirationForFiber(currentTime, fiber) {\n  var expirationTime = void 0;\n  if (expirationContext !== NoWork) {\n    // An explicit expiration context was set;\n    expirationTime = expirationContext;\n  } else if (isWorking) {\n    if (isCommitting$1) {\n      // Updates that occur during the commit phase should have sync priority\n      // by default.\n      expirationTime = Sync;\n    } else {\n      // Updates during the render phase should expire at the same time as\n      // the work that is being rendered.\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // No explicit expiration context was set, and we're not currently\n    // performing work. Calculate a new expiration time.\n    if (fiber.mode & AsyncMode) {\n      if (isBatchingInteractiveUpdates) {\n        // This is an interactive update\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n      // If we're in the middle of rendering a tree, do not update at the same\n      // expiration time that is already rendering.\n      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {\n        expirationTime += 1;\n      }\n    } else {\n      // This is a sync update\n      expirationTime = Sync;\n    }\n  }\n  if (isBatchingInteractiveUpdates) {\n    // This is an interactive update. Keep track of the lowest pending\n    // interactive expiration time. This allows us to synchronously flush\n    // all interactive updates when needed.\n    if (\n      lowestPriorityPendingInteractiveExpirationTime === NoWork ||\n      expirationTime > lowestPriorityPendingInteractiveExpirationTime\n    ) {\n      lowestPriorityPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n\nfunction renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {\n  // Schedule the timeout.\n  if (\n    absoluteTimeoutMs >= 0 &&\n    nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs\n  ) {\n    nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;\n  }\n}\n\nfunction renderDidError() {\n  nextRenderDidError = true;\n}\n\nfunction retrySuspendedRoot(root, fiber, suspendedTime) {\n  if (enableSuspense) {\n    var retryTime = void 0;\n\n    if (isPriorityLevelSuspended(root, suspendedTime)) {\n      // Ping at the original level\n      retryTime = suspendedTime;\n      markPingedPriorityLevel(root, retryTime);\n    } else {\n      // Placeholder already timed out. Compute a new expiration time\n      var currentTime = requestCurrentTime();\n      retryTime = computeExpirationForFiber(currentTime, fiber);\n      markPendingPriorityLevel(root, retryTime);\n    }\n\n    scheduleWorkToRoot(fiber, retryTime);\n    var rootExpirationTime = root.expirationTime;\n    if (rootExpirationTime !== NoWork) {\n      if (enableSchedulerTracking) {\n        // Restore previous interactions so that new work is associated with them.\n        var prevInteractions = tracking.__interactionsRef.current;\n        tracking.__interactionsRef.current = root.memoizedInteractions;\n        // Because suspense timeouts do not decrement the interaction count,\n        // Continued suspense work should also not increment the count.\n        storeInteractionsForExpirationTime(root, rootExpirationTime, false);\n        requestWork(root, rootExpirationTime);\n        tracking.__interactionsRef.current = prevInteractions;\n      } else {\n        requestWork(root, rootExpirationTime);\n      }\n    }\n  }\n}\n\nfunction scheduleWorkToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (\n    fiber.expirationTime === NoWork ||\n    fiber.expirationTime > expirationTime\n  ) {\n    fiber.expirationTime = expirationTime;\n  }\n  var alternate = fiber.alternate;\n  if (\n    alternate !== null &&\n    (alternate.expirationTime === NoWork ||\n      alternate.expirationTime > expirationTime)\n  ) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  var node = fiber.return;\n  if (node === null && fiber.tag === HostRoot) {\n    return fiber.stateNode;\n  }\n  while (node !== null) {\n    alternate = node.alternate;\n    if (\n      node.childExpirationTime === NoWork ||\n      node.childExpirationTime > expirationTime\n    ) {\n      node.childExpirationTime = expirationTime;\n      if (\n        alternate !== null &&\n        (alternate.childExpirationTime === NoWork ||\n          alternate.childExpirationTime > expirationTime)\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n    } else if (\n      alternate !== null &&\n      (alternate.childExpirationTime === NoWork ||\n        alternate.childExpirationTime > expirationTime)\n    ) {\n      alternate.childExpirationTime = expirationTime;\n    }\n    if (node.return === null && node.tag === HostRoot) {\n      return node.stateNode;\n    }\n    node = node.return;\n  }\n  return null;\n}\n\nfunction storeInteractionsForExpirationTime(\n  root,\n  expirationTime,\n  updateInteractionCounts\n) {\n  if (!enableSchedulerTracking) {\n    return;\n  }\n\n  var interactions = tracking.__interactionsRef.current;\n  if (interactions.size > 0) {\n    var pendingInteractions = root.pendingInteractionMap.get(expirationTime);\n    if (pendingInteractions != null) {\n      interactions.forEach(function(interaction) {\n        if (updateInteractionCounts && !pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      root.pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      if (updateInteractionCounts) {\n        interactions.forEach(function(interaction) {\n          interaction.__count++;\n        });\n      }\n    }\n\n    var subscriber = tracking.__subscriberRef.current;\n    if (subscriber !== null) {\n      var threadID = computeThreadID(expirationTime, root.interactionThreadID);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction scheduleWork(fiber, expirationTime) {\n  recordScheduleUpdate();\n\n  {\n    if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {\n      var instance = fiber.stateNode;\n      warnAboutInvalidUpdates(instance);\n    }\n  }\n\n  var root = scheduleWorkToRoot(fiber, expirationTime);\n  if (root === null) {\n    if (\n      true &&\n      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)\n    ) {\n      warnAboutUpdateOnUnmounted(fiber);\n    }\n    return;\n  }\n\n  if (enableSchedulerTracking) {\n    storeInteractionsForExpirationTime(root, expirationTime, true);\n  }\n\n  if (\n    !isWorking &&\n    nextRenderExpirationTime !== NoWork &&\n    expirationTime < nextRenderExpirationTime\n  ) {\n    // This is an interruption. (Used for performance tracking.)\n    interruptedBy = fiber;\n    resetStack();\n  }\n  markPendingPriorityLevel(root, expirationTime);\n  if (\n    // If we're in the render phase, we don't need to schedule this root\n    // for an update, because we'll do it before we exit...\n    !isWorking ||\n    isCommitting$1 ||\n    // ...unless this is a different root than the one we're rendering.\n    nextRoot !== root\n  ) {\n    var rootExpirationTime = root.expirationTime;\n    requestWork(root, rootExpirationTime);\n  }\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    // Reset this back to zero so subsequent updates don't throw.\n    nestedUpdateCount = 0;\n    invariant(\n      false,\n      \"Maximum update depth exceeded. This can happen when a \" +\n        \"component repeatedly calls setState inside \" +\n        \"componentWillUpdate or componentDidUpdate. React limits \" +\n        \"the number of nested updates to prevent infinite loops.\"\n    );\n  }\n}\n\n// TODO: Everything below this is written as if it has been lifted to the\n// renderers. I'll do this in a follow-up.\n\n// Linked-list of roots\nvar firstScheduledRoot = null;\nvar lastScheduledRoot = null;\n\nvar callbackExpirationTime = NoWork;\nvar callbackID = void 0;\nvar isRendering = false;\nvar nextFlushedRoot = null;\nvar nextFlushedExpirationTime = NoWork;\nvar lowestPriorityPendingInteractiveExpirationTime = NoWork;\nvar deadlineDidExpire = false;\nvar hasUnhandledError = false;\nvar unhandledError = null;\nvar deadline = null;\n\nvar isBatchingUpdates = false;\nvar isUnbatchingUpdates = false;\nvar isBatchingInteractiveUpdates = false;\n\nvar completedBatches = null;\n\nvar originalStartTimeMs = now();\nvar currentRendererTime = msToExpirationTime(originalStartTimeMs);\nvar currentSchedulerTime = currentRendererTime;\n\n// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT = 50;\nvar nestedUpdateCount = 0;\nvar lastCommittedRootDuringThisBatch = null;\n\nvar timeHeuristicForUnitOfWork = 1;\n\nfunction recomputeCurrentRendererTime() {\n  var currentTimeMs = now() - originalStartTimeMs;\n  currentRendererTime = msToExpirationTime(currentTimeMs);\n}\n\nfunction scheduleCallbackWithExpirationTime(root, expirationTime) {\n  if (callbackExpirationTime !== NoWork) {\n    // A callback is already scheduled. Check its expiration time (timeout).\n    if (expirationTime > callbackExpirationTime) {\n      // Existing callback has sufficient timeout. Exit.\n      return;\n    } else {\n      if (callbackID !== null) {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n    }\n    // The request callback timer is already running. Don't start a new one.\n  } else {\n    startRequestCallbackTimer();\n  }\n\n  callbackExpirationTime = expirationTime;\n  var currentMs = now() - originalStartTimeMs;\n  var expirationTimeMs = expirationTimeToMs(expirationTime);\n  var timeout = expirationTimeMs - currentMs;\n  callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n}\n\n// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and\n// onYield is called upon exiting. We use these in lieu of returning a tuple.\n// I've also chosen not to inline them into renderRoot because these will\n// eventually be lifted into the renderer.\nfunction onFatal(root) {\n  root.finishedWork = null;\n}\n\nfunction onComplete(root, finishedWork, expirationTime) {\n  root.pendingCommitExpirationTime = expirationTime;\n  root.finishedWork = finishedWork;\n}\n\nfunction onSuspend(\n  root,\n  finishedWork,\n  suspendedExpirationTime,\n  rootExpirationTime,\n  msUntilTimeout\n) {\n  root.expirationTime = rootExpirationTime;\n  if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {\n    // Don't wait an additional tick. Commit the tree immediately.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n  } else if (msUntilTimeout > 0) {\n    // Wait `msUntilTimeout` milliseconds before committing.\n    root.timeoutHandle = scheduleTimeout(\n      onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),\n      msUntilTimeout\n    );\n  }\n}\n\nfunction onYield(root) {\n  root.finishedWork = null;\n}\n\nfunction onTimeout(root, finishedWork, suspendedExpirationTime) {\n  if (enableSuspense) {\n    // The root timed out. Commit it.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n    // Read the current time before entering the commit phase. We can be\n    // certain this won't cause tearing related to batching of event updates\n    // because we're at the top of a timer event.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableSchedulerTracking) {\n      // Don't update pending interaction counts for suspense timeouts,\n      // Because we know we still need to do more work in this case.\n      suspenseDidTimeout = true;\n      flushRoot(root, suspendedExpirationTime);\n      suspenseDidTimeout = false;\n    } else {\n      flushRoot(root, suspendedExpirationTime);\n    }\n  }\n}\n\nfunction onCommit(root, expirationTime) {\n  root.expirationTime = expirationTime;\n  root.finishedWork = null;\n}\n\nfunction requestCurrentTime() {\n  // requestCurrentTime is called by the scheduler to compute an expiration\n  // time.\n  //\n  // Expiration times are computed by adding to the current time (the start\n  // time). However, if two updates are scheduled within the same event, we\n  // should treat their start times as simultaneous, even if the actual clock\n  // time has advanced between the first and second call.\n\n  // In other words, because expiration times determine how updates are batched,\n  // we want all updates of like priority that occur within the same event to\n  // receive the same expiration time. Otherwise we get tearing.\n  //\n  // We keep track of two separate times: the current \"renderer\" time and the\n  // current \"scheduler\" time. The renderer time can be updated whenever; it\n  // only exists to minimize the calls performance.now.\n  //\n  // But the scheduler time can only be updated if there's no pending work, or\n  // if we know for certain that we're not in the middle of an event.\n\n  if (isRendering) {\n    // We're already rendering. Return the most recently read time.\n    return currentSchedulerTime;\n  }\n  // Check if there's pending work.\n  findHighestPriorityRoot();\n  if (\n    nextFlushedExpirationTime === NoWork ||\n    nextFlushedExpirationTime === Never\n  ) {\n    // If there's no pending work, or if the pending work is offscreen, we can\n    // read the current time without risk of tearing.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n    return currentSchedulerTime;\n  }\n  // There's already pending work. We might be in the middle of a browser\n  // event. If we were to read the current time, it could cause multiple updates\n  // within the same event to receive different expiration times, leading to\n  // tearing. Return the last read time. During the next idle callback, the\n  // time will be updated.\n  return currentSchedulerTime;\n}\n\n// requestWork is called by the scheduler whenever a root receives an update.\n// It's up to the renderer to call renderRoot at some point in the future.\nfunction requestWork(root, expirationTime) {\n  addRootToSchedule(root, expirationTime);\n  if (isRendering) {\n    // Prevent reentrancy. Remaining work will be scheduled at the end of\n    // the currently rendering batch.\n    return;\n  }\n\n  if (isBatchingUpdates) {\n    // Flush work at the end of the batch.\n    if (isUnbatchingUpdates) {\n      // ...unless we're inside unbatchedUpdates, in which case we should\n      // flush it now.\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = Sync;\n      performWorkOnRoot(root, Sync, true);\n    }\n    return;\n  }\n\n  // TODO: Get rid of Sync and use current time?\n  if (expirationTime === Sync) {\n    performSyncWork();\n  } else {\n    scheduleCallbackWithExpirationTime(root, expirationTime);\n  }\n}\n\nfunction addRootToSchedule(root, expirationTime) {\n  // Add the root to the schedule.\n  // Check if this root is already part of the schedule.\n  if (root.nextScheduledRoot === null) {\n    // This root is not already scheduled. Add it.\n    root.expirationTime = expirationTime;\n    if (lastScheduledRoot === null) {\n      firstScheduledRoot = lastScheduledRoot = root;\n      root.nextScheduledRoot = root;\n    } else {\n      lastScheduledRoot.nextScheduledRoot = root;\n      lastScheduledRoot = root;\n      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n    }\n  } else {\n    // This root is already scheduled, but its priority may have increased.\n    var remainingExpirationTime = root.expirationTime;\n    if (\n      remainingExpirationTime === NoWork ||\n      expirationTime < remainingExpirationTime\n    ) {\n      // Update the priority.\n      root.expirationTime = expirationTime;\n    }\n  }\n}\n\nfunction findHighestPriorityRoot() {\n  var highestPriorityWork = NoWork;\n  var highestPriorityRoot = null;\n  if (lastScheduledRoot !== null) {\n    var previousScheduledRoot = lastScheduledRoot;\n    var root = firstScheduledRoot;\n    while (root !== null) {\n      var remainingExpirationTime = root.expirationTime;\n      if (remainingExpirationTime === NoWork) {\n        // This root no longer has work. Remove it from the scheduler.\n\n        // TODO: This check is redudant, but Flow is confused by the branch\n        // below where we set lastScheduledRoot to null, even though we break\n        // from the loop right after.\n        invariant(\n          previousScheduledRoot !== null && lastScheduledRoot !== null,\n          \"Should have a previous and last root. This error is likely \" +\n            \"caused by a bug in React. Please file an issue.\"\n        );\n        if (root === root.nextScheduledRoot) {\n          // This is the only root in the list.\n          root.nextScheduledRoot = null;\n          firstScheduledRoot = lastScheduledRoot = null;\n          break;\n        } else if (root === firstScheduledRoot) {\n          // This is the first root in the list.\n          var next = root.nextScheduledRoot;\n          firstScheduledRoot = next;\n          lastScheduledRoot.nextScheduledRoot = next;\n          root.nextScheduledRoot = null;\n        } else if (root === lastScheduledRoot) {\n          // This is the last root in the list.\n          lastScheduledRoot = previousScheduledRoot;\n          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          root.nextScheduledRoot = null;\n          break;\n        } else {\n          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n          root.nextScheduledRoot = null;\n        }\n        root = previousScheduledRoot.nextScheduledRoot;\n      } else {\n        if (\n          highestPriorityWork === NoWork ||\n          remainingExpirationTime < highestPriorityWork\n        ) {\n          // Update the priority, if it's higher\n          highestPriorityWork = remainingExpirationTime;\n          highestPriorityRoot = root;\n        }\n        if (root === lastScheduledRoot) {\n          break;\n        }\n        if (highestPriorityWork === Sync) {\n          // Sync is highest priority by definition so\n          // we can stop searching.\n          break;\n        }\n        previousScheduledRoot = root;\n        root = root.nextScheduledRoot;\n      }\n    }\n  }\n\n  nextFlushedRoot = highestPriorityRoot;\n  nextFlushedExpirationTime = highestPriorityWork;\n}\n\nfunction performAsyncWork(dl) {\n  if (dl.didTimeout) {\n    // The callback timed out. That means at least one update has expired.\n    // Iterate through the root schedule. If they contain expired work, set\n    // the next render expiration time to the current time. This has the effect\n    // of flushing all expired work in a single batch, instead of flushing each\n    // level one at a time.\n    if (firstScheduledRoot !== null) {\n      recomputeCurrentRendererTime();\n      var root = firstScheduledRoot;\n      do {\n        didExpireAtExpirationTime(root, currentRendererTime);\n        // The root schedule is circular, so this is never null.\n        root = root.nextScheduledRoot;\n      } while (root !== firstScheduledRoot);\n    }\n  }\n  performWork(NoWork, dl);\n}\n\nfunction performSyncWork() {\n  performWork(Sync, null);\n}\n\nfunction performWork(minExpirationTime, dl) {\n  deadline = dl;\n\n  // Keep working on roots until there's no more work, or until we reach\n  // the deadline.\n  findHighestPriorityRoot();\n\n  if (deadline !== null) {\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableUserTimingAPI) {\n      var didExpire = nextFlushedExpirationTime < currentRendererTime;\n      var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n      stopRequestCallbackTimer(didExpire, timeout);\n    }\n\n    while (\n      nextFlushedRoot !== null &&\n      nextFlushedExpirationTime !== NoWork &&\n      (minExpirationTime === NoWork ||\n        minExpirationTime >= nextFlushedExpirationTime) &&\n      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)\n    ) {\n      performWorkOnRoot(\n        nextFlushedRoot,\n        nextFlushedExpirationTime,\n        currentRendererTime >= nextFlushedExpirationTime\n      );\n      findHighestPriorityRoot();\n      recomputeCurrentRendererTime();\n      currentSchedulerTime = currentRendererTime;\n    }\n  } else {\n    while (\n      nextFlushedRoot !== null &&\n      nextFlushedExpirationTime !== NoWork &&\n      (minExpirationTime === NoWork ||\n        minExpirationTime >= nextFlushedExpirationTime)\n    ) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);\n      findHighestPriorityRoot();\n    }\n  }\n\n  // We're done flushing work. Either we ran out of time in this callback,\n  // or there's no more work left with sufficient priority.\n\n  // If we're inside a callback, set this to false since we just completed it.\n  if (deadline !== null) {\n    callbackExpirationTime = NoWork;\n    callbackID = null;\n  }\n  // If there's work left over, schedule a new callback.\n  if (nextFlushedExpirationTime !== NoWork) {\n    scheduleCallbackWithExpirationTime(\n      nextFlushedRoot,\n      nextFlushedExpirationTime\n    );\n  }\n\n  // Clean-up.\n  deadline = null;\n  deadlineDidExpire = false;\n\n  finishRendering();\n}\n\nfunction flushRoot(root, expirationTime) {\n  invariant(\n    !isRendering,\n    \"work.commit(): Cannot commit while already rendering. This likely \" +\n      \"means you attempted to commit from inside a lifecycle method.\"\n  );\n  // Perform work on root as if the given expiration time is the current time.\n  // This has the effect of synchronously flushing all work up to and\n  // including the given time.\n  nextFlushedRoot = root;\n  nextFlushedExpirationTime = expirationTime;\n  performWorkOnRoot(root, expirationTime, true);\n  // Flush any sync work that was scheduled by lifecycles\n  performSyncWork();\n}\n\nfunction finishRendering() {\n  nestedUpdateCount = 0;\n  lastCommittedRootDuringThisBatch = null;\n\n  if (completedBatches !== null) {\n    var batches = completedBatches;\n    completedBatches = null;\n    for (var i = 0; i < batches.length; i++) {\n      var batch = batches[i];\n      try {\n        batch._onComplete();\n      } catch (error) {\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      }\n    }\n  }\n\n  if (hasUnhandledError) {\n    var error = unhandledError;\n    unhandledError = null;\n    hasUnhandledError = false;\n    throw error;\n  }\n}\n\nfunction performWorkOnRoot(root, expirationTime, isExpired) {\n  invariant(\n    !isRendering,\n    \"performWorkOnRoot was called recursively. This error is likely caused \" +\n      \"by a bug in React. Please file an issue.\"\n  );\n\n  isRendering = true;\n\n  // Check if this is async work or sync/expired work.\n  if (deadline === null || isExpired) {\n    // Flush work without yielding.\n    // TODO: Non-yieldy work does not necessarily imply expired work. A renderer\n    // may want to perform some work without yielding, but also without\n    // requiring the root to complete (by triggering placeholders).\n\n    var finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      var timeoutHandle = root.timeoutHandle;\n      if (enableSuspense && timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(timeoutHandle);\n      }\n      var isYieldy = false;\n      renderRoot(root, isYieldy, isExpired);\n      finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // We've completed the root. Commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  } else {\n    // Flush async work.\n    var _finishedWork = root.finishedWork;\n    if (_finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, _finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      var _timeoutHandle = root.timeoutHandle;\n      if (enableSuspense && _timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(_timeoutHandle);\n      }\n      var _isYieldy = true;\n      renderRoot(root, _isYieldy, isExpired);\n      _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // We've completed the root. Check the deadline one more time\n        // before committing.\n        if (!shouldYield()) {\n          // Still time left. Commit the root.\n          completeRoot(root, _finishedWork, expirationTime);\n        } else {\n          // There's no time left. Mark this root as complete. We'll come\n          // back and commit it later.\n          root.finishedWork = _finishedWork;\n        }\n      }\n    }\n  }\n\n  isRendering = false;\n}\n\nfunction completeRoot(root, finishedWork, expirationTime) {\n  // Check if there's a batch that matches this expiration time.\n  var firstBatch = root.firstBatch;\n  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n    if (completedBatches === null) {\n      completedBatches = [firstBatch];\n    } else {\n      completedBatches.push(firstBatch);\n    }\n    if (firstBatch._defer) {\n      // This root is blocked from committing by a batch. Unschedule it until\n      // we receive another update.\n      root.finishedWork = finishedWork;\n      root.expirationTime = NoWork;\n      return;\n    }\n  }\n\n  // Commit the root.\n  root.finishedWork = null;\n\n  // Check if this is a nested update (a sync update scheduled during the\n  // commit phase).\n  if (root === lastCommittedRootDuringThisBatch) {\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    nestedUpdateCount++;\n  } else {\n    // Reset whenever we switch roots.\n    lastCommittedRootDuringThisBatch = root;\n    nestedUpdateCount = 0;\n  }\n  commitRoot(root, finishedWork);\n}\n\n// When working on async work, the reconciler asks the renderer if it should\n// yield execution. For DOM, we implement this with requestIdleCallback.\nfunction shouldYield() {\n  if (deadlineDidExpire) {\n    return true;\n  }\n  if (\n    deadline === null ||\n    deadline.timeRemaining() > timeHeuristicForUnitOfWork\n  ) {\n    // Disregard deadline.didTimeout. Only expired work should be flushed\n    // during a timeout. This path is only hit for non-expired work.\n    return false;\n  }\n  deadlineDidExpire = true;\n  return true;\n}\n\nfunction onUncaughtError(error) {\n  invariant(\n    nextFlushedRoot !== null,\n    \"Should be working on a root. This error is likely caused by a bug in \" +\n      \"React. Please file an issue.\"\n  );\n  // Unschedule this root so we don't work on it again until there's\n  // another update.\n  nextFlushedRoot.expirationTime = NoWork;\n  if (!hasUnhandledError) {\n    hasUnhandledError = true;\n    unhandledError = error;\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction batchedUpdates$1(fn, a) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return fn(a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction interactiveUpdates$1(fn, a, b) {\n  if (isBatchingInteractiveUpdates) {\n    return fn(a, b);\n  }\n  // If there are any pending interactive updates, synchronously flush them.\n  // This needs to happen before we read any handlers, because the effect of\n  // the previous event may influence which handlers are called during\n  // this event.\n  if (\n    !isBatchingUpdates &&\n    !isRendering &&\n    lowestPriorityPendingInteractiveExpirationTime !== NoWork\n  ) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingInteractiveUpdates = true;\n  isBatchingUpdates = true;\n  try {\n    return fn(a, b);\n  } finally {\n    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction flushInteractiveUpdates$1() {\n  if (\n    !isRendering &&\n    lowestPriorityPendingInteractiveExpirationTime !== NoWork\n  ) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  var fiber = get$1(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    var Component = fiber.type;\n    if (isContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  } else if (fiber.tag === ClassComponentLazy) {\n    var _Component = getResultFromResolvedThenable(fiber.type);\n    if (isContextProvider(_Component)) {\n      return processChildContext(fiber, _Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction scheduleRootUpdate(current$$1, element, expirationTime, callback) {\n  {\n    if (phase === \"render\" && current !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      warningWithoutStack$1(\n        false,\n        \"Render methods should be a pure function of props and state; \" +\n          \"triggering nested component updates from render is not allowed. \" +\n          \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" +\n          \"Check the render method of %s.\",\n        getComponentName(current.type) || \"Unknown\"\n      );\n    }\n  }\n\n  var update = createUpdate(expirationTime);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: element };\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    !(typeof callback === \"function\")\n      ? warningWithoutStack$1(\n          false,\n          \"render(...): Expected the last optional `callback` argument to be a \" +\n            \"function. Instead received: %s.\",\n          callback\n        )\n      : void 0;\n    update.callback = callback;\n  }\n  enqueueUpdate(current$$1, update);\n\n  scheduleWork(current$$1, expirationTime);\n  return expirationTime;\n}\n\nfunction updateContainerAtExpirationTime(\n  element,\n  container,\n  parentComponent,\n  expirationTime,\n  callback\n) {\n  // TODO: If this is a nested container, this won't be the root.\n  var current$$1 = container.current;\n\n  {\n    if (ReactFiberInstrumentation_1.debugTool) {\n      if (current$$1.alternate === null) {\n        ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n\n  var context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  return scheduleRootUpdate(current$$1, element, expirationTime, callback);\n}\n\nfunction findHostInstance$1(component) {\n  var fiber = get$1(component);\n  if (fiber === undefined) {\n    if (typeof component.render === \"function\") {\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    } else {\n      invariant(\n        false,\n        \"Argument appears to not be a ReactComponent. Keys: %s\",\n        Object.keys(component)\n      );\n    }\n  }\n  var hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction createContainer(containerInfo, isAsync, hydrate) {\n  return createFiberRoot(containerInfo, isAsync, hydrate);\n}\n\nfunction updateContainer(element, container, parentComponent, callback) {\n  var current$$1 = container.current;\n  var currentTime = requestCurrentTime();\n  var expirationTime = computeExpirationForFiber(currentTime, current$$1);\n  return updateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    expirationTime,\n    callback\n  );\n}\n\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n  return injectInternals(\n    Object.assign({}, devToolsConfig, {\n      findHostInstanceByFiber: function(fiber) {\n        var hostFiber = findCurrentHostFiber(fiber);\n        if (hostFiber === null) {\n          return null;\n        }\n        return hostFiber.stateNode;\n      },\n      findFiberByHostInstance: function(instance) {\n        if (!findFiberByHostInstance) {\n          // Might not be implemented by the renderer.\n          return null;\n        }\n        return findFiberByHostInstance(instance);\n      }\n    })\n  );\n}\n\n// This file intentionally does *not* have the Flow annotation.\n// Don't add it. See `./inline-typed.js` for an explanation.\n\nfunction createPortal(\n  children,\n  containerInfo,\n  // TODO: figure out the API for cross-renderer implementation.\n  implementation\n) {\n  var key =\n    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : \"\" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = \"16.5.0\";\n\n// Modules provided by RN:\nvar NativeMethodsMixin = function(findNodeHandle, findHostInstance) {\n  /**\n   * `NativeMethodsMixin` provides methods to access the underlying native\n   * component directly. This can be useful in cases when you want to focus\n   * a view or measure its on-screen dimensions, for example.\n   *\n   * The methods described here are available on most of the default components\n   * provided by React Native. Note, however, that they are *not* available on\n   * composite components that aren't directly backed by a native view. This will\n   * generally include most components that you define in your own app. For more\n   * information, see [Direct\n   * Manipulation](docs/direct-manipulation.html).\n   *\n   * Note the Flow $Exact<> syntax is required to support mixins.\n   * React createClass mixins can only be used with exact types.\n   */\n  var NativeMethodsMixin = {\n    /**\n     * Determines the location on screen, width, and height of the given view and\n     * returns the values via an async callback. If successful, the callback will\n     * be called with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *  - pageX\n     *  - pageY\n     *\n     * Note that these measurements are not available until after the rendering\n     * has been completed in native. If you need the measurements as soon as\n     * possible, consider using the [`onLayout`\n     * prop](docs/view.html#onlayout) instead.\n     */\n    measure: function(callback) {\n      UIManager.measure(\n        findNodeHandle(this),\n        mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n      );\n    },\n\n    /**\n     * Determines the location of the given view in the window and returns the\n     * values via an async callback. If the React root view is embedded in\n     * another native view, this will give you the absolute coordinates. If\n     * successful, the callback will be called with the following\n     * arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *\n     * Note that these measurements are not available until after the rendering\n     * has been completed in native.\n     */\n    measureInWindow: function(callback) {\n      UIManager.measureInWindow(\n        findNodeHandle(this),\n        mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n      );\n    },\n\n    /**\n     * Like [`measure()`](#measure), but measures the view relative an ancestor,\n     * specified as `relativeToNativeNode`. This means that the returned x, y\n     * are relative to the origin x, y of the ancestor view.\n     *\n     * As always, to obtain a native node handle for a component, you can use\n     * `findNodeHandle(component)`.\n     */\n    measureLayout: function(\n      relativeToNativeNode,\n      onSuccess,\n      onFail /* currently unused */\n    ) {\n      UIManager.measureLayout(\n        findNodeHandle(this),\n        relativeToNativeNode,\n        mountSafeCallback_NOT_REALLY_SAFE(this, onFail),\n        mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess)\n      );\n    },\n\n    /**\n     * This function sends props straight to native. They will not participate in\n     * future diff process - this means that if you do not include them in the\n     * next render, they will remain active (see [Direct\n     * Manipulation](docs/direct-manipulation.html)).\n     */\n    setNativeProps: function(nativeProps) {\n      // Class components don't have viewConfig -> validateAttributes.\n      // Nor does it make sense to set native props on a non-native component.\n      // Instead, find the nearest host component and set props on it.\n      // Use findNodeHandle() rather than findNodeHandle() because\n      // We want the instance/wrapper (not the native tag).\n      var maybeInstance = void 0;\n\n      // Fiber errors if findNodeHandle is called for an umounted component.\n      // Tests using ReactTestRenderer will trigger this case indirectly.\n      // Mimicking stack behavior, we should silently ignore this case.\n      // TODO Fix ReactTestRenderer so we can remove this try/catch.\n      try {\n        maybeInstance = findHostInstance(this);\n      } catch (error) {}\n\n      // If there is no host component beneath this we should fail silently.\n      // This is not an error; it could mean a class component rendered null.\n      if (maybeInstance == null) {\n        return;\n      }\n\n      var viewConfig = maybeInstance.viewConfig;\n\n      {\n        warnForStyleProps(nativeProps, viewConfig.validAttributes);\n      }\n\n      var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          maybeInstance._nativeTag,\n          viewConfig.uiViewClassName,\n          updatePayload\n        );\n      }\n    },\n\n    /**\n     * Requests focus for the given input or view. The exact behavior triggered\n     * will depend on the platform and type of view.\n     */\n    focus: function() {\n      TextInputState.focusTextInput(findNodeHandle(this));\n    },\n\n    /**\n     * Removes focus from an input or view. This is the opposite of `focus()`.\n     */\n    blur: function() {\n      TextInputState.blurTextInput(findNodeHandle(this));\n    }\n  };\n\n  {\n    // hide this from Flow since we can't define these properties outside of\n    // true without actually implementing them (setting them to undefined\n    // isn't allowed by ReactClass)\n    var NativeMethodsMixin_DEV = NativeMethodsMixin;\n    invariant(\n      !NativeMethodsMixin_DEV.componentWillMount &&\n        !NativeMethodsMixin_DEV.componentWillReceiveProps &&\n        !NativeMethodsMixin_DEV.UNSAFE_componentWillMount &&\n        !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps,\n      \"Do not override existing functions.\"\n    );\n    // TODO (bvaughn) Remove cWM and cWRP in a future version of React Native,\n    // Once these lifecycles have been remove from the reconciler.\n    NativeMethodsMixin_DEV.componentWillMount = function() {\n      throwOnStylesProp(this, this.props);\n    };\n    NativeMethodsMixin_DEV.componentWillReceiveProps = function(newProps) {\n      throwOnStylesProp(this, newProps);\n    };\n    NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function() {\n      throwOnStylesProp(this, this.props);\n    };\n    NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function(\n      newProps\n    ) {\n      throwOnStylesProp(this, newProps);\n    };\n\n    // React may warn about cWM/cWRP/cWU methods being deprecated.\n    // Add a flag to suppress these warnings for this special case.\n    // TODO (bvaughn) Remove this flag once the above methods have been removed.\n    NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;\n    NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;\n  }\n\n  return NativeMethodsMixin;\n};\n\nfunction _classCallCheck$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\n      \"this hasn't been initialised - super() hasn't been called\"\n    );\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\")\n    ? call\n    : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\n      \"Super expression must either be null or a function, not \" +\n        typeof superClass\n    );\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\n// Modules provided by RN:\nvar ReactNativeComponent = function(findNodeHandle, findHostInstance) {\n  /**\n   * Superclass that provides methods to access the underlying native component.\n   * This can be useful when you want to focus a view or measure its dimensions.\n   *\n   * Methods implemented by this class are available on most default components\n   * provided by React Native. However, they are *not* available on composite\n   * components that are not directly backed by a native view. For more\n   * information, see [Direct Manipulation](docs/direct-manipulation.html).\n   *\n   * @abstract\n   */\n  var ReactNativeComponent = (function(_React$Component) {\n    _inherits(ReactNativeComponent, _React$Component);\n\n    function ReactNativeComponent() {\n      _classCallCheck$1(this, ReactNativeComponent);\n\n      return _possibleConstructorReturn(\n        this,\n        _React$Component.apply(this, arguments)\n      );\n    }\n\n    /**\n     * Removes focus. This is the opposite of `focus()`.\n     */\n\n    /**\n     * Due to bugs in Flow's handling of React.createClass, some fields already\n     * declared in the base class need to be redeclared below.\n     */\n    ReactNativeComponent.prototype.blur = function blur() {\n      TextInputState.blurTextInput(findNodeHandle(this));\n    };\n\n    /**\n     * Requests focus. The exact behavior depends on the platform and view.\n     */\n\n    ReactNativeComponent.prototype.focus = function focus() {\n      TextInputState.focusTextInput(findNodeHandle(this));\n    };\n\n    /**\n     * Measures the on-screen location and dimensions. If successful, the callback\n     * will be called asynchronously with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *  - pageX\n     *  - pageY\n     *\n     * These values are not available until after natives rendering completes. If\n     * you need the measurements as soon as possible, consider using the\n     * [`onLayout` prop](docs/view.html#onlayout) instead.\n     */\n\n    ReactNativeComponent.prototype.measure = function measure(callback) {\n      UIManager.measure(\n        findNodeHandle(this),\n        mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n      );\n    };\n\n    /**\n     * Measures the on-screen location and dimensions. Even if the React Native\n     * root view is embedded within another native view, this method will give you\n     * the absolute coordinates measured from the window. If successful, the\n     * callback will be called asynchronously with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *\n     * These values are not available until after natives rendering completes.\n     */\n\n    ReactNativeComponent.prototype.measureInWindow = function measureInWindow(\n      callback\n    ) {\n      UIManager.measureInWindow(\n        findNodeHandle(this),\n        mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n      );\n    };\n\n    /**\n     * Similar to [`measure()`](#measure), but the resulting location will be\n     * relative to the supplied ancestor's location.\n     *\n     * Obtain a native node handle with `ReactNative.findNodeHandle(component)`.\n     */\n\n    ReactNativeComponent.prototype.measureLayout = function measureLayout(\n      relativeToNativeNode,\n      onSuccess,\n      onFail /* currently unused */\n    ) {\n      UIManager.measureLayout(\n        findNodeHandle(this),\n        relativeToNativeNode,\n        mountSafeCallback_NOT_REALLY_SAFE(this, onFail),\n        mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess)\n      );\n    };\n\n    /**\n     * This function sends props straight to native. They will not participate in\n     * future diff process - this means that if you do not include them in the\n     * next render, they will remain active (see [Direct\n     * Manipulation](docs/direct-manipulation.html)).\n     */\n\n    ReactNativeComponent.prototype.setNativeProps = function setNativeProps(\n      nativeProps\n    ) {\n      // Class components don't have viewConfig -> validateAttributes.\n      // Nor does it make sense to set native props on a non-native component.\n      // Instead, find the nearest host component and set props on it.\n      // Use findNodeHandle() rather than ReactNative.findNodeHandle() because\n      // We want the instance/wrapper (not the native tag).\n      var maybeInstance = void 0;\n\n      // Fiber errors if findNodeHandle is called for an umounted component.\n      // Tests using ReactTestRenderer will trigger this case indirectly.\n      // Mimicking stack behavior, we should silently ignore this case.\n      // TODO Fix ReactTestRenderer so we can remove this try/catch.\n      try {\n        maybeInstance = findHostInstance(this);\n      } catch (error) {}\n\n      // If there is no host component beneath this we should fail silently.\n      // This is not an error; it could mean a class component rendered null.\n      if (maybeInstance == null) {\n        return;\n      }\n\n      var viewConfig =\n        maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;\n\n      var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          maybeInstance._nativeTag,\n          viewConfig.uiViewClassName,\n          updatePayload\n        );\n      }\n    };\n\n    return ReactNativeComponent;\n  })(React.Component);\n\n  // eslint-disable-next-line no-unused-expressions\n\n  return ReactNativeComponent;\n};\n\n// Module provided by RN:\nvar emptyObject$2 = {};\n{\n  Object.freeze(emptyObject$2);\n}\n\nvar getInspectorDataForViewTag = void 0;\n\n{\n  var traverseOwnerTreeUp = function(hierarchy, instance) {\n    if (instance) {\n      hierarchy.unshift(instance);\n      traverseOwnerTreeUp(hierarchy, instance._debugOwner);\n    }\n  };\n\n  var getOwnerHierarchy = function(instance) {\n    var hierarchy = [];\n    traverseOwnerTreeUp(hierarchy, instance);\n    return hierarchy;\n  };\n\n  var lastNonHostInstance = function(hierarchy) {\n    for (var i = hierarchy.length - 1; i > 1; i--) {\n      var instance = hierarchy[i];\n\n      if (instance.tag !== HostComponent) {\n        return instance;\n      }\n    }\n    return hierarchy[0];\n  };\n\n  var getHostProps = function(fiber) {\n    var host = findCurrentHostFiber(fiber);\n    if (host) {\n      return host.memoizedProps || emptyObject$2;\n    }\n    return emptyObject$2;\n  };\n\n  var getHostNode = function(fiber, findNodeHandle) {\n    var hostNode = void 0;\n    // look for children first for the hostNode\n    // as composite fibers do not have a hostNode\n    while (fiber) {\n      if (fiber.stateNode !== null && fiber.tag === HostComponent) {\n        hostNode = findNodeHandle(fiber.stateNode);\n      }\n      if (hostNode) {\n        return hostNode;\n      }\n      fiber = fiber.child;\n    }\n    return null;\n  };\n\n  var createHierarchy = function(fiberHierarchy) {\n    return fiberHierarchy.map(function(fiber) {\n      return {\n        name: getComponentName(fiber.type),\n        getInspectorData: function(findNodeHandle) {\n          return {\n            measure: function(callback) {\n              return UIManager.measure(\n                getHostNode(fiber, findNodeHandle),\n                callback\n              );\n            },\n            props: getHostProps(fiber),\n            source: fiber._debugSource\n          };\n        }\n      };\n    });\n  };\n\n  getInspectorDataForViewTag = function(viewTag) {\n    var closestInstance = getInstanceFromTag(viewTag);\n\n    // Handle case where user clicks outside of ReactNative\n    if (!closestInstance) {\n      return {\n        hierarchy: [],\n        props: emptyObject$2,\n        selection: null,\n        source: null\n      };\n    }\n\n    var fiber = findCurrentFiberUsingSlowPath(closestInstance);\n    var fiberHierarchy = getOwnerHierarchy(fiber);\n    var instance = lastNonHostInstance(fiberHierarchy);\n    var hierarchy = createHierarchy(fiberHierarchy);\n    var props = getHostProps(instance);\n    var source = instance._debugSource;\n    var selection = fiberHierarchy.indexOf(instance);\n\n    return {\n      hierarchy: hierarchy,\n      props: props,\n      selection: selection,\n      source: source\n    };\n  };\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\n// Module provided by RN:\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar findHostInstance = findHostInstance$1;\n\nfunction findNodeHandle(componentOrHandle) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.stateNode !== null) {\n      !owner.stateNode._warnedAboutRefsInRender\n        ? warningWithoutStack$1(\n            false,\n            \"%s is accessing findNodeHandle inside its render(). \" +\n              \"render() should be a pure function of props and state. It should \" +\n              \"never access something that requires stale data from the previous \" +\n              \"render, such as refs. Move this logic to componentDidMount and \" +\n              \"componentDidUpdate instead.\",\n            getComponentName(owner.type) || \"A component\"\n          )\n        : void 0;\n\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrHandle == null) {\n    return null;\n  }\n  if (typeof componentOrHandle === \"number\") {\n    // Already a node handle\n    return componentOrHandle;\n  }\n  if (componentOrHandle._nativeTag) {\n    return componentOrHandle._nativeTag;\n  }\n  if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {\n    return componentOrHandle.canonical._nativeTag;\n  }\n  var hostInstance = findHostInstance(componentOrHandle);\n  if (hostInstance == null) {\n    return hostInstance;\n  }\n  if (hostInstance.canonical) {\n    // Fabric\n    return hostInstance.canonical._nativeTag;\n  }\n  return hostInstance._nativeTag;\n}\n\nsetBatchingImplementation(\n  batchedUpdates$1,\n  interactiveUpdates$1,\n  flushInteractiveUpdates$1\n);\n\nfunction computeComponentStackForErrorReporting(reactTag) {\n  var fiber = getInstanceFromTag(reactTag);\n  if (!fiber) {\n    return \"\";\n  }\n  return getStackByFiberInDevAndProd(fiber);\n}\n\nvar roots = new Map();\n\nvar ReactNativeRenderer = {\n  NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),\n\n  findNodeHandle: findNodeHandle,\n\n  render: function(element, containerTag, callback) {\n    var root = roots.get(containerTag);\n\n    if (!root) {\n      // TODO (bvaughn): If we decide to keep the wrapper component,\n      // We could create a wrapper for containerTag as well to reduce special casing.\n      root = createContainer(containerTag, false, false);\n      roots.set(containerTag, root);\n    }\n    updateContainer(element, root, null, callback);\n\n    return getPublicRootInstance(root);\n  },\n  unmountComponentAtNode: function(containerTag) {\n    var root = roots.get(containerTag);\n    if (root) {\n      // TODO: Is it safe to reset this now or should I wait since this unmount could be deferred?\n      updateContainer(null, root, null, function() {\n        roots.delete(containerTag);\n      });\n    }\n  },\n  unmountComponentAtNodeAndRemoveContainer: function(containerTag) {\n    ReactNativeRenderer.unmountComponentAtNode(containerTag);\n\n    // Call back into native to remove all of the subviews from this container\n    UIManager.removeRootView(containerTag);\n  },\n  createPortal: function(children, containerTag) {\n    var key =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    return createPortal(children, containerTag, null, key);\n  },\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // Used as a mixin in many createClass-based components\n    NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance),\n    computeComponentStackForErrorReporting: computeComponentStackForErrorReporting\n  }\n};\n\ninjectIntoDevTools({\n  findFiberByHostInstance: getInstanceFromTag,\n  getInspectorDataForViewTag: getInspectorDataForViewTag,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: \"react-native-renderer\"\n});\n\nvar ReactNativeRenderer$2 = Object.freeze({\n  default: ReactNativeRenderer\n});\n\nvar ReactNativeRenderer$3 =\n  (ReactNativeRenderer$2 && ReactNativeRenderer) || ReactNativeRenderer$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactNativeRenderer =\n  ReactNativeRenderer$3.default || ReactNativeRenderer$3;\n\nmodule.exports = reactNativeRenderer;\n\n  })();\n}\n"]}