43cb4ede8972fb5dd8b83653e14aa4a9













'use strict';var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}

var _shouldPolyfillES6Collection = require('_shouldPolyfillES6Collection');
var guid = require('guid');
var isNode = require('fbjs/lib/isNode');
var toIterator = require('toIterator');

module.exports = function (global, undefined) {




  if (!_shouldPolyfillES6Collection('Map')) {
    return global.Map;
  }
























































  var KIND_KEY = 'key';
  var KIND_VALUE = 'value';
  var KIND_KEY_VALUE = 'key+value';



  var KEY_PREFIX = '$map_';



  var SECRET_SIZE_PROP = void 0;
  if (__DEV__) {
    SECRET_SIZE_PROP = '$size' + guid();
  }


  var OLD_IE_HASH_PREFIX = 'IE_HASH_';var

  Map = function () {









    function Map(iterable) {_classCallCheck(this, Map);
      if (!isObject(this)) {
        throw new TypeError('Wrong map object type.');
      }

      initMap(this);

      if (iterable != null) {
        var it = toIterator(iterable);
        var next = void 0;
        while (!(next = it.next()).done) {
          if (!isObject(next.value)) {
            throw new TypeError('Expected iterable items to be pair objects.');
          }
          this.set(next.value[0], next.value[1]);
        }
      }
    }_createClass(Map, [{ key: 'clear', value: function clear()





      {
        initMap(this);
      } }, { key: 'has', value: function has(








      key) {
        var index = getIndex(this, key);
        return !!(index != null && this._mapData[index]);
      } }, { key: 'set', value: function set(









      key, value) {
        var index = getIndex(this, key);

        if (index != null && this._mapData[index]) {
          this._mapData[index][1] = value;
        } else {
          index = this._mapData.push([key, value]) - 1;
          setIndex(this, key, index);
          if (__DEV__) {
            this[SECRET_SIZE_PROP] += 1;
          } else {
            this.size += 1;
          }
        }

        return this;
      } }, { key: 'get', value: function get(








      key) {
        var index = getIndex(this, key);
        if (index == null) {
          return undefined;
        } else {
          return this._mapData[index][1];
        }
      } }, { key: 'delete', value: function _delete(








      key) {
        var index = getIndex(this, key);
        if (index != null && this._mapData[index]) {
          setIndex(this, key, undefined);
          this._mapData[index] = undefined;
          if (__DEV__) {
            this[SECRET_SIZE_PROP] -= 1;
          } else {
            this.size -= 1;
          }
          return true;
        } else {
          return false;
        }
      } }, { key: 'entries', value: function entries()








      {
        return new MapIterator(this, KIND_KEY_VALUE);
      } }, { key: 'keys', value: function keys()







      {
        return new MapIterator(this, KIND_KEY);
      } }, { key: 'values', value: function values()







      {
        return new MapIterator(this, KIND_VALUE);
      } }, { key: 'forEach', value: function forEach(










      callback, thisArg) {
        if (typeof callback !== 'function') {
          throw new TypeError('Callback must be callable.');
        }

        var boundCallback = callback.bind(thisArg || undefined);
        var mapData = this._mapData;




        for (var i = 0; i < mapData.length; i++) {
          var entry = mapData[i];
          if (entry != null) {
            boundCallback(entry[1], entry[0], this);
          }
        }
      } }]);return Map;}();



  Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;var

  MapIterator = function () {








    function MapIterator(map, kind) {_classCallCheck(this, MapIterator);
      if (!(isObject(map) && map._mapData)) {
        throw new TypeError('Object is not a map.');
      }

      if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {
        throw new Error('Invalid iteration kind.');
      }

      this._map = map;
      this._nextIndex = 0;
      this._kind = kind;
    }_createClass(MapIterator, [{ key: 'next', value: function next()







      {
        if (!this instanceof Map) {
          throw new TypeError('Expected to be called on a MapIterator.');
        }

        var map = this._map;
        var index = this._nextIndex;
        var kind = this._kind;

        if (map == null) {
          return createIterResultObject(undefined, true);
        }

        var entries = map._mapData;

        while (index < entries.length) {
          var record = entries[index];

          index += 1;
          this._nextIndex = index;

          if (record) {
            if (kind === KIND_KEY) {
              return createIterResultObject(record[0], false);
            } else if (kind === KIND_VALUE) {
              return createIterResultObject(record[1], false);
            } else if (kind) {
              return createIterResultObject(record, false);
            }
          }
        }

        this._map = undefined;

        return createIterResultObject(undefined, true);
      } }]);return MapIterator;}();





  MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function () {
    return this;
  };












  function getIndex(map, key) {
    if (isObject(key)) {
      var hash = getHash(key);
      return map._objectIndex[hash];
    } else {
      var prefixedKey = KEY_PREFIX + key;
      if (typeof key === 'string') {
        return map._stringIndex[prefixedKey];
      } else {
        return map._otherIndex[prefixedKey];
      }
    }
  }







  function setIndex(map, key, index) {
    var shouldDelete = index == null;

    if (isObject(key)) {
      var hash = getHash(key);
      if (shouldDelete) {
        delete map._objectIndex[hash];
      } else {
        map._objectIndex[hash] = index;
      }
    } else {
      var prefixedKey = KEY_PREFIX + key;
      if (typeof key === 'string') {
        if (shouldDelete) {
          delete map._stringIndex[prefixedKey];
        } else {
          map._stringIndex[prefixedKey] = index;
        }
      } else {
        if (shouldDelete) {
          delete map._otherIndex[prefixedKey];
        } else {
          map._otherIndex[prefixedKey] = index;
        }
      }
    }
  }






  function initMap(map) {






    map._mapData = [];







    map._objectIndex = {};


    map._stringIndex = {};


    map._otherIndex = {};







    if (__DEV__) {
      if (isES5) {



        if (map.hasOwnProperty(SECRET_SIZE_PROP)) {
          map[SECRET_SIZE_PROP] = 0;
        } else {
          Object.defineProperty(map, SECRET_SIZE_PROP, {
            value: 0,
            writable: true });

          Object.defineProperty(map, 'size', {
            set: function set(v) {
              console.error(
              'PLEASE FIX ME: You are changing the map size property which ' +
              'should not be writable and will break in production.');

              throw new Error('The map size property is not writable.');
            },
            get: function get() {return map[SECRET_SIZE_PROP];} });

        }


        return;
      }
    }



    map.size = 0;
  }







  function isObject(o) {
    return o != null && (typeof o === 'object' || typeof o === 'function');
  }








  function createIterResultObject(value, done) {
    return { value: value, done: done };
  }


  var isES5 = function () {
    try {
      Object.defineProperty({}, 'x', {});
      return true;
    } catch (e) {
      return false;
    }
  }();







  function isExtensible(o) {
    if (!isES5) {
      return true;
    } else {
      return Object.isExtensible(o);
    }
  }









  function getIENodeHash(node) {
    var uniqueID = void 0;
    switch (node.nodeType) {
      case 1:
        uniqueID = node.uniqueID;
        break;
      case 9:
        uniqueID = node.documentElement.uniqueID;
        break;
      default:
        return null;}


    if (uniqueID) {
      return OLD_IE_HASH_PREFIX + uniqueID;
    } else {
      return null;
    }
  }

  var getHash = function () {
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    var hashProperty = guid();
    var hashCounter = 0;







    return function getHash(o) {

      if (o[hashProperty]) {
        return o[hashProperty];
      } else if (
      !isES5 &&
      o.propertyIsEnumerable &&
      o.propertyIsEnumerable[hashProperty])
      {
        return o.propertyIsEnumerable[hashProperty];
      } else if (!isES5 && isNode(o) && getIENodeHash(o)) {
        return getIENodeHash(o);
      } else if (!isES5 && o[hashProperty]) {
        return o[hashProperty];
      }

      if (isExtensible(o)) {
        hashCounter += 1;
        if (isES5) {
          Object.defineProperty(o, hashProperty, {
            enumerable: false,
            writable: false,
            configurable: false,
            value: hashCounter });

        } else if (o.propertyIsEnumerable) {




          o.propertyIsEnumerable = function () {
            return propIsEnumerable.apply(this, arguments);
          };
          o.propertyIsEnumerable[hashProperty] = hashCounter;
        } else if (isNode(o)) {




          o[hashProperty] = hashCounter;
        } else {
          throw new Error('Unable to set a non-enumerable property on object.');
        }
        return hashCounter;
      } else {
        throw new Error('Non-extensible objects are not allowed as keys.');
      }
    };
  }();

  return Map;
}(Function('return this')());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk1hcC5qcyJdLCJuYW1lcyI6WyJfc2hvdWxkUG9seWZpbGxFUzZDb2xsZWN0aW9uIiwicmVxdWlyZSIsImd1aWQiLCJpc05vZGUiLCJ0b0l0ZXJhdG9yIiwibW9kdWxlIiwiZXhwb3J0cyIsImdsb2JhbCIsInVuZGVmaW5lZCIsIk1hcCIsIktJTkRfS0VZIiwiS0lORF9WQUxVRSIsIktJTkRfS0VZX1ZBTFVFIiwiS0VZX1BSRUZJWCIsIlNFQ1JFVF9TSVpFX1BST1AiLCJfX0RFVl9fIiwiT0xEX0lFX0hBU0hfUFJFRklYIiwiaXRlcmFibGUiLCJpc09iamVjdCIsIlR5cGVFcnJvciIsImluaXRNYXAiLCJpdCIsIm5leHQiLCJkb25lIiwidmFsdWUiLCJzZXQiLCJrZXkiLCJpbmRleCIsImdldEluZGV4IiwiX21hcERhdGEiLCJwdXNoIiwic2V0SW5kZXgiLCJzaXplIiwiTWFwSXRlcmF0b3IiLCJjYWxsYmFjayIsInRoaXNBcmciLCJib3VuZENhbGxiYWNrIiwiYmluZCIsIm1hcERhdGEiLCJpIiwibGVuZ3RoIiwiZW50cnkiLCJwcm90b3R5cGUiLCJJVEVSQVRPUl9TWU1CT0wiLCJlbnRyaWVzIiwibWFwIiwia2luZCIsImluZGV4T2YiLCJFcnJvciIsIl9tYXAiLCJfbmV4dEluZGV4IiwiX2tpbmQiLCJjcmVhdGVJdGVyUmVzdWx0T2JqZWN0IiwicmVjb3JkIiwiaGFzaCIsImdldEhhc2giLCJfb2JqZWN0SW5kZXgiLCJwcmVmaXhlZEtleSIsIl9zdHJpbmdJbmRleCIsIl9vdGhlckluZGV4Iiwic2hvdWxkRGVsZXRlIiwiaXNFUzUiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25zb2xlIiwiZXJyb3IiLCJnZXQiLCJvIiwiZSIsImlzRXh0ZW5zaWJsZSIsImdldElFTm9kZUhhc2giLCJub2RlIiwidW5pcXVlSUQiLCJub2RlVHlwZSIsImRvY3VtZW50RWxlbWVudCIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImhhc2hQcm9wZXJ0eSIsImhhc2hDb3VudGVyIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiRnVuY3Rpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFhQSxhOztBQUVBLElBQU1BLCtCQUErQkMsUUFBUSw4QkFBUixDQUFyQztBQUNBLElBQU1DLE9BQU9ELFFBQVEsTUFBUixDQUFiO0FBQ0EsSUFBTUUsU0FBU0YsUUFBUSxpQkFBUixDQUFmO0FBQ0EsSUFBTUcsYUFBYUgsUUFBUSxZQUFSLENBQW5COztBQUVBSSxPQUFPQyxPQUFQLEdBQWtCLFVBQVNDLE1BQVQsRUFBaUJDLFNBQWpCLEVBQTRCOzs7OztBQUs1QyxNQUFJLENBQUNSLDZCQUE2QixLQUE3QixDQUFMLEVBQTBDO0FBQ3hDLFdBQU9PLE9BQU9FLEdBQWQ7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeURELE1BQU1DLFdBQVcsS0FBakI7QUFDQSxNQUFNQyxhQUFhLE9BQW5CO0FBQ0EsTUFBTUMsaUJBQWlCLFdBQXZCOzs7O0FBSUEsTUFBTUMsYUFBYSxPQUFuQjs7OztBQUlBLE1BQUlDLHlCQUFKO0FBQ0EsTUFBSUMsT0FBSixFQUFhO0FBQ1hELHVCQUFtQixVQUFVWixNQUE3QjtBQUNEOzs7QUFHRCxNQUFNYyxxQkFBcUIsVUFBM0IsQ0FoRjRDOztBQWtGdENQLEtBbEZzQzs7Ozs7Ozs7OztBQTRGMUMsaUJBQVlRLFFBQVosRUFBc0I7QUFDcEIsVUFBSSxDQUFDQyxTQUFTLElBQVQsQ0FBTCxFQUFxQjtBQUNuQixjQUFNLElBQUlDLFNBQUosQ0FBYyx3QkFBZCxDQUFOO0FBQ0Q7O0FBRURDLGNBQVEsSUFBUjs7QUFFQSxVQUFJSCxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLFlBQU1JLEtBQUtqQixXQUFXYSxRQUFYLENBQVg7QUFDQSxZQUFJSyxhQUFKO0FBQ0EsZUFB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QVUsb0RBQVYsQ0FBTjtBQUNEO0FBQ0QsZUFBT2dDLFdBQVA7QUFDRCxPQTVCRCxNQTRCTztBQUNMLGNBQU0sSUFBSWhDLEtBQUosQ0FBVSxpREFBVixDQUFOO0FBQ0Q7QUFDRixLQS9DRDtBQWdERCxHQTNEZSxFQUFoQjs7QUE2REEsU0FBT3ZDLEdBQVA7QUFDRCxDQW5sQmdCLENBbWxCZDRFLFNBQVMsYUFBVCxHQW5sQmMsQ0FBakIiLCJmaWxlIjoiTWFwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZm9ybWF0XG4gKiBAcHJldmVudE11bmdlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWV4dGVuZC1uYXRpdmUsIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgX3Nob3VsZFBvbHlmaWxsRVM2Q29sbGVjdGlvbiA9IHJlcXVpcmUoJ19zaG91bGRQb2x5ZmlsbEVTNkNvbGxlY3Rpb24nKTtcbmNvbnN0IGd1aWQgPSByZXF1aXJlKCdndWlkJyk7XG5jb25zdCBpc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9pc05vZGUnKTtcbmNvbnN0IHRvSXRlcmF0b3IgPSByZXF1aXJlKCd0b0l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gIC8vIFNpbmNlIG91ciBpbXBsZW1lbnRhdGlvbiBpcyBzcGVjLWNvbXBsaWFudCBmb3IgdGhlIG1vc3QgcGFydCB3ZSBjYW4gc2FmZWx5XG4gIC8vIGRlbGVnYXRlIHRvIGEgYnVpbHQtaW4gdmVyc2lvbiBpZiBleGlzdHMgYW5kIGlzIGltcGxlbWVudGVkIGNvcnJlY3RseS5cbiAgLy8gRmlyZWZveCBoYWQgZ290dGVuIGEgZmV3IGltcGxlbWVudGF0aW9uIGRldGFpbHMgd3JvbmcgYWNyb3NzIGRpZmZlcmVudFxuICAvLyB2ZXJzaW9ucyBzbyB3ZSBndWFyZCBhZ2FpbnN0IHRoYXQuXG4gIGlmICghX3Nob3VsZFBvbHlmaWxsRVM2Q29sbGVjdGlvbignTWFwJykpIHtcbiAgICByZXR1cm4gZ2xvYmFsLk1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiA9PSBFUzYgTWFwIENvbGxlY3Rpb24gPT1cbiAgICpcbiAgICogVGhpcyBtb2R1bGUgaXMgbWVhbnQgdG8gaW1wbGVtZW50IGEgTWFwIGNvbGxlY3Rpb24gYXMgZGVzY3JpYmVkIGluIGNoYXB0ZXJcbiAgICogMjMuMSBvZiB0aGUgRVM2IHNwZWNpZmljYXRpb24uXG4gICAqXG4gICAqIE1hcCBvYmplY3RzIGFyZSBjb2xsZWN0aW9ucyBvZiBrZXkvdmFsdWUgcGFpcnMgd2hlcmUgYm90aCB0aGUga2V5cyBhbmRcbiAgICogdmFsdWVzIG1heSBiZSBhcmJpdHJhcnkgRUNNQVNjcmlwdCBsYW5ndWFnZSB2YWx1ZXMuIEEgZGlzdGluY3Qga2V5IHZhbHVlXG4gICAqIG1heSBvbmx5IG9jY3VyIGluIG9uZSBrZXkvdmFsdWUgcGFpciB3aXRoaW4gdGhlIE1hcCdzIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1tYXAtb2JqZWN0c1xuICAgKlxuICAgKiBUaGVyZSBvbmx5IHR3byAtLSByYXRoZXIgc21hbGwgLS0gZGl2aWF0aW9ucyBmcm9tIHRoZSBzcGVjOlxuICAgKlxuICAgKiAxLiBUaGUgdXNlIG9mIGZyb3plbiBvYmplY3RzIGFzIGtleXMuXG4gICAqICAgIFdlIGRlY2lkZWQgbm90IHRvIGFsbG93IGFuZCBzaW1wbHkgdGhyb3cgYW4gZXJyb3IuIFRoZSByZWFzb24gYmVpbmcgaXNcbiAgICogICAgd2Ugc3RvcmUgYSBcImhhc2hcIiBvbiB0aGUgb2JqZWN0IGZvciBmYXN0IGFjY2VzcyB0byBpdCdzIHBsYWNlIGluIHRoZVxuICAgKiAgICBpbnRlcm5hbCBtYXAgZW50cmllcy5cbiAgICogICAgSWYgdGhpcyB0dXJucyBvdXQgdG8gYmUgYSBwb3B1bGFyIHVzZSBjYXNlIGl0J3MgcG9zc2libGUgdG8gaW1wbGVtZW50IGJ5XG4gICAqICAgIG92ZXJpZGluZyBgT2JqZWN0LmZyZWV6ZWAgdG8gc3RvcmUgYSBcImhhc2hcIiBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG4gICAqICAgIGZvciBsYXRlciB1c2Ugd2l0aCB0aGUgbWFwLlxuICAgKlxuICAgKiAyLiBUaGUgYHNpemVgIHByb3BlcnR5IG9uIGEgbWFwIG9iamVjdCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkgYW5kIG5vdCBhXG4gICAqICAgIGNvbXB1dGVkIHByb3BlcnR5IG9uIHRoZSBwcm90b3R5cGUgYXMgZGVzY3JpYmVkIGJ5IHRoZSBzcGVjLlxuICAgKiAgICBUaGUgcmVhc29uIGJlaW5nIGlzIHRoYXQgd2Ugc2ltcGx5IHdhbnQgdG8gc3VwcG9ydCBFUzMgZW52aXJvbm1lbnRzXG4gICAqICAgIHdoaWNoIGRvZXNuJ3QgaW1wbGVtZW50IGNvbXB1dGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqID09IFVzYWdlID09XG4gICAqXG4gICAqIHZhciBtYXAgPSBuZXcgTWFwKGl0ZXJhYmxlKTtcbiAgICpcbiAgICogbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICogbWFwLmdldChrZXkpOyAvLyB2YWx1ZVxuICAgKiBtYXAuaGFzKGtleSk7IC8vIHRydWVcbiAgICogbWFwLmRlbGV0ZShrZXkpOyAvLyB0cnVlXG4gICAqXG4gICAqIHZhciBpdGVyYXRvciA9IG1hcC5rZXlzKCk7XG4gICAqIGl0ZXJhdG9yLm5leHQoKTsgLy8ge3ZhbHVlOiBrZXksIGRvbmU6IGZhbHNlfVxuICAgKlxuICAgKiB2YXIgaXRlcmF0b3IgPSBtYXAudmFsdWVzKCk7XG4gICAqIGl0ZXJhdG9yLm5leHQoKTsgLy8ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogZmFsc2V9XG4gICAqXG4gICAqIHZhciBpdGVyYXRvciA9IG1hcC5lbnRyaWVzKCk7XG4gICAqIGl0ZXJhdG9yLm5leHQoKTsgLy8ge3ZhbHVlOiBba2V5LCB2YWx1ZV0sIGRvbmU6IGZhbHNlfVxuICAgKlxuICAgKiBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KXsgdGhpcyA9PT0gdGhpc0FyZyB9LCB0aGlzQXJnKTtcbiAgICpcbiAgICogbWFwLmNsZWFyKCk7IC8vIHJlc2V0cyBtYXAuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgLy8gS2luZHMgb2YgbWFwIGl0ZXJhdGlvbnMgMjMuMS41LjNcbiAgY29uc3QgS0lORF9LRVkgPSAna2V5JztcbiAgY29uc3QgS0lORF9WQUxVRSA9ICd2YWx1ZSc7XG4gIGNvbnN0IEtJTkRfS0VZX1ZBTFVFID0gJ2tleSt2YWx1ZSc7XG5cbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgd2UgY2FuJ3QgY3JlYXRlIGEgbnVsbC1wcm90b3R5cGUgb2JqZWN0IHNvIHdlIGhhdmUgdG9cbiAgLy8gZGVmZW5kIGFnYWluc3Qga2V5IGNvbGxpc2lvbnMgd2l0aCBidWlsdC1pbiBtZXRob2RzLlxuICBjb25zdCBLRVlfUFJFRklYID0gJyRtYXBfJztcblxuICAvLyBUaGlzIHByb3BlcnR5IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW50ZXJuYWwgc2l6ZSB2YXJpYWJsZSB0byBkaXNhbGxvd1xuICAvLyB3cml0aW5nIGFuZCB0byBpc3N1ZSB3YXJuaW5ncyBmb3Igd3JpdGluZ3MgaW4gZGV2ZWxvcG1lbnQuXG4gIGxldCBTRUNSRVRfU0laRV9QUk9QO1xuICBpZiAoX19ERVZfXykge1xuICAgIFNFQ1JFVF9TSVpFX1BST1AgPSAnJHNpemUnICsgZ3VpZCgpO1xuICB9XG5cbiAgLy8gSW4gb2xkSUUgd2UgdXNlIHRoZSBET00gTm9kZSBgdW5pcXVlSURgIHByb3BlcnR5IHRvIGdldCBjcmVhdGUgdGhlIGhhc2guXG4gIGNvbnN0IE9MRF9JRV9IQVNIX1BSRUZJWCA9ICdJRV9IQVNIXyc7XG5cbiAgY2xhc3MgTWFwIHtcbiAgICAvKipcbiAgICAgKiAyMy4xLjEuMVxuICAgICAqIFRha2VzIGFuIGBpdGVyYWJsZWAgd2hpY2ggaXMgYmFzaWNhbGx5IGFueSBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIGFcbiAgICAgKiBTeW1ib2wuaXRlcmF0b3IgKEBAaXRlcmF0b3IpIG1ldGhvZC4gVGhlIGl0ZXJhYmxlIGlzIGV4cGVjdGVkIHRvIGJlIGFcbiAgICAgKiBjb2xsZWN0aW9uIG9mIHBhaXJzLiBFYWNoIHBhaXIgaXMgYSBrZXkvdmFsdWUgcGFpciB0aGF0IHdpbGwgYmUgdXNlZFxuICAgICAqIHRvIGluc3RhbnRpYXRlIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGl0ZXJhYmxlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaXRlcmFibGUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JvbmcgbWFwIG9iamVjdCB0eXBlLicpO1xuICAgICAgfVxuXG4gICAgICBpbml0TWFwKHRoaXMpO1xuXG4gICAgICBpZiAoaXRlcmFibGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBpdCA9IHRvSXRlcmF0b3IoaXRlcmFibGUpO1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IGl0Lm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmICghaXNPYmplY3QobmV4dC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGl0ZXJhYmxlIGl0ZW1zIHRvIGJlIHBhaXIgb2JqZWN0cy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXQobmV4dC52YWx1ZVswXSwgbmV4dC52YWx1ZVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAyMy4xLjMuMVxuICAgICAqIENsZWFycyB0aGUgbWFwIGZyb20gYWxsIGtleXMgYW5kIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgIGluaXRNYXAodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogMjMuMS4zLjdcbiAgICAgKiBDaGVjayBpZiBhIGtleSBleGlzdHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleCh0aGlzLCBrZXkpO1xuICAgICAgcmV0dXJuICEhKGluZGV4ICE9IG51bGwgJiYgdGhpcy5fbWFwRGF0YVtpbmRleF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuMy45XG4gICAgICogQWRkcyBhIGtleS92YWx1ZSBwYWlyIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7bWFwfVxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBsZXQgaW5kZXggPSBnZXRJbmRleCh0aGlzLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiB0aGlzLl9tYXBEYXRhW2luZGV4XSkge1xuICAgICAgICB0aGlzLl9tYXBEYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9tYXBEYXRhLnB1c2goW2tleSwgdmFsdWVdKSAtIDE7XG4gICAgICAgIHNldEluZGV4KHRoaXMsIGtleSwgaW5kZXgpO1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgIHRoaXNbU0VDUkVUX1NJWkVfUFJPUF0gKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNpemUgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAyMy4xLjMuNlxuICAgICAqIEdldHMgYSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBrZXkgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleCh0aGlzLCBrZXkpO1xuICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBEYXRhW2luZGV4XVsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAyMy4xLjMuM1xuICAgICAqIERlbGV0ZSBhIGtleS92YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBrZXkgd2FzIGZvdW5kIGFuZCBkZWxldGVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgodGhpcywga2V5KTtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsICYmIHRoaXMuX21hcERhdGFbaW5kZXhdKSB7XG4gICAgICAgIHNldEluZGV4KHRoaXMsIGtleSwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fbWFwRGF0YVtpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgdGhpc1tTRUNSRVRfU0laRV9QUk9QXSAtPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2l6ZSAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuMy40XG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBrZXkvdmFsdWUgcGFpcnMgKGluIHRoZSBmb3JtIG9mIGFuIEFycmF5KSBpblxuICAgICAqIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TWFwSXRlcmF0b3J9XG4gICAgICovXG4gICAgZW50cmllcygpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgS0lORF9LRVlfVkFMVUUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuMy44XG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBrZXlzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TWFwSXRlcmF0b3J9XG4gICAgICovXG4gICAga2V5cygpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgS0lORF9LRVkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuMy4xMVxuICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgdmFsdWVzIHBhaXJzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TWFwSXRlcmF0b3J9XG4gICAgICovXG4gICAgdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLCBLSU5EX1ZBTFVFKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAyMy4xLjMuNVxuICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgY29sbGVjdGlvbiBjYWxsaW5nIGBjYWxsYmFja2BcbiAgICAgKiB3aXRoIFt2YWx1ZSwga2V5LCBtYXBdLiBBbiBvcHRpb25hbCBgdGhpc0FyZ2AgY2FuIGJlIHBhc3NlZCB0byBzZXQgdGhlXG4gICAgICogY29udGV4dCB3aGVuIGBjYWxsYmFja2AgaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgY2FsbGFibGUuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvdW5kQ2FsbGJhY2sgPSBjYWxsYmFjay5iaW5kKHRoaXNBcmcgfHwgdW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IG1hcERhdGEgPSB0aGlzLl9tYXBEYXRhO1xuXG4gICAgICAvLyBOb3RlIHRoYXQgYG1hcERhdGEubGVuZ3RoYCBzaG91bGQgYmUgY29tcHV0ZWQgb24gZWFjaCBpdGVyYXRpb24gdG9cbiAgICAgIC8vIHN1cHBvcnQgaXRlcmF0aW5nIG92ZXIgbmV3IGl0ZW1zIGluIHRoZSBtYXAgdGhhdCB3ZXJlIGFkZGVkIGFmdGVyIHRoZVxuICAgICAgLy8gc3RhcnQgb2YgdGhlIGl0ZXJhdGlvbi5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG1hcERhdGFbaV07XG4gICAgICAgIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgYm91bmRDYWxsYmFjayhlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMjMuMS4zLjEyXG4gIE1hcC5wcm90b3R5cGVbdG9JdGVyYXRvci5JVEVSQVRPUl9TWU1CT0xdID0gTWFwLnByb3RvdHlwZS5lbnRyaWVzO1xuXG4gIGNsYXNzIE1hcEl0ZXJhdG9yIHtcbiAgICAvKipcbiAgICAgKiAyMy4xLjUuMVxuICAgICAqIENyZWF0ZSBhIGBNYXBJdGVyYXRvcmAgZm9yIGEgZ2l2ZW4gYG1hcGAuIFdoaWxlIHRoaXMgY2xhc3MgaXMgcHJpdmF0ZSBpdFxuICAgICAqIHdpbGwgY3JlYXRlIG9iamVjdHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBhcm91bmQgcHVibGljaWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHttYXB9IG1hcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWFwLCBraW5kKSB7XG4gICAgICBpZiAoIShpc09iamVjdChtYXApICYmIG1hcC5fbWFwRGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IGlzIG5vdCBhIG1hcC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFtLSU5EX0tFWSwgS0lORF9LRVlfVkFMVUUsIEtJTkRfVkFMVUVdLmluZGV4T2Yoa2luZCkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpdGVyYXRpb24ga2luZC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgdGhpcy5fbmV4dEluZGV4ID0gMDtcbiAgICAgIHRoaXMuX2tpbmQgPSBraW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuNS4yLjFcbiAgICAgKiBHZXQgdGhlIG5leHQgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICBpZiAoIXRoaXMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdG8gYmUgY2FsbGVkIG9uIGEgTWFwSXRlcmF0b3IuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hcCA9IHRoaXMuX21hcDtcbiAgICAgIGxldCBpbmRleCA9IHRoaXMuX25leHRJbmRleDtcbiAgICAgIGNvbnN0IGtpbmQgPSB0aGlzLl9raW5kO1xuXG4gICAgICBpZiAobWFwID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW50cmllcyA9IG1hcC5fbWFwRGF0YTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gZW50cmllc1tpbmRleF07XG5cbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgdGhpcy5fbmV4dEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgIGlmIChraW5kID09PSBLSU5EX0tFWSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVjb3JkWzBdLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChraW5kID09PSBLSU5EX1ZBTFVFKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChyZWNvcmRbMV0sIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHJlY29yZCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgY2FuIHB1dCB0aGlzIGluIHRoZSBjbGFzcyBkZWZpbml0aW9uIG9uY2Ugd2UgaGF2ZSBjb21wdXRlZCBwcm9wc1xuICAvLyB0cmFuc2Zvcm0uXG4gIC8vIDIzLjEuNS4yLjJcbiAgTWFwSXRlcmF0b3IucHJvdG90eXBlW3RvSXRlcmF0b3IuSVRFUkFUT1JfU1lNQk9MXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgRnVuY3Rpb25zLlxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGluZGV4IHRvIG1hcC5bW01hcERhdGFdXSBhcnJheSBmb3IgYSBnaXZlbiBLZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bWFwfSBtYXBcbiAgICogQHBhcmFtIHsqfSBrZXlcbiAgICogQHJldHVybiB7P251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEluZGV4KG1hcCwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBnZXRIYXNoKGtleSk7XG4gICAgICByZXR1cm4gbWFwLl9vYmplY3RJbmRleFtoYXNoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJlZml4ZWRLZXkgPSBLRVlfUFJFRklYICsga2V5O1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXAuX3N0cmluZ0luZGV4W3ByZWZpeGVkS2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXAuX290aGVySW5kZXhbcHJlZml4ZWRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBhbiBpbmRleCB0aGF0IHJlZmVyIHRvIHRoZSBrZXkncyBsb2NhdGlvbiBpbiBtYXAuW1tNYXBEYXRhXV0uXG4gICAqXG4gICAqIEBwYXJhbSB7bWFwfSBtYXBcbiAgICogQHBhcmFtIHsqfSBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHNldEluZGV4KG1hcCwga2V5LCBpbmRleCkge1xuICAgIGNvbnN0IHNob3VsZERlbGV0ZSA9IGluZGV4ID09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgY29uc3QgaGFzaCA9IGdldEhhc2goa2V5KTtcbiAgICAgIGlmIChzaG91bGREZWxldGUpIHtcbiAgICAgICAgZGVsZXRlIG1hcC5fb2JqZWN0SW5kZXhbaGFzaF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAuX29iamVjdEluZGV4W2hhc2hdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkS2V5ID0gS0VZX1BSRUZJWCArIGtleTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoc2hvdWxkRGVsZXRlKSB7XG4gICAgICAgICAgZGVsZXRlIG1hcC5fc3RyaW5nSW5kZXhbcHJlZml4ZWRLZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcC5fc3RyaW5nSW5kZXhbcHJlZml4ZWRLZXldID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzaG91bGREZWxldGUpIHtcbiAgICAgICAgICBkZWxldGUgbWFwLl9vdGhlckluZGV4W3ByZWZpeGVkS2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXAuX290aGVySW5kZXhbcHJlZml4ZWRLZXldID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYSBtYXAgd2l0aCBpbnRlcm5hbCBzbG90cy5cbiAgICpcbiAgICogQHBhcmFtIHttYXB9IG1hcFxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdE1hcChtYXApIHtcbiAgICAvLyBEYXRhIHN0cnVjdHVyZSBkZXNpZ24gaW5zcGlyZWQgYnkgVHJhY2V1cidzIE1hcCBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLyBXZSBtYWludGFpbiBhbiBpbnRlcm5hbCBhcnJheSBmb3IgYWxsIHRoZSBlbnRyaWVzLiBUaGUgYXJyYXkgaXMgbmVlZGVkXG4gICAgLy8gdG8gcmVtZW1iZXIgb3JkZXIuIEhvd2V2ZXIsIHRvIGhhdmUgYSByZWFzb25hYmxlIEhhc2hNYXAgcGVyZm9ybWFuY2VcbiAgICAvLyBpLmUuIE8oMSkgZm9yIGluc2VydGlvbiwgZGVsZXRpb24sIGFuZCByZXRyaWV2YWwuIFdlIG1haW50YWluIGluZGljZXNcbiAgICAvLyBpbiBvYmplY3RzIGZvciBmYXN0IGxvb2sgdXBzLiBJbmRpY2VzIGFyZSBzcGxpdCB1cCBhY2NvcmRpbmcgdG8gZGF0YVxuICAgIC8vIHR5cGVzIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gICAgbWFwLl9tYXBEYXRhID0gW107XG5cbiAgICAvLyBPYmplY3QgaW5kZXggbWFwcyBmcm9tIGFuIG9iamVjdCBcImhhc2hcIiB0byBpbmRleC4gVGhlIGhhc2ggYmVpbmcgYSB1bmlxdWVcbiAgICAvLyBwcm9wZXJ0eSBvZiBvdXIgY2hvb3NpbmcgdGhhdCB3ZSBhc3NvY2lhdGUgd2l0aCB0aGUgb2JqZWN0LiBBc3NvY2lhdGlvblxuICAgIC8vIGlzIGRvbmUgYnkgd2F5cyBvZiBrZWVwaW5nIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG9iamVjdC5cbiAgICAvLyBJZGVhbGx5IHRoZXNlIHdvdWxkIGJlIGBPYmplY3QuY3JlYXRlKG51bGwpYCBvYmplY3RzIGJ1dCBzaW5jZSB3ZSdyZVxuICAgIC8vIHRyeWluZyB0byBzdXBwb3J0IEVTMyB3ZSdsbCBoYXZlIHRvIGd1YXJkIGFnYWluc3QgY29sbGlzaW9ucyB1c2luZ1xuICAgIC8vIHByZWZpeGVzIG9uIHRoZSBrZXlzIHJhdGhlciB0aGFuIHJlbHkgb24gbnVsbCBwcm90b3R5cGUgb2JqZWN0cy5cbiAgICBtYXAuX29iamVjdEluZGV4ID0ge307XG5cbiAgICAvLyBTdHJpbmcgaW5kZXggbWFwcyBmcm9tIHN0cmluZ3MgdG8gaW5kZXguXG4gICAgbWFwLl9zdHJpbmdJbmRleCA9IHt9O1xuXG4gICAgLy8gTnVtYmVycywgYm9vbGVhbnMsIHVuZGVmaW5lZCwgYW5kIG51bGwuXG4gICAgbWFwLl9vdGhlckluZGV4ID0ge307XG5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IHdlIGhhdmUgdG8gc3VwcG9ydCBFUzMgYW5kIGNhbm5vdCBoYXZlIGBNYXAucHJvdG90eXBlLnNpemVgXG4gICAgLy8gYmUgYSBnZXR0ZXIgbWV0aG9kIGJ1dCBqdXN0IGEgcmVndWxhciBtZXRob2QuIFRoZSBiaWdnZXN0IHByb2JsZW0gd2l0aFxuICAgIC8vIHRoaXMgaXMgc2FmZXR5LiBDbGllbnRzIGNhbiBjaGFuZ2UgdGhlIHNpemUgcHJvcGVydHkgZWFzaWx5IGFuZCBwb3NzaWJseVxuICAgIC8vIHdpdGhvdXQgbm90aWNpbmcgKGUuZy4gYGlmIChtYXAuc2l6ZSA9IDEpIHsuLn1gIGtpbmQgb2YgdHlwbykuIFdoYXQgd2VcbiAgICAvLyBjYW4gZG8gdG8gbWl0aWdhdGUgdXNlIGdldHRlcnMgYW5kIHNldHRlcnMgaW4gZGV2ZWxvcG1lbnQgdG8gZGlzYWxsb3dcbiAgICAvLyBhbmQgaXNzdWUgYSB3YXJuaW5nIGZvciBjaGFuZ2luZyB0aGUgYHNpemVgIHByb3BlcnR5LlxuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAoaXNFUzUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGBTRUNSRVRfU0laRV9QUk9QYCBwcm9wZXJ0eSBpcyBhbHJlYWR5IGRlZmluZWQgdGhlbiB3ZSdyZSBub3RcbiAgICAgICAgLy8gaW4gdGhlIGZpcnN0IGNhbGwgdG8gYGluaXRNYXBgIChlLmcuIGNvbWluZyBmcm9tIGBtYXAuY2xlYXIoKWApIHNvXG4gICAgICAgIC8vIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHJlc2V0IHRoZSBzaXplIHdpdGhvdXQgZGVmaW5pbmcgdGhlIHByb3BlcnRpZXMuXG4gICAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkoU0VDUkVUX1NJWkVfUFJPUCkpIHtcbiAgICAgICAgICBtYXBbU0VDUkVUX1NJWkVfUFJPUF0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIFNFQ1JFVF9TSVpFX1BST1AsIHtcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgJ3NpemUnLCB7XG4gICAgICAgICAgICBzZXQ6IHYgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdQTEVBU0UgRklYIE1FOiBZb3UgYXJlIGNoYW5naW5nIHRoZSBtYXAgc2l6ZSBwcm9wZXJ0eSB3aGljaCAnICtcbiAgICAgICAgICAgICAgICAgICdzaG91bGQgbm90IGJlIHdyaXRhYmxlIGFuZCB3aWxsIGJyZWFrIGluIHByb2R1Y3Rpb24uJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbWFwIHNpemUgcHJvcGVydHkgaXMgbm90IHdyaXRhYmxlLicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gbWFwW1NFQ1JFVF9TSVpFX1BST1BdLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogRWFybHkgcmV0dXJuIHRvIGltcGxlbWVudCBpbW11dGFibGUgYC5zaXplYCBpbiBERVYuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGEgZGl2aWF0aW9uIGZyb20gdGhlIHNwZWMuIGBzaXplYCBzaG91bGQgYmUgYSBnZXR0ZXIgb25cbiAgICAvLyBgTWFwLnByb3RvdHlwZWAuIEhvd2V2ZXIsIHdlIGhhdmUgdG8gc3VwcG9ydCBJRTguXG4gICAgbWFwLnNpemUgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNvbWV0aGluZyBpcyBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICAgIHJldHVybiBvICE9IG51bGwgJiYgKHR5cGVvZiBvID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGl0ZXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBkb25lXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodmFsdWUsIGRvbmUpIHtcbiAgICByZXR1cm4ge3ZhbHVlLCBkb25lfTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBpbiBhIGxlZ2l0IEVTNSBlbnZpcm9ubWVudC4gU3BvaWxlciBhbGVydDogdGhhdCBkb2Vzbid0IGluY2x1ZGUgSUU4LlxuICBjb25zdCBpc0VTNSA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBjYW4gYmUgZXh0ZW5kZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fGZ1bmN0aW9ufHJlZ2V4cH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNFeHRlbnNpYmxlKG8pIHtcbiAgICBpZiAoIWlzRVM1KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUobyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIGB1bmlxdWVJRGAgc2V0IG9uIGV2ZXJ5IERPTSBub2RlLiBTbyB3ZSBjb25zdHJ1Y3QgdGhlIGhhc2ggZnJvbVxuICAgKiB0aGlzIHVuaXF1ZUlEIHRvIGF2b2lkIG1lbW9yeSBsZWFrcyBhbmQgdGhlIElFIGNsb25lTm9kZSBidWcgd2hlcmUgaXRcbiAgICogY2xvbmVzIHByb3BlcnRpZXMgaW4gYWRkaXRpb24gdG8gdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJRU5vZGVIYXNoKG5vZGUpIHtcbiAgICBsZXQgdW5pcXVlSUQ7XG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICBjYXNlIDE6IC8vIEVsZW1lbnRcbiAgICAgICAgdW5pcXVlSUQgPSBub2RlLnVuaXF1ZUlEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTogLy8gRG9jdW1lbnRcbiAgICAgICAgdW5pcXVlSUQgPSBub2RlLmRvY3VtZW50RWxlbWVudC51bmlxdWVJRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodW5pcXVlSUQpIHtcbiAgICAgIHJldHVybiBPTERfSUVfSEFTSF9QUkVGSVggKyB1bmlxdWVJRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZ2V0SGFzaCA9IChmdW5jdGlvbigpIHtcbiAgICBjb25zdCBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgICBjb25zdCBoYXNoUHJvcGVydHkgPSBndWlkKCk7XG4gICAgbGV0IGhhc2hDb3VudGVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgXCJoYXNoXCIgYXNzb2NpYXRlZCB3aXRoIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fGZ1bmN0aW9ufHJlZ2V4cH0gb1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0SGFzaChvKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuICAgICAgaWYgKG9baGFzaFByb3BlcnR5XSkge1xuICAgICAgICByZXR1cm4gb1toYXNoUHJvcGVydHldO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgIWlzRVM1ICYmXG4gICAgICAgIG8ucHJvcGVydHlJc0VudW1lcmFibGUgJiZcbiAgICAgICAgby5wcm9wZXJ0eUlzRW51bWVyYWJsZVtoYXNoUHJvcGVydHldXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG8ucHJvcGVydHlJc0VudW1lcmFibGVbaGFzaFByb3BlcnR5XTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRVM1ICYmIGlzTm9kZShvKSAmJiBnZXRJRU5vZGVIYXNoKG8pKSB7XG4gICAgICAgIHJldHVybiBnZXRJRU5vZGVIYXNoKG8pO1xuICAgICAgfSBlbHNlIGlmICghaXNFUzUgJiYgb1toYXNoUHJvcGVydHldKSB7XG4gICAgICAgIHJldHVybiBvW2hhc2hQcm9wZXJ0eV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0V4dGVuc2libGUobykpIHtcbiAgICAgICAgaGFzaENvdW50ZXIgKz0gMTtcbiAgICAgICAgaWYgKGlzRVM1KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGhhc2hQcm9wZXJ0eSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGhhc2hDb3VudGVyLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG8ucHJvcGVydHlJc0VudW1lcmFibGUpIHtcbiAgICAgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG4gICAgICAgICAgLy8gd2UnbGwgaGlqYWNrIG9uZSBvZiB0aGUgbGVzcy11c2VkIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgdG9cbiAgICAgICAgICAvLyBzYXZlIG91ciBoYXNoIG9uIGl0LiBBZGRpb3Rpb25hbGx5LCBzaW5jZSB0aGlzIGlzIGEgZnVuY3Rpb24gaXRcbiAgICAgICAgICAvLyB3aWxsIG5vdCBzaG93IHVwIGluIGBKU09OLnN0cmluZ2lmeWAgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgICAgIG8ucHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wSXNFbnVtZXJhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBvLnByb3BlcnR5SXNFbnVtZXJhYmxlW2hhc2hQcm9wZXJ0eV0gPSBoYXNoQ291bnRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChpc05vZGUobykpIHtcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGNvdWxkbid0IGdldCB0aGUgSUUgYHVuaXF1ZUlEYCB0byB1c2UgYXMgYSBoYXNoXG4gICAgICAgICAgLy8gYW5kIHdlIGNvdWxkbid0IHVzZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IHRvIGV4cGxvaXQgdGhlXG4gICAgICAgICAgLy8gZG9udEVudW0gYnVnIHNvIHdlIHNpbXBseSBhZGQgdGhlIGBoYXNoUHJvcGVydHlgIG9uIHRoZSBub2RlXG4gICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgIG9baGFzaFByb3BlcnR5XSA9IGhhc2hDb3VudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNldCBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzaENvdW50ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1leHRlbnNpYmxlIG9iamVjdHMgYXJlIG5vdCBhbGxvd2VkIGFzIGtleXMuJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcblxuICByZXR1cm4gTWFwO1xufSkoRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LWZ1bmNcbiJdfQ==