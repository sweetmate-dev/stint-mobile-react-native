{"version":3,"sources":["Map.js"],"names":["_shouldPolyfillES6Collection","require","guid","isNode","toIterator","module","exports","global","undefined","Map","KIND_KEY","KIND_VALUE","KIND_KEY_VALUE","KEY_PREFIX","SECRET_SIZE_PROP","__DEV__","OLD_IE_HASH_PREFIX","iterable","isObject","TypeError","initMap","it","next","done","value","set","key","index","getIndex","_mapData","push","setIndex","size","MapIterator","callback","thisArg","boundCallback","bind","mapData","i","length","entry","prototype","ITERATOR_SYMBOL","entries","map","kind","indexOf","Error","_map","_nextIndex","_kind","createIterResultObject","record","hash","getHash","_objectIndex","prefixedKey","_stringIndex","_otherIndex","shouldDelete","isES5","hasOwnProperty","Object","defineProperty","writable","console","error","get","o","e","isExtensible","getIENodeHash","node","uniqueID","nodeType","documentElement","propIsEnumerable","propertyIsEnumerable","hashProperty","hashCounter","enumerable","configurable","apply","arguments","Function"],"mappings":"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","file":"Map.js","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @preventMunge\n * @typechecks\n */\n\n/* eslint-disable no-extend-native, no-shadow-restricted-names */\n\n'use strict';\n\nconst _shouldPolyfillES6Collection = require('_shouldPolyfillES6Collection');\nconst guid = require('guid');\nconst isNode = require('fbjs/lib/isNode');\nconst toIterator = require('toIterator');\n\nmodule.exports = (function(global, undefined) {\n  // Since our implementation is spec-compliant for the most part we can safely\n  // delegate to a built-in version if exists and is implemented correctly.\n  // Firefox had gotten a few implementation details wrong across different\n  // versions so we guard against that.\n  if (!_shouldPolyfillES6Collection('Map')) {\n    return global.Map;\n  }\n\n  /**\n   * == ES6 Map Collection ==\n   *\n   * This module is meant to implement a Map collection as described in chapter\n   * 23.1 of the ES6 specification.\n   *\n   * Map objects are collections of key/value pairs where both the keys and\n   * values may be arbitrary ECMAScript language values. A distinct key value\n   * may only occur in one key/value pair within the Map's collection.\n   *\n   * https://people.mozilla.org/~jorendorff/es6-draft.html#sec-map-objects\n   *\n   * There only two -- rather small -- diviations from the spec:\n   *\n   * 1. The use of frozen objects as keys.\n   *    We decided not to allow and simply throw an error. The reason being is\n   *    we store a \"hash\" on the object for fast access to it's place in the\n   *    internal map entries.\n   *    If this turns out to be a popular use case it's possible to implement by\n   *    overiding `Object.freeze` to store a \"hash\" property on the object\n   *    for later use with the map.\n   *\n   * 2. The `size` property on a map object is a regular property and not a\n   *    computed property on the prototype as described by the spec.\n   *    The reason being is that we simply want to support ES3 environments\n   *    which doesn't implement computed properties.\n   *\n   * == Usage ==\n   *\n   * var map = new Map(iterable);\n   *\n   * map.set(key, value);\n   * map.get(key); // value\n   * map.has(key); // true\n   * map.delete(key); // true\n   *\n   * var iterator = map.keys();\n   * iterator.next(); // {value: key, done: false}\n   *\n   * var iterator = map.values();\n   * iterator.next(); // {value: value, done: false}\n   *\n   * var iterator = map.entries();\n   * iterator.next(); // {value: [key, value], done: false}\n   *\n   * map.forEach(function(value, key){ this === thisArg }, thisArg);\n   *\n   * map.clear(); // resets map.\n   */\n\n  /**\n   * Constants\n   */\n\n  // Kinds of map iterations 23.1.5.3\n  const KIND_KEY = 'key';\n  const KIND_VALUE = 'value';\n  const KIND_KEY_VALUE = 'key+value';\n\n  // In older browsers we can't create a null-prototype object so we have to\n  // defend against key collisions with built-in methods.\n  const KEY_PREFIX = '$map_';\n\n  // This property will be used as the internal size variable to disallow\n  // writing and to issue warnings for writings in development.\n  let SECRET_SIZE_PROP;\n  if (__DEV__) {\n    SECRET_SIZE_PROP = '$size' + guid();\n  }\n\n  // In oldIE we use the DOM Node `uniqueID` property to get create the hash.\n  const OLD_IE_HASH_PREFIX = 'IE_HASH_';\n\n  class Map {\n    /**\n     * 23.1.1.1\n     * Takes an `iterable` which is basically any object that implements a\n     * Symbol.iterator (@@iterator) method. The iterable is expected to be a\n     * collection of pairs. Each pair is a key/value pair that will be used\n     * to instantiate the map.\n     *\n     * @param {*} iterable\n     */\n    constructor(iterable) {\n      if (!isObject(this)) {\n        throw new TypeError('Wrong map object type.');\n      }\n\n      initMap(this);\n\n      if (iterable != null) {\n        const it = toIterator(iterable);\n        let next;\n        while (!(next = it.next()).done) {\n          if (!isObject(next.value)) {\n            throw new TypeError('Expected iterable items to be pair objects.');\n          }\n          this.set(next.value[0], next.value[1]);\n        }\n      }\n    }\n\n    /**\n     * 23.1.3.1\n     * Clears the map from all keys and values.\n     */\n    clear() {\n      initMap(this);\n    }\n\n    /**\n     * 23.1.3.7\n     * Check if a key exists in the collection.\n     *\n     * @param {*} key\n     * @return {boolean}\n     */\n    has(key) {\n      const index = getIndex(this, key);\n      return !!(index != null && this._mapData[index]);\n    }\n\n    /**\n     * 23.1.3.9\n     * Adds a key/value pair to the collection.\n     *\n     * @param {*} key\n     * @param {*} value\n     * @return {map}\n     */\n    set(key, value) {\n      let index = getIndex(this, key);\n\n      if (index != null && this._mapData[index]) {\n        this._mapData[index][1] = value;\n      } else {\n        index = this._mapData.push([key, value]) - 1;\n        setIndex(this, key, index);\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] += 1;\n        } else {\n          this.size += 1;\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * 23.1.3.6\n     * Gets a value associated with a key in the collection.\n     *\n     * @param {*} key\n     * @return {*}\n     */\n    get(key) {\n      const index = getIndex(this, key);\n      if (index == null) {\n        return undefined;\n      } else {\n        return this._mapData[index][1];\n      }\n    }\n\n    /**\n     * 23.1.3.3\n     * Delete a key/value from the collection.\n     *\n     * @param {*} key\n     * @return {boolean} Whether the key was found and deleted.\n     */\n    delete(key) {\n      const index = getIndex(this, key);\n      if (index != null && this._mapData[index]) {\n        setIndex(this, key, undefined);\n        this._mapData[index] = undefined;\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] -= 1;\n        } else {\n          this.size -= 1;\n        }\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * 23.1.3.4\n     * Returns an iterator over the key/value pairs (in the form of an Array) in\n     * the collection.\n     *\n     * @return {MapIterator}\n     */\n    entries() {\n      return new MapIterator(this, KIND_KEY_VALUE);\n    }\n\n    /**\n     * 23.1.3.8\n     * Returns an iterator over the keys in the collection.\n     *\n     * @return {MapIterator}\n     */\n    keys() {\n      return new MapIterator(this, KIND_KEY);\n    }\n\n    /**\n     * 23.1.3.11\n     * Returns an iterator over the values pairs in the collection.\n     *\n     * @return {MapIterator}\n     */\n    values() {\n      return new MapIterator(this, KIND_VALUE);\n    }\n\n    /**\n     * 23.1.3.5\n     * Iterates over the key/value pairs in the collection calling `callback`\n     * with [value, key, map]. An optional `thisArg` can be passed to set the\n     * context when `callback` is called.\n     *\n     * @param {function} callback\n     * @param {?object} thisArg\n     */\n    forEach(callback, thisArg) {\n      if (typeof callback !== 'function') {\n        throw new TypeError('Callback must be callable.');\n      }\n\n      const boundCallback = callback.bind(thisArg || undefined);\n      const mapData = this._mapData;\n\n      // Note that `mapData.length` should be computed on each iteration to\n      // support iterating over new items in the map that were added after the\n      // start of the iteration.\n      for (let i = 0; i < mapData.length; i++) {\n        const entry = mapData[i];\n        if (entry != null) {\n          boundCallback(entry[1], entry[0], this);\n        }\n      }\n    }\n  }\n\n  // 23.1.3.12\n  Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;\n\n  class MapIterator {\n    /**\n     * 23.1.5.1\n     * Create a `MapIterator` for a given `map`. While this class is private it\n     * will create objects that will be passed around publicily.\n     *\n     * @param {map} map\n     * @param {string} kind\n     */\n    constructor(map, kind) {\n      if (!(isObject(map) && map._mapData)) {\n        throw new TypeError('Object is not a map.');\n      }\n\n      if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {\n        throw new Error('Invalid iteration kind.');\n      }\n\n      this._map = map;\n      this._nextIndex = 0;\n      this._kind = kind;\n    }\n\n    /**\n     * 23.1.5.2.1\n     * Get the next iteration.\n     *\n     * @return {object}\n     */\n    next() {\n      if (!this instanceof Map) {\n        throw new TypeError('Expected to be called on a MapIterator.');\n      }\n\n      const map = this._map;\n      let index = this._nextIndex;\n      const kind = this._kind;\n\n      if (map == null) {\n        return createIterResultObject(undefined, true);\n      }\n\n      const entries = map._mapData;\n\n      while (index < entries.length) {\n        const record = entries[index];\n\n        index += 1;\n        this._nextIndex = index;\n\n        if (record) {\n          if (kind === KIND_KEY) {\n            return createIterResultObject(record[0], false);\n          } else if (kind === KIND_VALUE) {\n            return createIterResultObject(record[1], false);\n          } else if (kind) {\n            return createIterResultObject(record, false);\n          }\n        }\n      }\n\n      this._map = undefined;\n\n      return createIterResultObject(undefined, true);\n    }\n  }\n\n  // We can put this in the class definition once we have computed props\n  // transform.\n  // 23.1.5.2.2\n  MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function() {\n    return this;\n  };\n\n  /**\n   * Helper Functions.\n   */\n\n  /**\n   * Return an index to map.[[MapData]] array for a given Key.\n   *\n   * @param {map} map\n   * @param {*} key\n   * @return {?number}\n   */\n  function getIndex(map, key) {\n    if (isObject(key)) {\n      const hash = getHash(key);\n      return map._objectIndex[hash];\n    } else {\n      const prefixedKey = KEY_PREFIX + key;\n      if (typeof key === 'string') {\n        return map._stringIndex[prefixedKey];\n      } else {\n        return map._otherIndex[prefixedKey];\n      }\n    }\n  }\n\n  /**\n   * Setup an index that refer to the key's location in map.[[MapData]].\n   *\n   * @param {map} map\n   * @param {*} key\n   */\n  function setIndex(map, key, index) {\n    const shouldDelete = index == null;\n\n    if (isObject(key)) {\n      const hash = getHash(key);\n      if (shouldDelete) {\n        delete map._objectIndex[hash];\n      } else {\n        map._objectIndex[hash] = index;\n      }\n    } else {\n      const prefixedKey = KEY_PREFIX + key;\n      if (typeof key === 'string') {\n        if (shouldDelete) {\n          delete map._stringIndex[prefixedKey];\n        } else {\n          map._stringIndex[prefixedKey] = index;\n        }\n      } else {\n        if (shouldDelete) {\n          delete map._otherIndex[prefixedKey];\n        } else {\n          map._otherIndex[prefixedKey] = index;\n        }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a map with internal slots.\n   *\n   * @param {map} map\n   */\n  function initMap(map) {\n    // Data structure design inspired by Traceur's Map implementation.\n    // We maintain an internal array for all the entries. The array is needed\n    // to remember order. However, to have a reasonable HashMap performance\n    // i.e. O(1) for insertion, deletion, and retrieval. We maintain indices\n    // in objects for fast look ups. Indices are split up according to data\n    // types to avoid collisions.\n    map._mapData = [];\n\n    // Object index maps from an object \"hash\" to index. The hash being a unique\n    // property of our choosing that we associate with the object. Association\n    // is done by ways of keeping a non-enumerable property on the object.\n    // Ideally these would be `Object.create(null)` objects but since we're\n    // trying to support ES3 we'll have to guard against collisions using\n    // prefixes on the keys rather than rely on null prototype objects.\n    map._objectIndex = {};\n\n    // String index maps from strings to index.\n    map._stringIndex = {};\n\n    // Numbers, booleans, undefined, and null.\n    map._otherIndex = {};\n\n    // Unfortunately we have to support ES3 and cannot have `Map.prototype.size`\n    // be a getter method but just a regular method. The biggest problem with\n    // this is safety. Clients can change the size property easily and possibly\n    // without noticing (e.g. `if (map.size = 1) {..}` kind of typo). What we\n    // can do to mitigate use getters and setters in development to disallow\n    // and issue a warning for changing the `size` property.\n    if (__DEV__) {\n      if (isES5) {\n        // If the `SECRET_SIZE_PROP` property is already defined then we're not\n        // in the first call to `initMap` (e.g. coming from `map.clear()`) so\n        // all we need to do is reset the size without defining the properties.\n        if (map.hasOwnProperty(SECRET_SIZE_PROP)) {\n          map[SECRET_SIZE_PROP] = 0;\n        } else {\n          Object.defineProperty(map, SECRET_SIZE_PROP, {\n            value: 0,\n            writable: true,\n          });\n          Object.defineProperty(map, 'size', {\n            set: v => {\n              console.error(\n                'PLEASE FIX ME: You are changing the map size property which ' +\n                  'should not be writable and will break in production.',\n              );\n              throw new Error('The map size property is not writable.');\n            },\n            get: () => map[SECRET_SIZE_PROP],\n          });\n        }\n\n        // NOTE: Early return to implement immutable `.size` in DEV.\n        return;\n      }\n    }\n\n    // This is a diviation from the spec. `size` should be a getter on\n    // `Map.prototype`. However, we have to support IE8.\n    map.size = 0;\n  }\n\n  /**\n   * Check if something is an object.\n   *\n   * @param {*} o\n   * @return {boolean}\n   */\n  function isObject(o) {\n    return o != null && (typeof o === 'object' || typeof o === 'function');\n  }\n\n  /**\n   * Create an iteration object.\n   *\n   * @param {*} value\n   * @param {boolean} done\n   * @return {object}\n   */\n  function createIterResultObject(value, done) {\n    return {value, done};\n  }\n\n  // Are we in a legit ES5 environment. Spoiler alert: that doesn't include IE8.\n  const isES5 = (function() {\n    try {\n      Object.defineProperty({}, 'x', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  /**\n   * Check if an object can be extended.\n   *\n   * @param {object|array|function|regexp} o\n   * @return {boolean}\n   */\n  function isExtensible(o) {\n    if (!isES5) {\n      return true;\n    } else {\n      return Object.isExtensible(o);\n    }\n  }\n\n  /**\n   * IE has a `uniqueID` set on every DOM node. So we construct the hash from\n   * this uniqueID to avoid memory leaks and the IE cloneNode bug where it\n   * clones properties in addition to the attributes.\n   *\n   * @param {object} node\n   * @return {?string}\n   */\n  function getIENodeHash(node) {\n    let uniqueID;\n    switch (node.nodeType) {\n      case 1: // Element\n        uniqueID = node.uniqueID;\n        break;\n      case 9: // Document\n        uniqueID = node.documentElement.uniqueID;\n        break;\n      default:\n        return null;\n    }\n\n    if (uniqueID) {\n      return OLD_IE_HASH_PREFIX + uniqueID;\n    } else {\n      return null;\n    }\n  }\n\n  const getHash = (function() {\n    const propIsEnumerable = Object.prototype.propertyIsEnumerable;\n    const hashProperty = guid();\n    let hashCounter = 0;\n\n    /**\n     * Get the \"hash\" associated with an object.\n     *\n     * @param {object|array|function|regexp} o\n     * @return {number}\n     */\n    return function getHash(o) {\n      // eslint-disable-line no-shadow\n      if (o[hashProperty]) {\n        return o[hashProperty];\n      } else if (\n        !isES5 &&\n        o.propertyIsEnumerable &&\n        o.propertyIsEnumerable[hashProperty]\n      ) {\n        return o.propertyIsEnumerable[hashProperty];\n      } else if (!isES5 && isNode(o) && getIENodeHash(o)) {\n        return getIENodeHash(o);\n      } else if (!isES5 && o[hashProperty]) {\n        return o[hashProperty];\n      }\n\n      if (isExtensible(o)) {\n        hashCounter += 1;\n        if (isES5) {\n          Object.defineProperty(o, hashProperty, {\n            enumerable: false,\n            writable: false,\n            configurable: false,\n            value: hashCounter,\n          });\n        } else if (o.propertyIsEnumerable) {\n          // Since we can't define a non-enumerable property on the object\n          // we'll hijack one of the less-used non-enumerable properties to\n          // save our hash on it. Addiotionally, since this is a function it\n          // will not show up in `JSON.stringify` which is what we want.\n          o.propertyIsEnumerable = function() {\n            return propIsEnumerable.apply(this, arguments);\n          };\n          o.propertyIsEnumerable[hashProperty] = hashCounter;\n        } else if (isNode(o)) {\n          // At this point we couldn't get the IE `uniqueID` to use as a hash\n          // and we couldn't use a non-enumerable property to exploit the\n          // dontEnum bug so we simply add the `hashProperty` on the node\n          // itself.\n          o[hashProperty] = hashCounter;\n        } else {\n          throw new Error('Unable to set a non-enumerable property on object.');\n        }\n        return hashCounter;\n      } else {\n        throw new Error('Non-extensible objects are not allowed as keys.');\n      }\n    };\n  })();\n\n  return Map;\n})(Function('return this')()); // eslint-disable-line no-new-func\n"]}